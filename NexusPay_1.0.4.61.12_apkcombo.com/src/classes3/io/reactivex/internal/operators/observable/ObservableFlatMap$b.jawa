record `io.reactivex.internal.operators.observable.ObservableFlatMap$b` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.disposables.Disposable` @kind interface, `io.reactivex.Observer` @kind interface {
  `io.reactivex.Observer` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @AccessFlag FINAL;
  `io.reactivex.functions.Function` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.b` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.c` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.e` @AccessFlag FINAL;
  `io.reactivex.internal.fuseable.SimplePlainQueue` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.f` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @AccessFlag VOLATILE;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.i` @AccessFlag VOLATILE;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @AccessFlag FINAL;
  `io.reactivex.disposables.Disposable` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.k` @AccessFlag ;
  `long` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.l` @AccessFlag ;
  `long` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.m` @AccessFlag ;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.n` @AccessFlag ;
  `java.util.Queue` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.o` @AccessFlag ;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @AccessFlag ;
}
global `io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.q` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.r` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L467820.  v0:= 0I;
  #L467822.  v1:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$a`[v0];
  #L467826.  `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.q` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] := v1 @kind object;
  #L46782a.  v0:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$a`[v0];
  #L46782e.  `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.r` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] := v0 @kind object;
  #L467832.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this, `io.reactivex.Observer` v2 @kind object, `io.reactivex.functions.Function` v3 @kind object, `boolean` v4 , `int` v5 , `int` v6 ) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.<init>:(Lio/reactivex/Observer;Lio/reactivex/functions/Function;ZII)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L467844.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L46784a.  v0:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L46784e.  call `<init>`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L467854.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` := v0 @kind object;
  #L467858.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @type ^`io.reactivex.Observer` := v2 @kind object;
  #L46785c.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.b` @type ^`io.reactivex.functions.Function` := v3 @kind object;
  #L467860.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.c` @type ^`boolean` := v4 @kind boolean;
  #L467864.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int` := v5;
  #L467868.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.e` @type ^`int` := v6;
  #L46786c.  v2:= 2147483647I;
  #L467872.  if v5 == v2 then goto L467884;
  #L467876.  v2:= new `java.util.ArrayDeque`;
  #L46787a.  call `<init>`(v2, v5) @signature `Ljava/util/ArrayDeque;.<init>:(I)V` @kind direct;
  #L467880.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.o` @type ^`java.util.Queue` := v2 @kind object;
  #L467884.  v2:= new `java.util.concurrent.atomic.AtomicReference`;
  #L467888.  v3:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.q` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] @kind object;
  #L46788c.  call `<init>`(v2, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L467892.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` := v2 @kind object;
  #L467896.  return @kind void;
}
procedure `boolean` `a`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v4 @kind this, `io.reactivex.internal.operators.observable.ObservableFlatMap$a` v5 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.a:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4675f8.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4675fc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L467602.  v0:= temp @kind object;
  #L467604.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[]) v0 @kind object;
  #L467608.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.r` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] @kind object;
  #L46760c.  v2:= 0I;
  #L46760e.  if v0 != v1 then goto L46761a;
  #L467612.  call `a`(v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;.a:()V` @kind virtual;
  #L467618.  return v2;
  #L46761a.  v1:= length @variable v0;
  #L46761c.  v3:= v1 + 1;
  #L467620.  v3:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$a`[v3];
  #L467624.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L46762a.  v3[v1]:= v5 @kind object;
  #L46762e.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L467632.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L467638.  v0:= temp;
  #L46763a.  if v0 == 0 then goto L4675f8;
  #L46763e.  v5:= 1I;
  #L467640.  return v5;
}
procedure `boolean` `b`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v3 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L467654.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L467658.  v1:= 1I;
  #L46765a.  if v0 == 0 then goto L467660;
  #L46765e.  return v1;
  #L467660.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L467664.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L46766a.  v0:= temp @kind object;
  #L46766c.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L467670.  v2:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.c` @type ^`boolean` @kind boolean;
  #L467674.  if v2 != 0 then goto L4676a2;
  #L467678.  if v0 == 0 then goto L4676a2;
  #L46767c.  call temp:= `c`(v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.c:()Z` @kind virtual;
  #L467682.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L467686.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L46768c.  v0:= temp @kind object;
  #L46768e.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L467692.  if v0 == v2 then goto L4676a0;
  #L467696.  v2:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @type ^`io.reactivex.Observer` @kind object;
  #L46769a.  call `onError`(v2, v0) @signature `Lio/reactivex/Observer;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L4676a0.  return v1;
  #L4676a2.  v0:= 0I;
  #L4676a4.  return v0;
}
procedure `boolean` `c`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v4 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.c:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4676b8.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.k` @type ^`io.reactivex.disposables.Disposable` @kind object;
  #L4676bc.  call `dispose`(v0) @signature `Lio/reactivex/disposables/Disposable;.dispose:()V` @kind interface;
  #L4676c2.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4676c6.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4676cc.  v0:= temp @kind object;
  #L4676ce.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[]) v0 @kind object;
  #L4676d2.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.r` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] @kind object;
  #L4676d6.  v2:= 0I;
  #L4676d8.  if v0 == v1 then goto L46770e;
  #L4676dc.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4676e0.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L4676e6.  v0:= temp @kind object;
  #L4676e8.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[]) v0 @kind object;
  #L4676ec.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.r` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] @kind object;
  #L4676f0.  if v0 == v1 then goto L46770e;
  #L4676f4.  v1:= length @variable v0;
  #L4676f6.  if v2 >= v1 then goto L46770a;
  #L4676fa.  v3:= v0[v2] @kind object;
  #L4676fe.  call `a`(v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;.a:()V` @kind virtual;
  #L467704.  v2:= v2 + 1;
  #L467708.  goto L4676f6;
  #L46770a.  v0:= 1I;
  #L46770c.  return v0;
  #L46770e.  return v2;
}
procedure `void` `d`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.d:()V` @AccessFlag  {
    temp;
    v0;

  #L4678f4.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L4678fa.  v0:= temp;
  #L4678fc.  if v0 != 0 then goto L467906;
  #L467900.  call `e`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.e:()V` @kind virtual;
  #L467906.  return @kind void;
}
procedure `void` `dispose`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v2 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.dispose:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4678a8.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L4678ac.  if v0 != 0 then goto L4678e0;
  #L4678b0.  v0:= 1I;
  #L4678b2.  v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.i` @type ^`boolean` := v0 @kind boolean;
  #L4678b6.  call temp:= `c`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.c:()Z` @kind virtual;
  #L4678bc.  v0:= temp;
  #L4678be.  if v0 == 0 then goto L4678e0;
  #L4678c2.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L4678c6.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L4678cc.  v0:= temp @kind object;
  #L4678ce.  if v0 == 0 then goto L4678e0;
  #L4678d2.  v1:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L4678d6.  if v0 == v1 then goto L4678e0;
  #L4678da.  call `onError`(v0) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L4678e0.  return @kind void;
}
procedure `void` `e`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v14 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.e:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;

  #L467918.  v0:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @type ^`io.reactivex.Observer` @kind object;
  #L46791c.  v1:= 1I;
  #L46791e.  call temp:= `b`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @kind virtual;
  #L467924.  v2:= temp;
  #L467926.  if v2 == 0 then goto L46792c;
  #L46792a.  return @kind void;
  #L46792c.  v2:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L467930.  v3:= 0I;
  #L467932.  v4:= 0I;
  #L467934.  if v2 == 0 then goto L467960;
  #L467938.  call temp:= `b`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @kind virtual;
  #L46793e.  v5:= temp;
  #L467940.  if v5 == 0 then goto L467946;
  #L467944.  return @kind void;
  #L467946.  call temp:= `poll`(v2) @signature `Lio/reactivex/internal/fuseable/SimplePlainQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L46794c.  v5:= temp @kind object;
  #L46794e.  if v5 != 0 then goto L467954;
  #L467952.  goto L467960;
  #L467954.  call `onNext`(v0, v5) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L46795a.  v4:= v4 + 1;
  #L46795e.  goto L467938;
  #L467960.  v2:= 2147483647I;
  #L467966.  if v4 == 0 then goto L46797a;
  #L46796a.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L46796e.  if v3 == v2 then goto L46791e;
  #L467972.  call `h`(v14, v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.h:(I)V` @kind virtual;
  #L467978.  goto L46791e;
  #L46797a.  v5:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L46797e.  v6:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L467982.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L467986.  call temp:= `get`(v7) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L46798c.  v7:= temp @kind object;
  #L46798e.  v7:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[]) v7 @kind object;
  #L467992.  v8:= length @variable v7;
  #L467994.  v9:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L467998.  if v9 == v2 then goto L4679b4;
  #L46799c.  @monitorenter v14
  #L46799e.  v9:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.o` @type ^`java.util.Queue` @kind object;
  #L4679a2.  call temp:= `size`(v9) @signature `Ljava/util/Queue;.size:()I` @kind interface;
  #L4679a8.  v9:= temp;
  #L4679aa.  @monitorexit v14
  #L4679ac.  goto L4679b6;
  #L4679ae.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L4679b0.  @monitorexit v14
  #L4679b2.  throw v0;
  #L4679b4.  v9:= 0I;
  #L4679b6.  if v5 == 0 then goto L4679fa;
  #L4679ba.  if v6 == 0 then goto L4679ca;
  #L4679be.  call temp:= `isEmpty`(v6) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L4679c4.  v5:= temp;
  #L4679c6.  if v5 == 0 then goto L4679fa;
  #L4679ca.  if v8 != 0 then goto L4679fa;
  #L4679ce.  if v9 != 0 then goto L4679fa;
  #L4679d2.  v1:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L4679d6.  call temp:= `terminate`(v1) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L4679dc.  v1:= temp @kind object;
  #L4679de.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L4679e2.  if v1 == v2 then goto L4679f8;
  #L4679e6.  if v1 != 0 then goto L4679f2;
  #L4679ea.  call `onComplete`(v0) @signature `Lio/reactivex/Observer;.onComplete:()V` @kind interface;
  #L4679f0.  goto L4679f8;
  #L4679f2.  call `onError`(v0, v1) @signature `Lio/reactivex/Observer;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L4679f8.  return @kind void;
  #L4679fa.  if v8 == 0 then goto L467b28;
  #L4679fe.  v5:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.m` @type ^`long` @kind wide;
  #L467a02.  v9:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.n` @type ^`int`;
  #L467a06.  if v8 <= v9 then goto L467a1a;
  #L467a0a.  v10:= v7[v9] @kind object;
  #L467a0e.  v10:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.a` @type ^`long` @kind wide;
  #L467a12.  v12:= lcmp(v10, v5);
  #L467a16.  if v12 == 0 then goto L467a58;
  #L467a1a.  if v8 > v9 then goto L467a20;
  #L467a1e.  v9:= 0I;
  #L467a20.  v10:= 0I;
  #L467a22.  if v10 >= v8 then goto L467a48;
  #L467a26.  v11:= v7[v9] @kind object;
  #L467a2a.  v11:= v11.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.a` @type ^`long` @kind wide;
  #L467a2e.  v13:= lcmp(v11, v5);
  #L467a32.  if v13 != 0 then goto L467a38;
  #L467a36.  goto L467a48;
  #L467a38.  v9:= v9 + 1;
  #L467a3c.  if v9 != v8 then goto L467a42;
  #L467a40.  v9:= 0I;
  #L467a42.  v10:= v10 + 1;
  #L467a46.  goto L467a22;
  #L467a48.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.n` @type ^`int` := v9;
  #L467a4c.  v5:= v7[v9] @kind object;
  #L467a50.  v5:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.a` @type ^`long` @kind wide;
  #L467a54.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.m` @type ^`long` := v5 @kind wide;
  #L467a58.  v5:= 0I;
  #L467a5a.  if v5 >= v8 then goto L467b18;
  #L467a5e.  call temp:= `b`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @kind virtual;
  #L467a64.  v6:= temp;
  #L467a66.  if v6 == 0 then goto L467a6c;
  #L467a6a.  return @kind void;
  #L467a6c.  v6:= v7[v9] @kind object;
  #L467a70.  v10:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.d` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L467a74.  if v10 == 0 then goto L467ad4;
  #L467a78.  call temp:= `poll`(v10) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L467a7e.  v11:= temp @kind object;
  #L467a80.  if v11 != 0 then goto L467a86;
  #L467a84.  goto L467ad4;
  #L467a86.  call `onNext`(v0, v11) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L467a8c.  call temp:= `b`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @kind virtual;
  #L467a92.  v11:= temp;
  #L467a94.  if v11 == 0 then goto L467a78;
  #L467a98.  return @kind void;
  #L467a9a.  v10:= Exception @type ^`java.lang.Throwable` @kind object;
  #L467a9c.  call `throwIfFatal`(v10) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L467aa2.  call `a`(v6) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;.a:()V` @kind virtual;
  #L467aa8.  v11:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L467aac.  call temp:= `addThrowable`(v11, v10) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L467ab2.  call temp:= `b`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @kind virtual;
  #L467ab8.  v10:= temp;
  #L467aba.  if v10 == 0 then goto L467ac0;
  #L467abe.  return @kind void;
  #L467ac0.  call `f`(v14, v6) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.f:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;)V` @kind virtual;
  #L467ac6.  v4:= v4 + 1;
  #L467aca.  v9:= v9 + 1;
  #L467ace.  if v9 != v8 then goto L467b12;
  #L467ad2.  goto L467b10;
  #L467ad4.  v10:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.c` @type ^`boolean` @kind boolean;
  #L467ad8.  v11:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.d` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L467adc.  if v10 == 0 then goto L467b08;
  #L467ae0.  if v11 == 0 then goto L467af0;
  #L467ae4.  call temp:= `isEmpty`(v11) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L467aea.  v10:= temp;
  #L467aec.  if v10 == 0 then goto L467b08;
  #L467af0.  call `f`(v14, v6) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.f:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;)V` @kind virtual;
  #L467af6.  call temp:= `b`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.b:()Z` @kind virtual;
  #L467afc.  v6:= temp;
  #L467afe.  if v6 == 0 then goto L467b04;
  #L467b02.  return @kind void;
  #L467b04.  v4:= v4 + 1;
  #L467b08.  v9:= v9 + 1;
  #L467b0c.  if v9 != v8 then goto L467b12;
  #L467b10.  v9:= 0I;
  #L467b12.  v5:= v5 + 1;
  #L467b16.  goto L467a5a;
  #L467b18.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.n` @type ^`int` := v9;
  #L467b1c.  v3:= v7[v9] @kind object;
  #L467b20.  v5:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.a` @type ^`long` @kind wide;
  #L467b24.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.m` @type ^`long` := v5 @kind wide;
  #L467b28.  if v4 == 0 then goto L467b3e;
  #L467b2c.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L467b30.  if v3 == v2 then goto L46791e;
  #L467b34.  call `h`(v14, v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.h:(I)V` @kind virtual;
  #L467b3a.  goto L46791e;
  #L467b3e.  v1:= -v1 @kind int;
  #L467b40.  call temp:= `addAndGet`(v14, v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L467b46.  v1:= temp;
  #L467b48.  if v1 != 0 then goto L46791e;
  #L467b4c.  return @kind void;
  catch `java.lang.Throwable` @[L46799e..L4679b2] goto L4679ae;
  catch `java.lang.Throwable` @[L467a78..L467a80] goto L467a9a;
}
procedure `void` `f`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v6 @kind this, `io.reactivex.internal.operators.observable.ObservableFlatMap$a` v7 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.f:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L467cc8.  v0:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L467ccc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L467cd2.  v0:= temp @kind object;
  #L467cd4.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[]) v0 @kind object;
  #L467cd8.  v1:= length @variable v0;
  #L467cda.  if v1 != 0 then goto L467ce0;
  #L467cde.  return @kind void;
  #L467ce0.  v2:= -1I;
  #L467ce2.  v3:= 0I;
  #L467ce4.  v4:= 0I;
  #L467ce6.  if v4 >= v1 then goto L467cfc;
  #L467cea.  v5:= v0[v4] @kind object;
  #L467cee.  if v5 != v7 then goto L467cf6;
  #L467cf2.  v2:= v4;
  #L467cf4.  goto L467cfc;
  #L467cf6.  v4:= v4 + 1;
  #L467cfa.  goto L467ce6;
  #L467cfc.  if v2 >= 0 then goto L467d02;
  #L467d00.  return @kind void;
  #L467d02.  v4:= 1I;
  #L467d04.  if v1 != v4 then goto L467d0e;
  #L467d08.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$b.q` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$a`[] @kind object;
  #L467d0c.  goto L467d2c;
  #L467d0e.  v5:= v1 + -1;
  #L467d12.  v5:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$a`[v5];
  #L467d16.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L467d1c.  v3:= v2 + 1;
  #L467d20.  v1:= v1 - v2 @kind int;
  #L467d22.  v1:= v1 - v4 @kind int;
  #L467d24.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L467d2a.  v1:= v5 @kind object;
  #L467d2c.  v2:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L467d30.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L467d36.  v0:= temp;
  #L467d38.  if v0 == 0 then goto L467cc8;
  #L467d3c.  return @kind void;
}
procedure `void` `g`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v5 @kind this, `io.reactivex.ObservableSource` v6 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.g:(Lio/reactivex/ObservableSource;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L467d50.  v0:= instanceof @variable v6 @type ^`java.util.concurrent.Callable` @kind boolean;
  #L467d54.  if v0 == 0 then goto L467db4;
  #L467d58.  v6:= (`java.util.concurrent.Callable`) v6 @kind object;
  #L467d5c.  call temp:= `j`(v5, v6) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.j:(Ljava/util/concurrent/Callable;)Z` @kind virtual;
  #L467d62.  v6:= temp;
  #L467d64.  if v6 == 0 then goto L467dde;
  #L467d68.  v6:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L467d6c.  v0:= 2147483647I;
  #L467d72.  if v6 == v0 then goto L467dde;
  #L467d76.  v6:= 0I;
  #L467d78.  @monitorenter v5
  #L467d7a.  v0:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.o` @type ^`java.util.Queue` @kind object;
  #L467d7e.  call temp:= `poll`(v0) @signature `Ljava/util/Queue;.poll:()Ljava/lang/Object;` @kind interface;
  #L467d84.  v0:= temp @kind object;
  #L467d86.  v0:= (`io.reactivex.ObservableSource`) v0 @kind object;
  #L467d8a.  v1:= 1I;
  #L467d8c.  if v0 != 0 then goto L467d9c;
  #L467d90.  v6:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int`;
  #L467d94.  v6:= v6 - v1 @kind int;
  #L467d96.  v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int` := v6;
  #L467d9a.  v6:= 1I;
  #L467d9c.  @monitorexit v5
  #L467d9e.  if v6 == 0 then goto L467daa;
  #L467da2.  call `d`(v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.d:()V` @kind virtual;
  #L467da8.  goto L467dde;
  #L467daa.  v6:= v0 @kind object;
  #L467dac.  goto L467d50;
  #L467dae.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L467db0.  @monitorexit v5
  #L467db2.  throw v6;
  #L467db4.  v0:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$a`;
  #L467db8.  v1:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.l` @type ^`long` @kind wide;
  #L467dbc.  v3:= 1L;
  #L467dc0.  v3:= v3 + v1 @kind long;
  #L467dc2.  v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.l` @type ^`long` := v3 @kind wide;
  #L467dc6.  call `<init>`(v0, v5, v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;.<init>:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;J)V` @kind direct;
  #L467dcc.  call temp:= `a`(v5, v0) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.a:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;)Z` @kind virtual;
  #L467dd2.  v1:= temp;
  #L467dd4.  if v1 == 0 then goto L467dde;
  #L467dd8.  call `subscribe`(v6, v0) @signature `Lio/reactivex/ObservableSource;.subscribe:(Lio/reactivex/Observer;)V` @kind interface;
  #L467dde.  return @kind void;
  catch `java.lang.Throwable` @[L467d7a..L467d9e] goto L467dae;
  catch `java.lang.Throwable` @[L467db0..L467db2] goto L467dae;
}
procedure `void` `h`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this, `int` v2 ) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.h:(I)V` @AccessFlag  {
    temp;
    v0;

  #L467e04.  v0:= v2 + -1;
  #L467e08.  if v2 == 0 then goto L467e44;
  #L467e0c.  @monitorenter v1
  #L467e0e.  v2:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.o` @type ^`java.util.Queue` @kind object;
  #L467e12.  call temp:= `poll`(v2) @signature `Ljava/util/Queue;.poll:()Ljava/lang/Object;` @kind interface;
  #L467e18.  v2:= temp @kind object;
  #L467e1a.  v2:= (`io.reactivex.ObservableSource`) v2 @kind object;
  #L467e1e.  if v2 != 0 then goto L467e32;
  #L467e22.  v2:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int`;
  #L467e26.  v2:= v2 + -1;
  #L467e2a.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int` := v2;
  #L467e2e.  @monitorexit v1
  #L467e30.  goto L467e3a;
  #L467e32.  @monitorexit v1
  #L467e34.  call `g`(v1, v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.g:(Lio/reactivex/ObservableSource;)V` @kind virtual;
  #L467e3a.  v2:= v0;
  #L467e3c.  goto L467e04;
  #L467e3e.  v2:= Exception @type ^`java.lang.Throwable` @kind object;
  #L467e40.  @monitorexit v1
  #L467e42.  throw v2;
  #L467e44.  return @kind void;
  catch `java.lang.Throwable` @[L467e0e..L467e34] goto L467e3e;
  catch `java.lang.Throwable` @[L467e40..L467e42] goto L467e3e;
}
procedure `void` `i`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v2 @kind this, `java.lang.Object` v3 @kind object, `io.reactivex.internal.operators.observable.ObservableFlatMap$a` v4 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.i:(Ljava/lang/Object;Lio/reactivex/internal/operators/observable/ObservableFlatMap$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L467e6c.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L467e72.  v0:= temp;
  #L467e74.  if v0 != 0 then goto L467ea0;
  #L467e78.  v0:= 0I;
  #L467e7a.  v1:= 1I;
  #L467e7c.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L467e82.  v0:= temp;
  #L467e84.  if v0 == 0 then goto L467ea0;
  #L467e88.  v4:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @type ^`io.reactivex.Observer` @kind object;
  #L467e8c.  call `onNext`(v4, v3) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L467e92.  call temp:= `decrementAndGet`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L467e98.  v3:= temp;
  #L467e9a.  if v3 != 0 then goto L467ece;
  #L467e9e.  return @kind void;
  #L467ea0.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.d` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L467ea4.  if v0 != 0 then goto L467eba;
  #L467ea8.  v0:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L467eac.  v1:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.e` @type ^`int`;
  #L467eb0.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L467eb6.  v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$a.d` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L467eba.  call temp:= `offer`(v0, v3) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L467ec0.  call temp:= `getAndIncrement`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L467ec6.  v3:= temp;
  #L467ec8.  if v3 == 0 then goto L467ece;
  #L467ecc.  return @kind void;
  #L467ece.  call `e`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.e:()V` @kind virtual;
  #L467ed4.  return @kind void;
}
procedure `boolean` `isDisposed`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.isDisposed:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L467720.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L467724.  return v0;
}
procedure `boolean` `j`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v4 @kind this, `java.util.concurrent.Callable` v5 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.j:(Ljava/util/concurrent/Callable;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L467738.  v0:= 1I;
  #L46773a.  call temp:= `call`(v5) @signature `Ljava/util/concurrent/Callable;.call:()Ljava/lang/Object;` @kind interface;
  #L467740.  v5:= temp @kind object;
  #L467742.  if v5 != 0 then goto L467748;
  #L467746.  return v0;
  #L467748.  call temp:= `get`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L46774e.  v1:= temp;
  #L467750.  v2:= 0I;
  #L467752.  if v1 != 0 then goto L46777a;
  #L467756.  call temp:= `compareAndSet`(v4, v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L46775c.  v1:= temp;
  #L46775e.  if v1 == 0 then goto L46777a;
  #L467762.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @type ^`io.reactivex.Observer` @kind object;
  #L467766.  call `onNext`(v1, v5) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L46776c.  call temp:= `decrementAndGet`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L467772.  v5:= temp;
  #L467774.  if v5 != 0 then goto L4677e2;
  #L467778.  return v0;
  #L46777a.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L46777e.  if v1 != 0 then goto L4677b2;
  #L467782.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L467786.  v3:= 2147483647I;
  #L46778c.  if v1 != v3 then goto L4677a0;
  #L467790.  v1:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L467794.  v3:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.e` @type ^`int`;
  #L467798.  call `<init>`(v1, v3) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L46779e.  goto L4677ae;
  #L4677a0.  v1:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L4677a4.  v3:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L4677a8.  call `<init>`(v1, v3) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L4677ae.  v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` := v1 @kind object;
  #L4677b2.  call temp:= `offer`(v1, v5) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L4677b8.  v5:= temp;
  #L4677ba.  if v5 != 0 then goto L4677d4;
  #L4677be.  v5:= new `java.lang.IllegalStateException`;
  #L4677c2.  v1:= "Scalar queue full?!" @kind object;
  #L4677c6.  call `<init>`(v5, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L4677cc.  call `onError`(v4, v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L4677d2.  return v0;
  #L4677d4.  call temp:= `getAndIncrement`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L4677da.  v5:= temp;
  #L4677dc.  if v5 == 0 then goto L4677e2;
  #L4677e0.  return v2;
  #L4677e2.  call `e`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.e:()V` @kind virtual;
  #L4677e8.  return v0;
  #L4677ea.  v5:= Exception @type ^`java.lang.Throwable` @kind object;
  #L4677ec.  call `throwIfFatal`(v5) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L4677f2.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L4677f6.  call temp:= `addThrowable`(v1, v5) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L4677fc.  call `d`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.d:()V` @kind virtual;
  #L467802.  return v0;
  catch `java.lang.Throwable` @[L46773a..L467742] goto L4677ea;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L467b78.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L467b7c.  if v0 == 0 then goto L467b82;
  #L467b80.  return @kind void;
  #L467b82.  v0:= 1I;
  #L467b84.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @type ^`boolean` := v0 @kind boolean;
  #L467b88.  call `d`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.d:()V` @kind virtual;
  #L467b8e.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L467ba0.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L467ba4.  if v0 == 0 then goto L467bb0;
  #L467ba8.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L467bae.  return @kind void;
  #L467bb0.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L467bb4.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L467bba.  v0:= temp;
  #L467bbc.  if v0 == 0 then goto L467bce;
  #L467bc0.  v2:= 1I;
  #L467bc2.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @type ^`boolean` := v2 @kind boolean;
  #L467bc6.  call `d`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.d:()V` @kind virtual;
  #L467bcc.  goto L467bd4;
  #L467bce.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L467bd4.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v2 @kind this, `java.lang.Object` v3 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L467be8.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L467bec.  if v0 == 0 then goto L467bf2;
  #L467bf0.  return @kind void;
  #L467bf2.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.b` @type ^`io.reactivex.functions.Function` @kind object;
  #L467bf6.  call temp:= `apply`(v0, v3) @signature `Lio/reactivex/functions/Function;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L467bfc.  v3:= temp @kind object;
  #L467bfe.  v0:= "The mapper returned a null ObservableSource" @kind object;
  #L467c02.  call temp:= `requireNonNull`(v3, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L467c08.  v3:= temp @kind object;
  #L467c0a.  v3:= (`io.reactivex.ObservableSource`) v3 @kind object;
  #L467c0e.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L467c12.  v1:= 2147483647I;
  #L467c18.  if v0 == v1 then goto L467c4e;
  #L467c1c.  @monitorenter v2
  #L467c1e.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int`;
  #L467c22.  v1:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.d` @type ^`int`;
  #L467c26.  if v0 != v1 then goto L467c38;
  #L467c2a.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.o` @type ^`java.util.Queue` @kind object;
  #L467c2e.  call temp:= `offer`(v0, v3) @signature `Ljava/util/Queue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L467c34.  @monitorexit v2
  #L467c36.  return @kind void;
  #L467c38.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int`;
  #L467c3c.  v0:= v0 + 1;
  #L467c40.  v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.p` @type ^`int` := v0;
  #L467c44.  @monitorexit v2
  #L467c46.  goto L467c4e;
  #L467c48.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L467c4a.  @monitorexit v2
  #L467c4c.  throw v3;
  #L467c4e.  call `g`(v2, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.g:(Lio/reactivex/ObservableSource;)V` @kind virtual;
  #L467c54.  return @kind void;
  #L467c56.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L467c58.  call `throwIfFatal`(v3) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L467c5e.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.k` @type ^`io.reactivex.disposables.Disposable` @kind object;
  #L467c62.  call `dispose`(v0) @signature `Lio/reactivex/disposables/Disposable;.dispose:()V` @kind interface;
  #L467c68.  call `onError`(v2, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L467c6e.  return @kind void;
  catch `java.lang.Throwable` @[L467bf2..L467c0e] goto L467c56;
  catch `java.lang.Throwable` @[L467c1e..L467c4c] goto L467c48;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.observable.ObservableFlatMap$b` v1 @kind this, `io.reactivex.disposables.Disposable` v2 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$b;.onSubscribe:(Lio/reactivex/disposables/Disposable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L467c98.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.k` @type ^`io.reactivex.disposables.Disposable` @kind object;
  #L467c9c.  call temp:= `validate`(v0, v2) @signature `Lio/reactivex/internal/disposables/DisposableHelper;.validate:(Lio/reactivex/disposables/Disposable;Lio/reactivex/disposables/Disposable;)Z` @kind static;
  #L467ca2.  v0:= temp;
  #L467ca4.  if v0 == 0 then goto L467cb6;
  #L467ca8.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.k` @type ^`io.reactivex.disposables.Disposable` := v2 @kind object;
  #L467cac.  v2:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$b.a` @type ^`io.reactivex.Observer` @kind object;
  #L467cb0.  call `onSubscribe`(v2, v1) @signature `Lio/reactivex/Observer;.onSubscribe:(Lio/reactivex/disposables/Disposable;)V` @kind interface;
  #L467cb6.  return @kind void;
}

record `io.reactivex.internal.operators.flowable.FlowableFlatMap$b` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.FlowableSubscriber` @kind interface, `org.reactivestreams.Subscription` @kind interface {
  `org.reactivestreams.Subscriber` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @AccessFlag FINAL;
  `io.reactivex.functions.Function` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.b` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.c` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.e` @AccessFlag FINAL;
  `io.reactivex.internal.fuseable.SimplePlainQueue` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @AccessFlag VOLATILE;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @AccessFlag VOLATILE;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @AccessFlag FINAL;
  `org.reactivestreams.Subscription` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @AccessFlag ;
  `long` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.m` @AccessFlag ;
  `long` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.n` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.o` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$b.q` @AccessFlag FINAL;
}
global `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.r` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L43a7cc.  v0:= 0I;
  #L43a7ce.  v1:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[v0];
  #L43a7d2.  `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.r` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] := v1 @kind object;
  #L43a7d6.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[v0];
  #L43a7da.  `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] := v0 @kind object;
  #L43a7de.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v1 @kind this, `org.reactivestreams.Subscriber` v2 @kind object, `io.reactivex.functions.Function` v3 @kind object, `boolean` v4 , `int` v5 , `int` v6 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.<init>:(Lorg/reactivestreams/Subscriber;Lio/reactivex/functions/Function;ZII)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L43a7f0.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L43a7f6.  v0:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L43a7fa.  call `<init>`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L43a800.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` := v0 @kind object;
  #L43a804.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L43a808.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L43a80e.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L43a812.  v0:= new `java.util.concurrent.atomic.AtomicLong`;
  #L43a816.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L43a81c.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` := v0 @kind object;
  #L43a820.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @type ^`org.reactivestreams.Subscriber` := v2 @kind object;
  #L43a824.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.b` @type ^`io.reactivex.functions.Function` := v3 @kind object;
  #L43a828.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.c` @type ^`boolean` := v4 @kind boolean;
  #L43a82c.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @type ^`int` := v5;
  #L43a830.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.e` @type ^`int` := v6;
  #L43a834.  v2:= 1I;
  #L43a836.  v3:= v5 ^> 1;
  #L43a83a.  call temp:= `max`(v2, v3) @signature `Ljava/lang/Math;.max:(II)I` @kind static;
  #L43a840.  v2:= temp;
  #L43a842.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.q` @type ^`int` := v2;
  #L43a846.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43a84a.  v3:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.r` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43a84e.  call `lazySet`(v2, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L43a854.  return @kind void;
}
procedure `boolean` `a`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v4 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$a` v5 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.a:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L43a694.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43a698.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L43a69e.  v0:= temp @kind object;
  #L43a6a0.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v0 @kind object;
  #L43a6a4.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43a6a8.  v2:= 0I;
  #L43a6aa.  if v0 != v1 then goto L43a6b6;
  #L43a6ae.  call `dispose`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.dispose:()V` @kind virtual;
  #L43a6b4.  return v2;
  #L43a6b6.  v1:= length @variable v0;
  #L43a6b8.  v3:= v1 + 1;
  #L43a6bc.  v3:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[v3];
  #L43a6c0.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L43a6c6.  v3[v1]:= v5 @kind object;
  #L43a6ca.  v1:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43a6ce.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L43a6d4.  v0:= temp;
  #L43a6d6.  if v0 == 0 then goto L43a694;
  #L43a6da.  v5:= 1I;
  #L43a6dc.  return v5;
}
procedure `boolean` `b`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v3 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L43a6f0.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L43a6f4.  v1:= 1I;
  #L43a6f6.  if v0 == 0 then goto L43a702;
  #L43a6fa.  call `c`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.c:()V` @kind virtual;
  #L43a700.  return v1;
  #L43a702.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.c` @type ^`boolean` @kind boolean;
  #L43a706.  if v0 != 0 then goto L43a740;
  #L43a70a.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43a70e.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L43a714.  v0:= temp @kind object;
  #L43a716.  if v0 == 0 then goto L43a740;
  #L43a71a.  call `c`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.c:()V` @kind virtual;
  #L43a720.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43a724.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L43a72a.  v0:= temp @kind object;
  #L43a72c.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L43a730.  if v0 == v2 then goto L43a73e;
  #L43a734.  v2:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L43a738.  call `onError`(v2, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L43a73e.  return v1;
  #L43a740.  v0:= 0I;
  #L43a742.  return v0;
}
procedure `void` `c`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.c:()V` @AccessFlag  {
    temp;
    v0;

  #L43a8b4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L43a8b8.  if v0 == 0 then goto L43a8c2;
  #L43a8bc.  call `clear`(v0) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.clear:()V` @kind interface;
  #L43a8c2.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L43a868.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L43a86c.  if v0 != 0 then goto L43a8a0;
  #L43a870.  v0:= 1I;
  #L43a872.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` := v0 @kind boolean;
  #L43a876.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43a87a.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L43a880.  call `d`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.d:()V` @kind virtual;
  #L43a886.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L43a88c.  v0:= temp;
  #L43a88e.  if v0 != 0 then goto L43a8a0;
  #L43a892.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L43a896.  if v0 == 0 then goto L43a8a0;
  #L43a89a.  call `clear`(v0) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.clear:()V` @kind interface;
  #L43a8a0.  return @kind void;
}
procedure `void` `d`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v4 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.d:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L43a8d4.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43a8d8.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L43a8de.  v0:= temp @kind object;
  #L43a8e0.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v0 @kind object;
  #L43a8e4.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43a8e8.  if v0 == v1 then goto L43a93a;
  #L43a8ec.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43a8f0.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L43a8f6.  v0:= temp @kind object;
  #L43a8f8.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v0 @kind object;
  #L43a8fc.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43a900.  if v0 == v1 then goto L43a93a;
  #L43a904.  v1:= length @variable v0;
  #L43a906.  v2:= 0I;
  #L43a908.  if v2 >= v1 then goto L43a91c;
  #L43a90c.  v3:= v0[v2] @kind object;
  #L43a910.  call `dispose`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.dispose:()V` @kind virtual;
  #L43a916.  v2:= v2 + 1;
  #L43a91a.  goto L43a908;
  #L43a91c.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43a920.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L43a926.  v0:= temp @kind object;
  #L43a928.  if v0 == 0 then goto L43a93a;
  #L43a92c.  v1:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L43a930.  if v0 == v1 then goto L43a93a;
  #L43a934.  call `onError`(v0) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L43a93a.  return @kind void;
}
procedure `void` `e`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.e:()V` @AccessFlag  {
    temp;
    v0;

  #L43a94c.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L43a952.  v0:= temp;
  #L43a954.  if v0 != 0 then goto L43a95e;
  #L43a958.  call `f`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.f:()V` @kind virtual;
  #L43a95e.  return @kind void;
}
procedure `void` `f`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v24 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.f:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;
    v23;

  #L43a970.  v1:= v24 @kind object;
  #L43a974.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L43a978.  v4:= 1I;
  #L43a97a.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43a980.  v0:= temp;
  #L43a982.  if v0 == 0 then goto L43a988;
  #L43a986.  return @kind void;
  #L43a988.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L43a98c.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43a990.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L43a996.  v5:= temp @kind wide;
  #L43a998.  v7:= 9223372036854775807L;
  #L43a9a2.  v10:= lcmp(v5, v7);
  #L43a9a6.  if v10 != 0 then goto L43a9ae;
  #L43a9aa.  v10:= 1I;
  #L43a9ac.  goto L43a9b0;
  #L43a9ae.  v10:= 0I;
  #L43a9b0.  v12:= 1L;
  #L43a9b4.  v14:= 0L;
  #L43a9b8.  v16:= v14 @kind wide;
  #L43a9bc.  if v0 == 0 then goto L43aa42;
  #L43a9c0.  v7:= v14 @kind wide;
  #L43a9c2.  v18:= 0I;
  #L43a9c6.  v19:= lcmp(v5, v14);
  #L43a9ca.  if v19 == 0 then goto L43aa02;
  #L43a9ce.  call temp:= `poll`(v0) @signature `Lio/reactivex/internal/fuseable/SimplePlainQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L43a9d4.  v9:= temp @kind object;
  #L43a9d6.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43a9dc.  v18:= temp;
  #L43a9de.  if v18 == 0 then goto L43a9e4;
  #L43a9e2.  return @kind void;
  #L43a9e4.  if v9 != 0 then goto L43a9ee;
  #L43a9e8.  v18:= v9 @kind object;
  #L43a9ec.  goto L43aa02;
  #L43a9ee.  call `onNext`(v2, v9) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L43a9f4.  v16:= v16 + v12 @kind long;
  #L43a9f8.  v7:= v7 + v12 @kind long;
  #L43a9fa.  v5:= v5 - v12 @kind long;
  #L43a9fc.  v18:= v9 @kind object;
  #L43aa00.  goto L43a9c6;
  #L43aa02.  v9:= lcmp(v7, v14);
  #L43aa06.  if v9 == 0 then goto L43aa28;
  #L43aa0a.  if v10 == 0 then goto L43aa1a;
  #L43aa0e.  v5:= 9223372036854775807L;
  #L43aa18.  goto L43aa28;
  #L43aa1a.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43aa1e.  v6:= -v7 @kind long;
  #L43aa20.  call temp:= `addAndGet`(v5, v6) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L43aa26.  v5:= temp @kind wide;
  #L43aa28.  v7:= lcmp(v5, v14);
  #L43aa2c.  if v7 == 0 then goto L43aa42;
  #L43aa30.  if v18 != 0 then goto L43aa36;
  #L43aa34.  goto L43aa42;
  #L43aa36.  v7:= 9223372036854775807L;
  #L43aa40.  goto L43a9c0;
  #L43aa42.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L43aa46.  v7:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L43aa4a.  v8:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43aa4e.  call temp:= `get`(v8) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L43aa54.  v8:= temp @kind object;
  #L43aa56.  v8:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v8 @kind object;
  #L43aa5a.  v9:= length @variable v8;
  #L43aa5c.  if v0 == 0 then goto L43aa9c;
  #L43aa60.  if v7 == 0 then goto L43aa70;
  #L43aa64.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L43aa6a.  v0:= temp;
  #L43aa6c.  if v0 == 0 then goto L43aa9c;
  #L43aa70.  if v9 != 0 then goto L43aa9c;
  #L43aa74.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43aa78.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L43aa7e.  v0:= temp @kind object;
  #L43aa80.  v3:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L43aa84.  if v0 == v3 then goto L43aa9a;
  #L43aa88.  if v0 != 0 then goto L43aa94;
  #L43aa8c.  call `onComplete`(v2) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L43aa92.  goto L43aa9a;
  #L43aa94.  call `onError`(v2, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L43aa9a.  return @kind void;
  #L43aa9c.  v18:= v4;
  #L43aaa0.  if v9 == 0 then goto L43aca8;
  #L43aaa4.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.n` @type ^`long` @kind wide;
  #L43aaa8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.o` @type ^`int`;
  #L43aaac.  if v9 <= v0 then goto L43aac0;
  #L43aab0.  v7:= v8[v0] @kind object;
  #L43aab4.  v11:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.a` @type ^`long` @kind wide;
  #L43aab8.  v7:= lcmp(v11, v3);
  #L43aabc.  if v7 == 0 then goto L43aafe;
  #L43aac0.  if v9 > v0 then goto L43aac6;
  #L43aac4.  v0:= 0I;
  #L43aac6.  v7:= 0I;
  #L43aac8.  if v7 >= v9 then goto L43aaee;
  #L43aacc.  v11:= v8[v0] @kind object;
  #L43aad0.  v11:= v11.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.a` @type ^`long` @kind wide;
  #L43aad4.  v13:= lcmp(v11, v3);
  #L43aad8.  if v13 != 0 then goto L43aade;
  #L43aadc.  goto L43aaee;
  #L43aade.  v0:= v0 + 1;
  #L43aae2.  if v0 != v9 then goto L43aae8;
  #L43aae6.  v0:= 0I;
  #L43aae8.  v7:= v7 + 1;
  #L43aaec.  goto L43aac8;
  #L43aaee.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.o` @type ^`int` := v0;
  #L43aaf2.  v3:= v8[v0] @kind object;
  #L43aaf6.  v3:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.a` @type ^`long` @kind wide;
  #L43aafa.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.n` @type ^`long` := v3 @kind wide;
  #L43aafe.  v3:= v0;
  #L43ab00.  v0:= 0I;
  #L43ab02.  v4:= 0I;
  #L43ab04.  if v4 >= v9 then goto L43ac88;
  #L43ab08.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43ab0e.  v7:= temp;
  #L43ab10.  if v7 == 0 then goto L43ab16;
  #L43ab14.  return @kind void;
  #L43ab16.  v7:= v8[v3] @kind object;
  #L43ab1a.  v11:= 0I;
  #L43ab1c.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43ab22.  v12:= temp;
  #L43ab24.  if v12 == 0 then goto L43ab2a;
  #L43ab28.  return @kind void;
  #L43ab2a.  v12:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L43ab2e.  if v12 != 0 then goto L43ab3c;
  #L43ab32.  v13:= v8 @kind object;
  #L43ab34.  v22:= v9;
  #L43ab38.  goto L43ac1a;
  #L43ab3c.  v13:= v8 @kind object;
  #L43ab3e.  v22:= v9;
  #L43ab42.  v8:= v14 @kind wide;
  #L43ab44.  v23:= lcmp(v5, v14);
  #L43ab48.  if v23 == 0 then goto L43abcc;
  #L43ab4c.  call temp:= `poll`(v12) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L43ab52.  v11:= temp @kind object;
  #L43ab54.  if v11 != 0 then goto L43ab5a;
  #L43ab58.  goto L43abcc;
  #L43ab5a.  call `onNext`(v2, v11) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L43ab60.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43ab66.  v23:= temp;
  #L43ab68.  if v23 == 0 then goto L43ab6e;
  #L43ab6c.  return @kind void;
  #L43ab6e.  v20:= 1L;
  #L43ab72.  v5:= v5 - v20 @kind long;
  #L43ab76.  v8:= v8 + v20 @kind long;
  #L43ab7a.  goto L43ab44;
  #L43ab7c.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L43ab7e.  v8:= v0 @kind object;
  #L43ab80.  call `throwIfFatal`(v8) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L43ab86.  call `dispose`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.dispose:()V` @kind virtual;
  #L43ab8c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43ab90.  call temp:= `addThrowable`(v0, v8) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L43ab96.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.c` @type ^`boolean` @kind boolean;
  #L43ab9a.  if v0 != 0 then goto L43aba8;
  #L43ab9e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43aba2.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L43aba8.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43abae.  v0:= temp;
  #L43abb0.  if v0 == 0 then goto L43abb6;
  #L43abb4.  return @kind void;
  #L43abb6.  call `j`(v1, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.j:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)V` @kind virtual;
  #L43abbc.  v4:= v4 + 1;
  #L43abc0.  v9:= v22;
  #L43abc4.  v0:= 1I;
  #L43abc6.  v7:= 1L;
  #L43abca.  goto L43ac7a;
  #L43abcc.  v12:= lcmp(v8, v14);
  #L43abd0.  if v12 == 0 then goto L43abfe;
  #L43abd4.  if v10 != 0 then goto L43abe8;
  #L43abd8.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43abdc.  v14:= -v8 @kind long;
  #L43abde.  call temp:= `addAndGet`(v5, v14) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L43abe4.  v5:= temp @kind wide;
  #L43abe6.  goto L43abf2;
  #L43abe8.  v5:= 9223372036854775807L;
  #L43abf2.  call `a`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.a:(J)V` @kind virtual;
  #L43abf8.  v8:= 0L;
  #L43abfc.  goto L43ac00;
  #L43abfe.  v8:= v14 @kind wide;
  #L43ac00.  v12:= lcmp(v5, v8);
  #L43ac04.  if v12 == 0 then goto L43ac1a;
  #L43ac08.  if v11 != 0 then goto L43ac0e;
  #L43ac0c.  goto L43ac1a;
  #L43ac0e.  v8:= v13 @kind object;
  #L43ac10.  v9:= v22;
  #L43ac14.  v14:= 0L;
  #L43ac18.  goto L43ab1c;
  #L43ac1a.  v8:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.e` @type ^`boolean` @kind boolean;
  #L43ac1e.  v9:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L43ac22.  if v8 == 0 then goto L43ac56;
  #L43ac26.  if v9 == 0 then goto L43ac36;
  #L43ac2a.  call temp:= `isEmpty`(v9) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L43ac30.  v8:= temp;
  #L43ac32.  if v8 == 0 then goto L43ac56;
  #L43ac36.  call `j`(v1, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.j:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)V` @kind virtual;
  #L43ac3c.  call temp:= `b`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.b:()Z` @kind virtual;
  #L43ac42.  v0:= temp;
  #L43ac44.  if v0 == 0 then goto L43ac4a;
  #L43ac48.  return @kind void;
  #L43ac4a.  v7:= 1L;
  #L43ac4e.  v16:= v16 + v7 @kind long;
  #L43ac52.  v0:= 1I;
  #L43ac54.  goto L43ac5a;
  #L43ac56.  v7:= 1L;
  #L43ac5a.  v11:= 0L;
  #L43ac5e.  v9:= lcmp(v5, v11);
  #L43ac62.  if v9 != 0 then goto L43ac6c;
  #L43ac66.  v9:= v0;
  #L43ac68.  v11:= 1I;
  #L43ac6a.  goto L43ac8e;
  #L43ac6c.  v3:= v3 + 1;
  #L43ac70.  v9:= v22;
  #L43ac74.  if v3 != v9 then goto L43ac7a;
  #L43ac78.  v3:= 0I;
  #L43ac7a.  v11:= 1I;
  #L43ac7c.  v4:= v4 + v11 @kind int;
  #L43ac7e.  v8:= v13 @kind object;
  #L43ac80.  v14:= 0L;
  #L43ac84.  goto L43ab04;
  #L43ac88.  v13:= v8 @kind object;
  #L43ac8a.  v11:= 1I;
  #L43ac8c.  v9:= v0;
  #L43ac8e.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.o` @type ^`int` := v3;
  #L43ac92.  v0:= v13[v3] @kind object;
  #L43ac96.  v3:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.a` @type ^`long` @kind wide;
  #L43ac9a.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.n` @type ^`long` := v3 @kind wide;
  #L43ac9e.  v3:= v16 @kind wide;
  #L43aca2.  v5:= 0L;
  #L43aca6.  goto L43acb2;
  #L43aca8.  v11:= 1I;
  #L43acaa.  v5:= v14 @kind wide;
  #L43acac.  v3:= v16 @kind wide;
  #L43acb0.  v9:= 0I;
  #L43acb2.  v0:= lcmp(v3, v5);
  #L43acb6.  if v0 == 0 then goto L43accc;
  #L43acba.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L43acbe.  if v0 != 0 then goto L43accc;
  #L43acc2.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43acc6.  call `request`(v0, v3) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L43accc.  if v9 == 0 then goto L43acd8;
  #L43acd0.  v4:= v18;
  #L43acd4.  goto L43a97a;
  #L43acd8.  v3:= v18;
  #L43acdc.  v0:= -v3 @kind int;
  #L43acde.  call temp:= `addAndGet`(v1, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L43ace4.  v4:= temp;
  #L43ace6.  if v4 != 0 then goto L43a97a;
  #L43acea.  return @kind void;
  catch `java.lang.Throwable` @[L43ab4c..L43ab54] goto L43ab7c;
}
procedure `io.reactivex.internal.fuseable.SimpleQueue` `g`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$a` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.g:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)Lio/reactivex/internal/fuseable/SimpleQueue;` @AccessFlag  {
    temp;
    v0;
    v1;

  #L43a754.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L43a758.  if v0 != 0 then goto L43a76e;
  #L43a75c.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L43a760.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.e` @type ^`int`;
  #L43a764.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L43a76a.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L43a76e.  return v0 @kind object;
}
procedure `io.reactivex.internal.fuseable.SimpleQueue` `h`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.h:()Lio/reactivex/internal/fuseable/SimpleQueue;` @AccessFlag  {
    temp;
    v0;
    v1;

  #L43a780.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L43a784.  if v0 != 0 then goto L43a7b8;
  #L43a788.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @type ^`int`;
  #L43a78c.  v1:= 2147483647I;
  #L43a792.  if v0 != v1 then goto L43a7a6;
  #L43a796.  v0:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L43a79a.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.e` @type ^`int`;
  #L43a79e.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L43a7a4.  goto L43a7b4;
  #L43a7a6.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L43a7aa.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @type ^`int`;
  #L43a7ae.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L43a7b4.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` := v0 @kind object;
  #L43a7b8.  return v0 @kind object;
}
procedure `void` `i`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$a` v3 @kind object, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.i:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;Ljava/lang/Throwable;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L43ad08.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43ad0c.  call temp:= `addThrowable`(v0, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L43ad12.  v0:= temp;
  #L43ad14.  if v0 == 0 then goto L43ad64;
  #L43ad18.  v4:= 1I;
  #L43ad1a.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.e` @type ^`boolean` := v4 @kind boolean;
  #L43ad1e.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.c` @type ^`boolean` @kind boolean;
  #L43ad22.  if v3 != 0 then goto L43ad5c;
  #L43ad26.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43ad2a.  call `cancel`(v3) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L43ad30.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43ad34.  v4:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43ad38.  call temp:= `getAndSet`(v3, v4) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L43ad3e.  v3:= temp @kind object;
  #L43ad40.  v3:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v3 @kind object;
  #L43ad44.  v4:= length @variable v3;
  #L43ad46.  v0:= 0I;
  #L43ad48.  if v0 >= v4 then goto L43ad5c;
  #L43ad4c.  v1:= v3[v0] @kind object;
  #L43ad50.  call `dispose`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.dispose:()V` @kind virtual;
  #L43ad56.  v0:= v0 + 1;
  #L43ad5a.  goto L43ad48;
  #L43ad5c.  call `e`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.e:()V` @kind virtual;
  #L43ad62.  goto L43ad6a;
  #L43ad64.  call `onError`(v4) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L43ad6a.  return @kind void;
}
procedure `void` `j`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v6 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$a` v7 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.j:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L43af8c.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43af90.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L43af96.  v0:= temp @kind object;
  #L43af98.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v0 @kind object;
  #L43af9c.  v1:= length @variable v0;
  #L43af9e.  if v1 != 0 then goto L43afa4;
  #L43afa2.  return @kind void;
  #L43afa4.  v2:= -1I;
  #L43afa6.  v3:= 0I;
  #L43afa8.  v4:= 0I;
  #L43afaa.  if v4 >= v1 then goto L43afc0;
  #L43afae.  v5:= v0[v4] @kind object;
  #L43afb2.  if v5 != v7 then goto L43afba;
  #L43afb6.  v2:= v4;
  #L43afb8.  goto L43afc0;
  #L43afba.  v4:= v4 + 1;
  #L43afbe.  goto L43afaa;
  #L43afc0.  if v2 >= 0 then goto L43afc6;
  #L43afc4.  return @kind void;
  #L43afc6.  v4:= 1I;
  #L43afc8.  if v1 != v4 then goto L43afd2;
  #L43afcc.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.r` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43afd0.  goto L43aff0;
  #L43afd2.  v5:= v1 + -1;
  #L43afd6.  v5:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[v5];
  #L43afda.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L43afe0.  v3:= v2 + 1;
  #L43afe4.  v1:= v1 - v2 @kind int;
  #L43afe6.  v1:= v1 - v4 @kind int;
  #L43afe8.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L43afee.  v1:= v5 @kind object;
  #L43aff0.  v2:= v6.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43aff4.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L43affa.  v0:= temp;
  #L43affc.  if v0 == 0 then goto L43af8c;
  #L43b000.  return @kind void;
}
procedure `void` `k`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v7 @kind this, `java.lang.Object` v8 @kind object, `io.reactivex.internal.operators.flowable.FlowableFlatMap$a` v9 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.k:(Ljava/lang/Object;Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L43b044.  call temp:= `get`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L43b04a.  v0:= temp;
  #L43b04c.  v1:= "Inner queue full?!" @kind object;
  #L43b050.  if v0 != 0 then goto L43b0fa;
  #L43b054.  v0:= 0I;
  #L43b056.  v2:= 1I;
  #L43b058.  call temp:= `compareAndSet`(v7, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L43b05e.  v0:= temp;
  #L43b060.  if v0 == 0 then goto L43b0fa;
  #L43b064.  v0:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43b068.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L43b06e.  v2:= temp @kind wide;
  #L43b070.  v0:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L43b074.  v4:= 0L;
  #L43b078.  v6:= lcmp(v2, v4);
  #L43b07c.  if v6 == 0 then goto L43b0c2;
  #L43b080.  if v0 == 0 then goto L43b090;
  #L43b084.  call temp:= `isEmpty`(v0) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L43b08a.  v4:= temp;
  #L43b08c.  if v4 == 0 then goto L43b0c2;
  #L43b090.  v0:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L43b094.  call `onNext`(v0, v8) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L43b09a.  v0:= 9223372036854775807L;
  #L43b0a4.  v8:= lcmp(v2, v0);
  #L43b0a8.  if v8 == 0 then goto L43b0b6;
  #L43b0ac.  v8:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43b0b0.  call temp:= `decrementAndGet`(v8) @signature `Ljava/util/concurrent/atomic/AtomicLong;.decrementAndGet:()J` @kind virtual;
  #L43b0b6.  v0:= 1L;
  #L43b0ba.  call `a`(v9, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.a:(J)V` @kind virtual;
  #L43b0c0.  goto L43b0ec;
  #L43b0c2.  if v0 != 0 then goto L43b0ce;
  #L43b0c6.  call temp:= `g`(v7, v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.g:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)Lio/reactivex/internal/fuseable/SimpleQueue;` @kind virtual;
  #L43b0cc.  v0:= temp @kind object;
  #L43b0ce.  call temp:= `offer`(v0, v8) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L43b0d4.  v8:= temp;
  #L43b0d6.  if v8 != 0 then goto L43b0ec;
  #L43b0da.  v8:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L43b0de.  call `<init>`(v8, v1) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L43b0e4.  call `onError`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L43b0ea.  return @kind void;
  #L43b0ec.  call temp:= `decrementAndGet`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L43b0f2.  v8:= temp;
  #L43b0f4.  if v8 != 0 then goto L43b140;
  #L43b0f8.  return @kind void;
  #L43b0fa.  v0:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L43b0fe.  if v0 != 0 then goto L43b114;
  #L43b102.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L43b106.  v2:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.e` @type ^`int`;
  #L43b10a.  call `<init>`(v0, v2) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L43b110.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$a.f` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L43b114.  call temp:= `offer`(v0, v8) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L43b11a.  v8:= temp;
  #L43b11c.  if v8 != 0 then goto L43b132;
  #L43b120.  v8:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L43b124.  call `<init>`(v8, v1) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L43b12a.  call `onError`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L43b130.  return @kind void;
  #L43b132.  call temp:= `getAndIncrement`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L43b138.  v8:= temp;
  #L43b13a.  if v8 == 0 then goto L43b140;
  #L43b13e.  return @kind void;
  #L43b140.  call `f`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.f:()V` @kind virtual;
  #L43b146.  return @kind void;
}
procedure `void` `l`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v9 @kind this, `java.lang.Object` v10 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.l:(Ljava/lang/Object;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L43b158.  call temp:= `get`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L43b15e.  v0:= temp;
  #L43b160.  v1:= "Scalar queue full?!" @kind object;
  #L43b164.  if v0 != 0 then goto L43b23c;
  #L43b168.  v0:= 0I;
  #L43b16a.  v2:= 1I;
  #L43b16c.  call temp:= `compareAndSet`(v9, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L43b172.  v3:= temp;
  #L43b174.  if v3 == 0 then goto L43b23c;
  #L43b178.  v3:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43b17c.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L43b182.  v3:= temp @kind wide;
  #L43b184.  v5:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.f` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L43b188.  v6:= 0L;
  #L43b18c.  v8:= lcmp(v3, v6);
  #L43b190.  if v8 == 0 then goto L43b204;
  #L43b194.  if v5 == 0 then goto L43b1a4;
  #L43b198.  call temp:= `isEmpty`(v5) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L43b19e.  v6:= temp;
  #L43b1a0.  if v6 == 0 then goto L43b204;
  #L43b1a4.  v1:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L43b1a8.  call `onNext`(v1, v10) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L43b1ae.  v5:= 9223372036854775807L;
  #L43b1b8.  v10:= lcmp(v3, v5);
  #L43b1bc.  if v10 == 0 then goto L43b1ca;
  #L43b1c0.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43b1c4.  call temp:= `decrementAndGet`(v10) @signature `Ljava/util/concurrent/atomic/AtomicLong;.decrementAndGet:()J` @kind virtual;
  #L43b1ca.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @type ^`int`;
  #L43b1ce.  v1:= 2147483647I;
  #L43b1d4.  if v10 == v1 then goto L43b22e;
  #L43b1d8.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L43b1dc.  if v10 != 0 then goto L43b22e;
  #L43b1e0.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @type ^`int`;
  #L43b1e4.  v10:= v10 + v2 @kind int;
  #L43b1e6.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @type ^`int` := v10;
  #L43b1ea.  v1:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.q` @type ^`int`;
  #L43b1ee.  if v10 != v1 then goto L43b22e;
  #L43b1f2.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @type ^`int` := v0;
  #L43b1f6.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43b1fa.  v0:= (`long`) v1 @kind i2l;
  #L43b1fc.  call `request`(v10, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L43b202.  goto L43b22e;
  #L43b204.  if v5 != 0 then goto L43b210;
  #L43b208.  call temp:= `h`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.h:()Lio/reactivex/internal/fuseable/SimpleQueue;` @kind virtual;
  #L43b20e.  v5:= temp @kind object;
  #L43b210.  call temp:= `offer`(v5, v10) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L43b216.  v10:= temp;
  #L43b218.  if v10 != 0 then goto L43b22e;
  #L43b21c.  v10:= new `java.lang.IllegalStateException`;
  #L43b220.  call `<init>`(v10, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L43b226.  call `onError`(v9, v10) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L43b22c.  return @kind void;
  #L43b22e.  call temp:= `decrementAndGet`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L43b234.  v10:= temp;
  #L43b236.  if v10 != 0 then goto L43b270;
  #L43b23a.  return @kind void;
  #L43b23c.  call temp:= `h`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.h:()Lio/reactivex/internal/fuseable/SimpleQueue;` @kind virtual;
  #L43b242.  v0:= temp @kind object;
  #L43b244.  call temp:= `offer`(v0, v10) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L43b24a.  v10:= temp;
  #L43b24c.  if v10 != 0 then goto L43b262;
  #L43b250.  v10:= new `java.lang.IllegalStateException`;
  #L43b254.  call `<init>`(v10, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L43b25a.  call `onError`(v9, v10) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L43b260.  return @kind void;
  #L43b262.  call temp:= `getAndIncrement`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L43b268.  v10:= temp;
  #L43b26a.  if v10 == 0 then goto L43b270;
  #L43b26e.  return @kind void;
  #L43b270.  call `f`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.f:()V` @kind virtual;
  #L43b276.  return @kind void;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L43ad7c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L43ad80.  if v0 == 0 then goto L43ad86;
  #L43ad84.  return @kind void;
  #L43ad86.  v0:= 1I;
  #L43ad88.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @type ^`boolean` := v0 @kind boolean;
  #L43ad8c.  call `e`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.e:()V` @kind virtual;
  #L43ad92.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v3 @kind this, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L43ada4.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L43ada8.  if v0 == 0 then goto L43adb4;
  #L43adac.  call `onError`(v4) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L43adb2.  return @kind void;
  #L43adb4.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43adb8.  call temp:= `addThrowable`(v0, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L43adbe.  v0:= temp;
  #L43adc0.  if v0 == 0 then goto L43ae06;
  #L43adc4.  v4:= 1I;
  #L43adc6.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @type ^`boolean` := v4 @kind boolean;
  #L43adca.  v4:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.c` @type ^`boolean` @kind boolean;
  #L43adce.  if v4 != 0 then goto L43adfe;
  #L43add2.  v4:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.j` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L43add6.  v0:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$b.s` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[] @kind object;
  #L43adda.  call temp:= `getAndSet`(v4, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L43ade0.  v4:= temp @kind object;
  #L43ade2.  v4:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$a`[]) v4 @kind object;
  #L43ade6.  v0:= length @variable v4;
  #L43ade8.  v1:= 0I;
  #L43adea.  if v1 >= v0 then goto L43adfe;
  #L43adee.  v2:= v4[v1] @kind object;
  #L43adf2.  call `dispose`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.dispose:()V` @kind virtual;
  #L43adf8.  v1:= v1 + 1;
  #L43adfc.  goto L43adea;
  #L43adfe.  call `e`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.e:()V` @kind virtual;
  #L43ae04.  goto L43ae0c;
  #L43ae06.  call `onError`(v4) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L43ae0c.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v5 @kind this, `java.lang.Object` v6 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L43ae20.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.g` @type ^`boolean` @kind boolean;
  #L43ae24.  if v0 == 0 then goto L43ae2a;
  #L43ae28.  return @kind void;
  #L43ae2a.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.b` @type ^`io.reactivex.functions.Function` @kind object;
  #L43ae2e.  call temp:= `apply`(v0, v6) @signature `Lio/reactivex/functions/Function;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L43ae34.  v6:= temp @kind object;
  #L43ae36.  v0:= "The mapper returned a null Publisher" @kind object;
  #L43ae3a.  call temp:= `requireNonNull`(v6, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L43ae40.  v6:= temp @kind object;
  #L43ae42.  v6:= (`org.reactivestreams.Publisher`) v6 @kind object;
  #L43ae46.  v0:= instanceof @variable v6 @type ^`java.util.concurrent.Callable` @kind boolean;
  #L43ae4a.  if v0 == 0 then goto L43aebe;
  #L43ae4e.  v6:= (`java.util.concurrent.Callable`) v6 @kind object;
  #L43ae52.  call temp:= `call`(v6) @signature `Ljava/util/concurrent/Callable;.call:()Ljava/lang/Object;` @kind interface;
  #L43ae58.  v6:= temp @kind object;
  #L43ae5a.  if v6 == 0 then goto L43ae66;
  #L43ae5e.  call `l`(v5, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.l:(Ljava/lang/Object;)V` @kind virtual;
  #L43ae64.  goto L43aee8;
  #L43ae66.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @type ^`int`;
  #L43ae6a.  v0:= 2147483647I;
  #L43ae70.  if v6 == v0 then goto L43aee8;
  #L43ae74.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L43ae78.  if v6 != 0 then goto L43aee8;
  #L43ae7c.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @type ^`int`;
  #L43ae80.  v6:= v6 + 1;
  #L43ae84.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @type ^`int` := v6;
  #L43ae88.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.q` @type ^`int`;
  #L43ae8c.  if v6 != v0 then goto L43aee8;
  #L43ae90.  v6:= 0I;
  #L43ae92.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.p` @type ^`int` := v6;
  #L43ae96.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43ae9a.  v0:= (`long`) v0 @kind i2l;
  #L43ae9c.  call `request`(v6, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L43aea2.  goto L43aee8;
  #L43aea4.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L43aea6.  call `throwIfFatal`(v6) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L43aeac.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.h` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L43aeb0.  call temp:= `addThrowable`(v0, v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L43aeb6.  call `e`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.e:()V` @kind virtual;
  #L43aebc.  return @kind void;
  #L43aebe.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$a`;
  #L43aec2.  v1:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.m` @type ^`long` @kind wide;
  #L43aec6.  v3:= 1L;
  #L43aeca.  v3:= v3 + v1 @kind long;
  #L43aecc.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.m` @type ^`long` := v3 @kind wide;
  #L43aed0.  call `<init>`(v0, v5, v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;J)V` @kind direct;
  #L43aed6.  call temp:= `a`(v5, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.a:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$a;)Z` @kind virtual;
  #L43aedc.  v1:= temp;
  #L43aede.  if v1 == 0 then goto L43aee8;
  #L43aee2.  call `subscribe`(v6, v0) @signature `Lorg/reactivestreams/Publisher;.subscribe:(Lorg/reactivestreams/Subscriber;)V` @kind interface;
  #L43aee8.  return @kind void;
  #L43aeea.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L43aeec.  call `throwIfFatal`(v6) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L43aef2.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43aef6.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L43aefc.  call `onError`(v5, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L43af02.  return @kind void;
  catch `java.lang.Throwable` @[L43ae2a..L43ae46] goto L43aeea;
  catch `java.lang.Throwable` @[L43ae4e..L43ae5a] goto L43aea4;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v2 @kind this, `org.reactivestreams.Subscription` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L43af2c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` @kind object;
  #L43af30.  call temp:= `validate`(v0, v3) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(Lorg/reactivestreams/Subscription;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L43af36.  v0:= temp;
  #L43af38.  if v0 == 0 then goto L43af7a;
  #L43af3c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.l` @type ^`org.reactivestreams.Subscription` := v3 @kind object;
  #L43af40.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L43af44.  call `onSubscribe`(v0, v2) @signature `Lorg/reactivestreams/Subscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @kind interface;
  #L43af4a.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.i` @type ^`boolean` @kind boolean;
  #L43af4e.  if v0 != 0 then goto L43af7a;
  #L43af52.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.d` @type ^`int`;
  #L43af56.  v1:= 2147483647I;
  #L43af5c.  if v0 != v1 then goto L43af72;
  #L43af60.  v0:= 9223372036854775807L;
  #L43af6a.  call `request`(v3, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L43af70.  goto L43af7a;
  #L43af72.  v0:= (`long`) v0 @kind i2l;
  #L43af74.  call `request`(v3, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L43af7a.  return @kind void;
}
procedure `void` `request`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$b` v1 @kind this, `long` v2 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.request:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L43b014.  call temp:= `validate`(v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(J)Z` @kind static;
  #L43b01a.  v0:= temp;
  #L43b01c.  if v0 == 0 then goto L43b030;
  #L43b020.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$b.k` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L43b024.  call temp:= `add`(v0, v2) @signature `Lio/reactivex/internal/util/BackpressureHelper;.add:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L43b02a.  call `e`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$b;.e:()V` @kind virtual;
  #L43b030.  return @kind void;
}

record `io.reactivex.processors.MulticastProcessor` @kind class @AccessFlag PUBLIC_FINAL extends `io.reactivex.processors.FlowableProcessor` @kind class {
  `java.util.concurrent.atomic.AtomicInteger` `io.reactivex.processors.MulticastProcessor.b` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.processors.MulticastProcessor.c` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.processors.MulticastProcessor.d` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicBoolean` `io.reactivex.processors.MulticastProcessor.e` @AccessFlag FINAL;
  `int` `io.reactivex.processors.MulticastProcessor.f` @AccessFlag FINAL;
  `int` `io.reactivex.processors.MulticastProcessor.g` @AccessFlag FINAL;
  `boolean` `io.reactivex.processors.MulticastProcessor.h` @AccessFlag FINAL;
  `io.reactivex.internal.fuseable.SimpleQueue` `io.reactivex.processors.MulticastProcessor.i` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.processors.MulticastProcessor.j` @AccessFlag VOLATILE;
  `java.lang.Throwable` `io.reactivex.processors.MulticastProcessor.k` @AccessFlag VOLATILE;
  `int` `io.reactivex.processors.MulticastProcessor.l` @AccessFlag ;
  `int` `io.reactivex.processors.MulticastProcessor.m` @AccessFlag ;
}
global `io.reactivex.processors.MulticastProcessor$a`[] `@@io.reactivex.processors.MulticastProcessor.n` @AccessFlag STATIC_FINAL;
global `io.reactivex.processors.MulticastProcessor$a`[] `@@io.reactivex.processors.MulticastProcessor.o` @AccessFlag STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/processors/MulticastProcessor;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L4913b4.  v0:= 0I;
  #L4913b6.  v1:= new `io.reactivex.processors.MulticastProcessor$a`[v0];
  #L4913ba.  `@@io.reactivex.processors.MulticastProcessor.n` @type ^`io.reactivex.processors.MulticastProcessor$a`[] := v1 @kind object;
  #L4913be.  v0:= new `io.reactivex.processors.MulticastProcessor$a`[v0];
  #L4913c2.  `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] := v0 @kind object;
  #L4913c6.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.processors.MulticastProcessor` v1 @kind this, `int` v2 , `boolean` v3 ) @signature `Lio/reactivex/processors/MulticastProcessor;.<init>:(IZ)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L4913d8.  call `<init>`(v1) @signature `Lio/reactivex/processors/FlowableProcessor;.<init>:()V` @kind direct;
  #L4913de.  v0:= "bufferSize" @kind object;
  #L4913e2.  call temp:= `verifyPositive`(v2, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.verifyPositive:(ILjava/lang/String;)I` @kind static;
  #L4913e8.  v1.`io.reactivex.processors.MulticastProcessor.f` @type ^`int` := v2;
  #L4913ec.  v0:= v2 ^> 2;
  #L4913f0.  v2:= v2 - v0 @kind int;
  #L4913f2.  v1.`io.reactivex.processors.MulticastProcessor.g` @type ^`int` := v2;
  #L4913f6.  v2:= new `java.util.concurrent.atomic.AtomicInteger`;
  #L4913fa.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L491400.  v1.`io.reactivex.processors.MulticastProcessor.b` @type ^`java.util.concurrent.atomic.AtomicInteger` := v2 @kind object;
  #L491404.  v2:= new `java.util.concurrent.atomic.AtomicReference`;
  #L491408.  v0:= `@@io.reactivex.processors.MulticastProcessor.n` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L49140c.  call `<init>`(v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L491412.  v1.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` := v2 @kind object;
  #L491416.  v2:= new `java.util.concurrent.atomic.AtomicReference`;
  #L49141a.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L491420.  v1.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` := v2 @kind object;
  #L491424.  v1.`io.reactivex.processors.MulticastProcessor.h` @type ^`boolean` := v3 @kind boolean;
  #L491428.  v2:= new `java.util.concurrent.atomic.AtomicBoolean`;
  #L49142c.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.<init>:()V` @kind direct;
  #L491432.  v1.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` := v2 @kind object;
  #L491436.  return @kind void;
}
procedure `io.reactivex.processors.MulticastProcessor` `create`() @signature `Lio/reactivex/processors/MulticastProcessor;.create:()Lio/reactivex/processors/MulticastProcessor;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L491300.  v0:= new `io.reactivex.processors.MulticastProcessor`;
  #L491304.  call temp:= `bufferSize`() @signature `Lio/reactivex/Flowable;.bufferSize:()I` @kind static;
  #L49130a.  v1:= temp;
  #L49130c.  v2:= 0I;
  #L49130e.  call `<init>`(v0, v1, v2) @signature `Lio/reactivex/processors/MulticastProcessor;.<init>:(IZ)V` @kind direct;
  #L491314.  return v0 @kind object;
}
procedure `io.reactivex.processors.MulticastProcessor` `create`(`int` v2 ) @signature `Lio/reactivex/processors/MulticastProcessor;.create:(I)Lio/reactivex/processors/MulticastProcessor;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L49134c.  v0:= new `io.reactivex.processors.MulticastProcessor`;
  #L491350.  v1:= 0I;
  #L491352.  call `<init>`(v0, v2, v1) @signature `Lio/reactivex/processors/MulticastProcessor;.<init>:(IZ)V` @kind direct;
  #L491358.  return v0 @kind object;
}
procedure `io.reactivex.processors.MulticastProcessor` `create`(`int` v1 , `boolean` v2 ) @signature `Lio/reactivex/processors/MulticastProcessor;.create:(IZ)Lio/reactivex/processors/MulticastProcessor;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L49136c.  v0:= new `io.reactivex.processors.MulticastProcessor`;
  #L491370.  call `<init>`(v0, v1, v2) @signature `Lio/reactivex/processors/MulticastProcessor;.<init>:(IZ)V` @kind direct;
  #L491376.  return v0 @kind object;
}
procedure `io.reactivex.processors.MulticastProcessor` `create`(`boolean` v2 ) @signature `Lio/reactivex/processors/MulticastProcessor;.create:(Z)Lio/reactivex/processors/MulticastProcessor;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L491328.  v0:= new `io.reactivex.processors.MulticastProcessor`;
  #L49132c.  call temp:= `bufferSize`() @signature `Lio/reactivex/Flowable;.bufferSize:()I` @kind static;
  #L491332.  v1:= temp;
  #L491334.  call `<init>`(v0, v1, v2) @signature `Lio/reactivex/processors/MulticastProcessor;.<init>:(IZ)V` @kind direct;
  #L49133a.  return v0 @kind object;
}
procedure `boolean` `e`(`io.reactivex.processors.MulticastProcessor` v4 @kind this, `io.reactivex.processors.MulticastProcessor$a` v5 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.e:(Lio/reactivex/processors/MulticastProcessor$a;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4911c8.  v0:= v4.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4911cc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4911d2.  v0:= temp @kind object;
  #L4911d4.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L4911d8.  v1:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L4911dc.  v2:= 0I;
  #L4911de.  if v0 != v1 then goto L4911e4;
  #L4911e2.  return v2;
  #L4911e4.  v1:= length @variable v0;
  #L4911e6.  v3:= v1 + 1;
  #L4911ea.  v3:= new `io.reactivex.processors.MulticastProcessor$a`[v3];
  #L4911ee.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4911f4.  v3[v1]:= v5 @kind object;
  #L4911f8.  v1:= v4.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4911fc.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L491202.  v0:= temp;
  #L491204.  if v0 == 0 then goto L4911c8;
  #L491208.  v5:= 1I;
  #L49120a.  return v5;
}
procedure `void` `f`(`io.reactivex.processors.MulticastProcessor` v21 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;

  #L491448.  v1:= v21 @kind object;
  #L49144c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.b` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L491450.  call temp:= `getAndIncrement`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L491456.  v0:= temp;
  #L491458.  if v0 == 0 then goto L49145e;
  #L49145c.  return @kind void;
  #L49145e.  v2:= v1.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491462.  v0:= v1.`io.reactivex.processors.MulticastProcessor.l` @type ^`int`;
  #L491466.  v3:= v1.`io.reactivex.processors.MulticastProcessor.g` @type ^`int`;
  #L49146a.  v4:= v1.`io.reactivex.processors.MulticastProcessor.m` @type ^`int`;
  #L49146e.  v5:= 1I;
  #L491470.  v6:= 1I;
  #L491472.  v7:= v1.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L491476.  if v7 == 0 then goto L491690;
  #L49147a.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L491480.  v8:= temp @kind object;
  #L491482.  v8:= (`io.reactivex.processors.MulticastProcessor$a`[]) v8 @kind object;
  #L491486.  v9:= length @variable v8;
  #L491488.  if v9 == 0 then goto L491690;
  #L49148c.  v9:= length @variable v8;
  #L49148e.  v10:= -1L;
  #L491492.  v14:= v10 @kind wide;
  #L491494.  v13:= 0I;
  #L491496.  v16:= 0L;
  #L49149a.  if v13 >= v9 then goto L4914de;
  #L49149e.  v12:= v8[v13] @kind object;
  #L4914a2.  call temp:= `get`(v12) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L4914a8.  v18:= temp @kind wide;
  #L4914aa.  v20:= lcmp(v18, v16);
  #L4914ae.  if v20 < 0 then goto L4914d4;
  #L4914b2.  v16:= lcmp(v14, v10);
  #L4914b6.  if v16 != 0 then goto L4914c4;
  #L4914ba.  v14:= v12.`io.reactivex.processors.MulticastProcessor$a.c` @type ^`long` @kind wide;
  #L4914be.  v14:= v18 - v14 @kind long;
  #L4914c2.  goto L4914d4;
  #L4914c4.  v10:= v12.`io.reactivex.processors.MulticastProcessor$a.c` @type ^`long` @kind wide;
  #L4914c8.  v10:= v18 - v10 @kind long;
  #L4914cc.  call temp:= `min`(v14, v10) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L4914d2.  v14:= temp @kind wide;
  #L4914d4.  v13:= v13 + 1;
  #L4914d8.  v10:= -1L;
  #L4914dc.  goto L491496;
  #L4914de.  v9:= v0;
  #L4914e0.  v10:= lcmp(v14, v16);
  #L4914e4.  if v10 <= 0 then goto L4915f6;
  #L4914e8.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4914ee.  v0:= temp @kind object;
  #L4914f0.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L4914f4.  v11:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L4914f8.  if v0 != v11 then goto L491504;
  #L4914fc.  call `clear`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.clear:()V` @kind interface;
  #L491502.  return @kind void;
  #L491504.  if v8 == v0 then goto L49150c;
  #L491508.  goto L49161a;
  #L49150c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.j` @type ^`boolean` @kind boolean;
  #L491510.  call temp:= `poll`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L491516.  v11:= temp @kind object;
  #L491518.  goto L49153c;
  #L49151a.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L49151c.  v11:= v0 @kind object;
  #L49151e.  call `throwIfFatal`(v11) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L491524.  v0:= v1.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491528.  call temp:= `cancel`(v0) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.cancel:(Ljava/util/concurrent/atomic/AtomicReference;)Z` @kind static;
  #L49152e.  v0:= 0I;
  #L491530.  v1.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` := v11 @kind object;
  #L491534.  v1.`io.reactivex.processors.MulticastProcessor.j` @type ^`boolean` := v5 @kind boolean;
  #L491538.  v11:= v0 @kind object;
  #L49153a.  v0:= 1I;
  #L49153c.  if v11 != 0 then goto L491544;
  #L491540.  v12:= 1I;
  #L491542.  goto L491546;
  #L491544.  v12:= 0I;
  #L491546.  if v0 == 0 then goto L4915a8;
  #L49154a.  if v12 == 0 then goto L4915a8;
  #L49154e.  v0:= v1.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` @kind object;
  #L491552.  if v0 == 0 then goto L49157e;
  #L491556.  v3:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L49155a.  call temp:= `getAndSet`(v2, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L491560.  v2:= temp @kind object;
  #L491562.  v2:= (`io.reactivex.processors.MulticastProcessor$a`[]) v2 @kind object;
  #L491566.  v3:= length @variable v2;
  #L491568.  v12:= 0I;
  #L49156a.  if v12 >= v3 then goto L4915a6;
  #L49156e.  v4:= v2[v12] @kind object;
  #L491572.  call `b`(v4, v0) @signature `Lio/reactivex/processors/MulticastProcessor$a;.b:(Ljava/lang/Throwable;)V` @kind virtual;
  #L491578.  v12:= v12 + 1;
  #L49157c.  goto L49156a;
  #L49157e.  v0:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L491582.  call temp:= `getAndSet`(v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L491588.  v0:= temp @kind object;
  #L49158a.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L49158e.  v2:= length @variable v0;
  #L491590.  v12:= 0I;
  #L491592.  if v12 >= v2 then goto L4915a6;
  #L491596.  v3:= v0[v12] @kind object;
  #L49159a.  call `a`(v3) @signature `Lio/reactivex/processors/MulticastProcessor$a;.a:()V` @kind virtual;
  #L4915a0.  v12:= v12 + 1;
  #L4915a4.  goto L491592;
  #L4915a6.  return @kind void;
  #L4915a8.  if v12 == 0 then goto L4915ae;
  #L4915ac.  goto L4915f6;
  #L4915ae.  v0:= length @variable v8;
  #L4915b0.  v10:= 0I;
  #L4915b2.  if v10 >= v0 then goto L4915c6;
  #L4915b6.  v12:= v8[v10] @kind object;
  #L4915ba.  call `c`(v12, v11) @signature `Lio/reactivex/processors/MulticastProcessor$a;.c:(Ljava/lang/Object;)V` @kind virtual;
  #L4915c0.  v10:= v10 + 1;
  #L4915c4.  goto L4915b2;
  #L4915c6.  v10:= 1L;
  #L4915ca.  v14:= v14 - v10 @kind long;
  #L4915cc.  if v4 == v5 then goto L4914e0;
  #L4915d0.  v9:= v9 + 1;
  #L4915d4.  if v9 != v3 then goto L4914e0;
  #L4915d8.  v0:= v1.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4915dc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4915e2.  v0:= temp @kind object;
  #L4915e4.  v0:= (`org.reactivestreams.Subscription`) v0 @kind object;
  #L4915e8.  v9:= (`long`) v3 @kind i2l;
  #L4915ea.  call `request`(v0, v9) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L4915f0.  v9:= 0I;
  #L4915f2.  goto L4914e0;
  #L4915f6.  if v10 != 0 then goto L49168e;
  #L4915fa.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L491600.  v0:= temp @kind object;
  #L491602.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L491606.  v10:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L49160a.  if v0 != v10 then goto L491616;
  #L49160e.  call `clear`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.clear:()V` @kind interface;
  #L491614.  return @kind void;
  #L491616.  if v8 == v0 then goto L491620;
  #L49161a.  v0:= v9;
  #L49161c.  goto L491472;
  #L491620.  v0:= v1.`io.reactivex.processors.MulticastProcessor.j` @type ^`boolean` @kind boolean;
  #L491624.  if v0 == 0 then goto L49168e;
  #L491628.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L49162e.  v0:= temp;
  #L491630.  if v0 == 0 then goto L49168e;
  #L491634.  v0:= v1.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` @kind object;
  #L491638.  if v0 == 0 then goto L491664;
  #L49163c.  v3:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L491640.  call temp:= `getAndSet`(v2, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L491646.  v2:= temp @kind object;
  #L491648.  v2:= (`io.reactivex.processors.MulticastProcessor$a`[]) v2 @kind object;
  #L49164c.  v3:= length @variable v2;
  #L49164e.  v12:= 0I;
  #L491650.  if v12 >= v3 then goto L49168c;
  #L491654.  v4:= v2[v12] @kind object;
  #L491658.  call `b`(v4, v0) @signature `Lio/reactivex/processors/MulticastProcessor$a;.b:(Ljava/lang/Throwable;)V` @kind virtual;
  #L49165e.  v12:= v12 + 1;
  #L491662.  goto L491650;
  #L491664.  v0:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L491668.  call temp:= `getAndSet`(v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L49166e.  v0:= temp @kind object;
  #L491670.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L491674.  v2:= length @variable v0;
  #L491676.  v12:= 0I;
  #L491678.  if v12 >= v2 then goto L49168c;
  #L49167c.  v3:= v0[v12] @kind object;
  #L491680.  call `a`(v3) @signature `Lio/reactivex/processors/MulticastProcessor$a;.a:()V` @kind virtual;
  #L491686.  v12:= v12 + 1;
  #L49168a.  goto L491678;
  #L49168c.  return @kind void;
  #L49168e.  v0:= v9;
  #L491690.  v1.`io.reactivex.processors.MulticastProcessor.l` @type ^`int` := v0;
  #L491694.  v7:= v1.`io.reactivex.processors.MulticastProcessor.b` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L491698.  v6:= -v6 @kind int;
  #L49169a.  call temp:= `addAndGet`(v7, v6) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L4916a0.  v6:= temp;
  #L4916a2.  if v6 != 0 then goto L491472;
  #L4916a6.  return @kind void;
  catch `java.lang.Throwable` @[L491510..L491518] goto L49151a;
}
procedure `void` `g`(`io.reactivex.processors.MulticastProcessor` v6 @kind this, `io.reactivex.processors.MulticastProcessor$a` v7 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.g:(Lio/reactivex/processors/MulticastProcessor$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L491834.  v0:= v6.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491838.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L49183e.  v0:= temp @kind object;
  #L491840.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L491844.  v1:= length @variable v0;
  #L491846.  if v1 != 0 then goto L49184c;
  #L49184a.  return @kind void;
  #L49184c.  v2:= -1I;
  #L49184e.  v3:= 0I;
  #L491850.  v4:= 0I;
  #L491852.  if v4 >= v1 then goto L491868;
  #L491856.  v5:= v0[v4] @kind object;
  #L49185a.  if v5 != v7 then goto L491862;
  #L49185e.  v2:= v4;
  #L491860.  goto L491868;
  #L491862.  v4:= v4 + 1;
  #L491866.  goto L491852;
  #L491868.  if v2 >= 0 then goto L49186e;
  #L49186c.  goto L4918e8;
  #L49186e.  v4:= 1I;
  #L491870.  if v1 != v4 then goto L4918bc;
  #L491874.  v1:= v6.`io.reactivex.processors.MulticastProcessor.h` @type ^`boolean` @kind boolean;
  #L491878.  if v1 == 0 then goto L4918a6;
  #L49187c.  v1:= v6.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491880.  v2:= `@@io.reactivex.processors.MulticastProcessor.o` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L491884.  call temp:= `compareAndSet`(v1, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L49188a.  v0:= temp;
  #L49188c.  if v0 == 0 then goto L491834;
  #L491890.  v7:= v6.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491894.  call temp:= `cancel`(v7) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.cancel:(Ljava/util/concurrent/atomic/AtomicReference;)Z` @kind static;
  #L49189a.  v7:= v6.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L49189e.  call `set`(v7, v4) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.set:(Z)V` @kind virtual;
  #L4918a4.  goto L4918e8;
  #L4918a6.  v1:= v6.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4918aa.  v2:= `@@io.reactivex.processors.MulticastProcessor.n` @type ^`io.reactivex.processors.MulticastProcessor$a`[] @kind object;
  #L4918ae.  call temp:= `compareAndSet`(v1, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L4918b4.  v0:= temp;
  #L4918b6.  if v0 == 0 then goto L491834;
  #L4918ba.  goto L4918e8;
  #L4918bc.  v5:= v1 + -1;
  #L4918c0.  v5:= new `io.reactivex.processors.MulticastProcessor$a`[v5];
  #L4918c4.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4918ca.  v3:= v2 + 1;
  #L4918ce.  v1:= v1 - v2 @kind int;
  #L4918d0.  v1:= v1 - v4 @kind int;
  #L4918d2.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4918d8.  v1:= v6.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4918dc.  call temp:= `compareAndSet`(v1, v0, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L4918e2.  v0:= temp;
  #L4918e4.  if v0 == 0 then goto L491834;
  #L4918e8.  return @kind void;
}
procedure `java.lang.Throwable` `getThrowable`(`io.reactivex.processors.MulticastProcessor` v1 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.getThrowable:()Ljava/lang/Throwable;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L491388.  v0:= v1.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L49138c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L491392.  v0:= temp;
  #L491394.  if v0 == 0 then goto L49139e;
  #L491398.  v0:= v1.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` @kind object;
  #L49139c.  goto L4913a0;
  #L49139e.  v0:= 0I;
  #L4913a0.  return v0 @kind object;
}
procedure `boolean` `hasComplete`(`io.reactivex.processors.MulticastProcessor` v1 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.hasComplete:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L49121c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L491220.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L491226.  v0:= temp;
  #L491228.  if v0 == 0 then goto L491238;
  #L49122c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` @kind object;
  #L491230.  if v0 != 0 then goto L491238;
  #L491234.  v0:= 1I;
  #L491236.  goto L49123a;
  #L491238.  v0:= 0I;
  #L49123a.  return v0;
}
procedure `boolean` `hasSubscribers`(`io.reactivex.processors.MulticastProcessor` v1 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.hasSubscribers:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L49124c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491250.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L491256.  v0:= temp @kind object;
  #L491258.  v0:= (`io.reactivex.processors.MulticastProcessor$a`[]) v0 @kind object;
  #L49125c.  v0:= length @variable v0;
  #L49125e.  if v0 == 0 then goto L491266;
  #L491262.  v0:= 1I;
  #L491264.  goto L491268;
  #L491266.  v0:= 0I;
  #L491268.  return v0;
}
procedure `boolean` `hasThrowable`(`io.reactivex.processors.MulticastProcessor` v1 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.hasThrowable:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L49127c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L491280.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L491286.  v0:= temp;
  #L491288.  if v0 == 0 then goto L491298;
  #L49128c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` @kind object;
  #L491290.  if v0 == 0 then goto L491298;
  #L491294.  v0:= 1I;
  #L491296.  goto L49129a;
  #L491298.  v0:= 0I;
  #L49129a.  return v0;
}
procedure `boolean` `offer`(`io.reactivex.processors.MulticastProcessor` v2 @kind this, `java.lang.Object` v3 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.offer:(Ljava/lang/Object;)Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4912ac.  v0:= v2.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L4912b0.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L4912b6.  v0:= temp;
  #L4912b8.  v1:= 0I;
  #L4912ba.  if v0 == 0 then goto L4912c0;
  #L4912be.  return v1;
  #L4912c0.  v0:= "offer called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L4912c4.  call temp:= `requireNonNull`(v3, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L4912ca.  v0:= v2.`io.reactivex.processors.MulticastProcessor.m` @type ^`int`;
  #L4912ce.  if v0 != 0 then goto L4912ec;
  #L4912d2.  v0:= v2.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L4912d6.  call temp:= `offer`(v0, v3) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L4912dc.  v3:= temp;
  #L4912de.  if v3 == 0 then goto L4912ec;
  #L4912e2.  call `f`(v2) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @kind virtual;
  #L4912e8.  v3:= 1I;
  #L4912ea.  return v3;
  #L4912ec.  return v1;
}
procedure `void` `onComplete`(`io.reactivex.processors.MulticastProcessor` v3 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4916c4.  v0:= v3.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L4916c8.  v1:= 0I;
  #L4916ca.  v2:= 1I;
  #L4916cc.  call temp:= `compareAndSet`(v0, v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.compareAndSet:(ZZ)Z` @kind virtual;
  #L4916d2.  v0:= temp;
  #L4916d4.  if v0 == 0 then goto L4916e2;
  #L4916d8.  v3.`io.reactivex.processors.MulticastProcessor.j` @type ^`boolean` := v2 @kind boolean;
  #L4916dc.  call `f`(v3) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @kind virtual;
  #L4916e2.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.processors.MulticastProcessor` v3 @kind this, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4916f4.  v0:= "onError called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L4916f8.  call temp:= `requireNonNull`(v4, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L4916fe.  v0:= v3.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L491702.  v1:= 0I;
  #L491704.  v2:= 1I;
  #L491706.  call temp:= `compareAndSet`(v0, v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.compareAndSet:(ZZ)Z` @kind virtual;
  #L49170c.  v0:= temp;
  #L49170e.  if v0 == 0 then goto L491722;
  #L491712.  v3.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` := v4 @kind object;
  #L491716.  v3.`io.reactivex.processors.MulticastProcessor.j` @type ^`boolean` := v2 @kind boolean;
  #L49171a.  call `f`(v3) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @kind virtual;
  #L491720.  goto L491728;
  #L491722.  call `onError`(v4) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L491728.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.processors.MulticastProcessor` v1 @kind this, `java.lang.Object` v2 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L49173c.  v0:= v1.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L491740.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L491746.  v0:= temp;
  #L491748.  if v0 == 0 then goto L49174e;
  #L49174c.  return @kind void;
  #L49174e.  v0:= v1.`io.reactivex.processors.MulticastProcessor.m` @type ^`int`;
  #L491752.  if v0 != 0 then goto L49178c;
  #L491756.  v0:= "onNext called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L49175a.  call temp:= `requireNonNull`(v2, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L491760.  v0:= v1.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L491764.  call temp:= `offer`(v0, v2) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L49176a.  v2:= temp;
  #L49176c.  if v2 != 0 then goto L49178c;
  #L491770.  v2:= v1.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491774.  call temp:= `cancel`(v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.cancel:(Ljava/util/concurrent/atomic/AtomicReference;)Z` @kind static;
  #L49177a.  v2:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L49177e.  call `<init>`(v2) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:()V` @kind direct;
  #L491784.  call `onError`(v1, v2) @signature `Lio/reactivex/processors/MulticastProcessor;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L49178a.  return @kind void;
  #L49178c.  call `f`(v1) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @kind virtual;
  #L491792.  return @kind void;
}
procedure `void` `onSubscribe`(`io.reactivex.processors.MulticastProcessor` v3 @kind this, `org.reactivestreams.Subscription` v4 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4917a4.  v0:= v3.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4917a8.  call temp:= `setOnce`(v0, v4) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.setOnce:(Ljava/util/concurrent/atomic/AtomicReference;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L4917ae.  v0:= temp;
  #L4917b0.  if v0 == 0 then goto L491820;
  #L4917b4.  v0:= instanceof @variable v4 @type ^`io.reactivex.internal.fuseable.QueueSubscription` @kind boolean;
  #L4917b8.  if v0 == 0 then goto L491802;
  #L4917bc.  v0:= v4 @kind object;
  #L4917be.  v0:= (`io.reactivex.internal.fuseable.QueueSubscription`) v0 @kind object;
  #L4917c2.  v1:= 3I;
  #L4917c4.  call temp:= `requestFusion`(v0, v1) @signature `Lio/reactivex/internal/fuseable/QueueFuseable;.requestFusion:(I)I` @kind interface;
  #L4917ca.  v1:= temp;
  #L4917cc.  v2:= 1I;
  #L4917ce.  if v1 != v2 then goto L4917e6;
  #L4917d2.  v3.`io.reactivex.processors.MulticastProcessor.m` @type ^`int` := v1;
  #L4917d6.  v3.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L4917da.  v3.`io.reactivex.processors.MulticastProcessor.j` @type ^`boolean` := v2 @kind boolean;
  #L4917de.  call `f`(v3) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @kind virtual;
  #L4917e4.  return @kind void;
  #L4917e6.  v2:= 2I;
  #L4917e8.  if v1 != v2 then goto L491802;
  #L4917ec.  v3.`io.reactivex.processors.MulticastProcessor.m` @type ^`int` := v1;
  #L4917f0.  v3.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L4917f4.  v0:= v3.`io.reactivex.processors.MulticastProcessor.f` @type ^`int`;
  #L4917f8.  v0:= (`long`) v0 @kind i2l;
  #L4917fa.  call `request`(v4, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L491800.  return @kind void;
  #L491802.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L491806.  v1:= v3.`io.reactivex.processors.MulticastProcessor.f` @type ^`int`;
  #L49180a.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L491810.  v3.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L491814.  v0:= v3.`io.reactivex.processors.MulticastProcessor.f` @type ^`int`;
  #L491818.  v0:= (`long`) v0 @kind i2l;
  #L49181a.  call `request`(v4, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L491820.  return @kind void;
}
procedure `void` `start`(`io.reactivex.processors.MulticastProcessor` v2 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.start:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4918fc.  v0:= v2.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491900.  v1:= `@@io.reactivex.internal.subscriptions.EmptySubscription.INSTANCE` @type ^`io.reactivex.internal.subscriptions.EmptySubscription` @kind object;
  #L491904.  call temp:= `setOnce`(v0, v1) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.setOnce:(Ljava/util/concurrent/atomic/AtomicReference;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L49190a.  v0:= temp;
  #L49190c.  if v0 == 0 then goto L491922;
  #L491910.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L491914.  v1:= v2.`io.reactivex.processors.MulticastProcessor.f` @type ^`int`;
  #L491918.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L49191e.  v2.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L491922.  return @kind void;
}
procedure `void` `startUnbounded`(`io.reactivex.processors.MulticastProcessor` v2 @kind this) @signature `Lio/reactivex/processors/MulticastProcessor;.startUnbounded:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L491934.  v0:= v2.`io.reactivex.processors.MulticastProcessor.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L491938.  v1:= `@@io.reactivex.internal.subscriptions.EmptySubscription.INSTANCE` @type ^`io.reactivex.internal.subscriptions.EmptySubscription` @kind object;
  #L49193c.  call temp:= `setOnce`(v0, v1) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.setOnce:(Ljava/util/concurrent/atomic/AtomicReference;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L491942.  v0:= temp;
  #L491944.  if v0 == 0 then goto L49195a;
  #L491948.  v0:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L49194c.  v1:= v2.`io.reactivex.processors.MulticastProcessor.f` @type ^`int`;
  #L491950.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L491956.  v2.`io.reactivex.processors.MulticastProcessor.i` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L49195a.  return @kind void;
}
procedure `void` `subscribeActual`(`io.reactivex.processors.MulticastProcessor` v5 @kind this, `org.reactivestreams.Subscriber` v6 @kind object) @signature `Lio/reactivex/processors/MulticastProcessor;.subscribeActual:(Lorg/reactivestreams/Subscriber;)V` @AccessFlag PROTECTED {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L49196c.  v0:= new `io.reactivex.processors.MulticastProcessor$a`;
  #L491970.  call `<init>`(v0, v6, v5) @signature `Lio/reactivex/processors/MulticastProcessor$a;.<init>:(Lorg/reactivestreams/Subscriber;Lio/reactivex/processors/MulticastProcessor;)V` @kind direct;
  #L491976.  call `onSubscribe`(v6, v0) @signature `Lorg/reactivestreams/Subscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @kind interface;
  #L49197c.  call temp:= `e`(v5, v0) @signature `Lio/reactivex/processors/MulticastProcessor;.e:(Lio/reactivex/processors/MulticastProcessor$a;)Z` @kind virtual;
  #L491982.  v1:= temp;
  #L491984.  if v1 == 0 then goto L4919ac;
  #L491988.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L49198e.  v1:= temp @kind wide;
  #L491990.  v3:= -9223372036854775808L;
  #L491994.  v6:= lcmp(v1, v3);
  #L491998.  if v6 != 0 then goto L4919a4;
  #L49199c.  call `g`(v5, v0) @signature `Lio/reactivex/processors/MulticastProcessor;.g:(Lio/reactivex/processors/MulticastProcessor$a;)V` @kind virtual;
  #L4919a2.  goto L4919da;
  #L4919a4.  call `f`(v5) @signature `Lio/reactivex/processors/MulticastProcessor;.f:()V` @kind virtual;
  #L4919aa.  goto L4919da;
  #L4919ac.  v0:= v5.`io.reactivex.processors.MulticastProcessor.e` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L4919b0.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L4919b6.  v0:= temp;
  #L4919b8.  if v0 != 0 then goto L4919c4;
  #L4919bc.  v0:= v5.`io.reactivex.processors.MulticastProcessor.h` @type ^`boolean` @kind boolean;
  #L4919c0.  if v0 != 0 then goto L4919d4;
  #L4919c4.  v0:= v5.`io.reactivex.processors.MulticastProcessor.k` @type ^`java.lang.Throwable` @kind object;
  #L4919c8.  if v0 == 0 then goto L4919d4;
  #L4919cc.  call `onError`(v6, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L4919d2.  return @kind void;
  #L4919d4.  call `onComplete`(v6) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L4919da.  return @kind void;
}

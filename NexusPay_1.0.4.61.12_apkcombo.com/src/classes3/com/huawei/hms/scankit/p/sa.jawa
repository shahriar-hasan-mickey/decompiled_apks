record `com.huawei.hms.scankit.p.sa` @kind class @AccessFlag FINAL {
}
global `float`[][] `@@com.huawei.hms.scankit.p.sa.a` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lcom/huawei/hms/scankit/p/sa;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;

  #L295bc0.  v0:= `@@com.huawei.hms.scankit.p.ta.b` @type ^`int`[] @kind object;
  #L295bc4.  v0:= length @variable v0;
  #L295bc6.  v1:= 2I;
  #L295bc8.  v1:= new `int`[v1];
  #L295bcc.  v2:= 1I;
  #L295bce.  v3:= 8I;
  #L295bd2.  v1[v2]:= v3;
  #L295bd6.  v4:= 0I;
  #L295bd8.  v1[v4]:= v0;
  #L295bdc.  v0:= constclass @type ^`float` @kind object;
  #L295be0.  call temp:= `newInstance`(v0, v1) @signature `Ljava/lang/reflect/Array;.newInstance:(Ljava/lang/Class;[I)Ljava/lang/Object;` @kind static;
  #L295be6.  v0:= temp @kind object;
  #L295be8.  v0:= (`float`[][]) v0 @kind object;
  #L295bec.  `@@com.huawei.hms.scankit.p.sa.a` @type ^`float`[][] := v0 @kind object;
  #L295bf0.  v0:= 0I;
  #L295bf2.  v1:= `@@com.huawei.hms.scankit.p.ta.b` @type ^`int`[] @kind object;
  #L295bf6.  v5:= length @variable v1;
  #L295bf8.  if v0 >= v5 then goto L295c46;
  #L295bfc.  v1:= v1[v0];
  #L295c00.  v5:= v1 ^& 1;
  #L295c04.  v6:= 0I;
  #L295c06.  if v6 >= v3 then goto L295c40;
  #L295c0a.  v7:= 0I;
  #L295c0c.  v8:= v1 ^& 1;
  #L295c10.  if v8 != v5 then goto L295c20;
  #L295c14.  v8:= 1.0F;
  #L295c18.  v7:= v7 + v8 @kind float;
  #L295c1a.  v1:= v1 ^> 1;
  #L295c1e.  goto L295c0c;
  #L295c20.  v5:= `@@com.huawei.hms.scankit.p.sa.a` @type ^`float`[][] @kind object;
  #L295c24.  v5:= v5[v0] @kind object;
  #L295c28.  v9:= v6 - 8;
  #L295c2c.  v9:= v9 - v2 @kind int;
  #L295c2e.  v10:= 17.0F;
  #L295c32.  v7:= v7 / v10 @kind float;
  #L295c34.  v5[v9]:= v7;
  #L295c38.  v6:= v6 + 1;
  #L295c3c.  v5:= v8;
  #L295c3e.  goto L295c06;
  #L295c40.  v0:= v0 + 1;
  #L295c44.  goto L295bf2;
  #L295c46.  return @kind void;
}
procedure `int` `a`(`int`[] v2 @kind object) @signature `Lcom/huawei/hms/scankit/p/sa;.a:([I)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L295a00.  call temp:= `e`(v2) @signature `Lcom/huawei/hms/scankit/p/sa;.e:([I)[I` @kind static;
  #L295a06.  v0:= temp @kind object;
  #L295a08.  call temp:= `d`(v0) @signature `Lcom/huawei/hms/scankit/p/sa;.d:([I)I` @kind static;
  #L295a0e.  v0:= temp;
  #L295a10.  v1:= -1I;
  #L295a12.  if v0 == v1 then goto L295a18;
  #L295a16.  return v0;
  #L295a18.  call temp:= `c`(v2) @signature `Lcom/huawei/hms/scankit/p/sa;.c:([I)I` @kind static;
  #L295a1e.  v2:= temp;
  #L295a20.  return v2;
}
procedure `int` `b`(`int`[] v7 @kind object) @signature `Lcom/huawei/hms/scankit/p/sa;.b:([I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L295a34.  v0:= 0I;
  #L295a36.  v1:= 0L;
  #L295a3a.  v3:= 0I;
  #L295a3c.  v4:= length @variable v7;
  #L295a3e.  if v3 >= v4 then goto L295a6c;
  #L295a42.  v4:= 0I;
  #L295a44.  v5:= v7[v3];
  #L295a48.  if v4 >= v5 then goto L295a66;
  #L295a4c.  v5:= 1I;
  #L295a4e.  v1:= v1 ^< v5 @kind long;
  #L295a50.  v6:= v3 %% 2;
  #L295a54.  if v6 != 0 then goto L295a5a;
  #L295a58.  goto L295a5c;
  #L295a5a.  v5:= 0I;
  #L295a5c.  v5:= (`long`) v5 @kind i2l;
  #L295a5e.  v1:= v1 ^| v5 @kind long;
  #L295a60.  v4:= v4 + 1;
  #L295a64.  goto L295a44;
  #L295a66.  v3:= v3 + 1;
  #L295a6a.  goto L295a3c;
  #L295a6c.  v7:= (`int`) v1 @kind l2i;
  #L295a6e.  return v7;
}
procedure `int` `c`(`int`[] v10 @kind object) @signature `Lcom/huawei/hms/scankit/p/sa;.c:([I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L295a80.  call temp:= `a`(v10) @signature `Lcom/huawei/hms/scankit/aiscan/common/n;.a:([I)I` @kind static;
  #L295a86.  v0:= temp;
  #L295a88.  v1:= 8I;
  #L295a8c.  v2:= new `float`[v1];
  #L295a90.  v3:= 0I;
  #L295a92.  v4:= 1I;
  #L295a94.  if v0 <= v4 then goto L295ab2;
  #L295a98.  v4:= 0I;
  #L295a9a.  if v4 >= v1 then goto L295ab2;
  #L295a9e.  v5:= v10[v4];
  #L295aa2.  v5:= (`float`) v5 @kind i2f;
  #L295aa4.  v6:= (`float`) v0 @kind i2f;
  #L295aa6.  v5:= v5 / v6 @kind float;
  #L295aa8.  v2[v4]:= v5;
  #L295aac.  v4:= v4 + 1;
  #L295ab0.  goto L295a9a;
  #L295ab2.  v10:= 2139095039I;
  #L295ab8.  v0:= -1I;
  #L295aba.  v4:= 0I;
  #L295abc.  v5:= `@@com.huawei.hms.scankit.p.sa.a` @type ^`float`[][] @kind object;
  #L295ac0.  v6:= length @variable v5;
  #L295ac2.  if v4 >= v6 then goto L295b0c;
  #L295ac6.  v6:= 0I;
  #L295ac8.  v5:= v5[v4] @kind object;
  #L295acc.  v7:= 0I;
  #L295ace.  if v7 >= v1 then goto L295af2;
  #L295ad2.  v8:= v5[v7];
  #L295ad6.  v9:= v2[v7];
  #L295ada.  v8:= v8 - v9 @kind float;
  #L295adc.  v8:= v8 * v8 @kind float;
  #L295ae0.  v6:= v6 + v8 @kind float;
  #L295ae2.  v8:= fcmpl(v6, v10);
  #L295ae6.  if v8 < 0 then goto L295aec;
  #L295aea.  goto L295af2;
  #L295aec.  v7:= v7 + 1;
  #L295af0.  goto L295ace;
  #L295af2.  v5:= fcmpg(v6, v10);
  #L295af6.  if v5 >= 0 then goto L295b06;
  #L295afa.  v10:= `@@com.huawei.hms.scankit.p.ta.b` @type ^`int`[] @kind object;
  #L295afe.  v10:= v10[v4];
  #L295b02.  v0:= v10;
  #L295b04.  v10:= v6;
  #L295b06.  v4:= v4 + 1;
  #L295b0a.  goto L295abc;
  #L295b0c.  return v0;
}
procedure `int` `d`(`int`[] v2 @kind object) @signature `Lcom/huawei/hms/scankit/p/sa;.d:([I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L295b20.  call temp:= `b`(v2) @signature `Lcom/huawei/hms/scankit/p/sa;.b:([I)I` @kind static;
  #L295b26.  v2:= temp;
  #L295b28.  call temp:= `a`(v2) @signature `Lcom/huawei/hms/scankit/p/ta;.a:(I)I` @kind static;
  #L295b2e.  v0:= temp;
  #L295b30.  v1:= -1I;
  #L295b32.  if v0 != v1 then goto L295b38;
  #L295b36.  v2:= -1I;
  #L295b38.  return v2;
}
procedure `int`[] `e`(`int`[] v8 @kind object) @signature `Lcom/huawei/hms/scankit/p/sa;.e:([I)[I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L295b4c.  call temp:= `a`(v8) @signature `Lcom/huawei/hms/scankit/aiscan/common/n;.a:([I)I` @kind static;
  #L295b52.  v0:= temp;
  #L295b54.  v0:= (`float`) v0 @kind i2f;
  #L295b56.  v1:= 8I;
  #L295b5a.  v1:= new `int`[v1];
  #L295b5e.  v2:= 0I;
  #L295b60.  v3:= 0I;
  #L295b62.  v4:= 0I;
  #L295b64.  v5:= 17I;
  #L295b68.  if v2 >= v5 then goto L295bae;
  #L295b6c.  v5:= 34.0F;
  #L295b70.  v5:= v0 / v5 @kind float;
  #L295b74.  v6:= (`float`) v2 @kind i2f;
  #L295b76.  v6:= v6 * v0 @kind float;
  #L295b7a.  v7:= 17.0F;
  #L295b7e.  v6:= v6 / v7 @kind float;
  #L295b80.  v5:= v5 + v6 @kind float;
  #L295b82.  v6:= v8[v4];
  #L295b86.  v6:= v6 + v3 @kind int;
  #L295b88.  v6:= (`float`) v6 @kind i2f;
  #L295b8a.  v5:= fcmpg(v6, v5);
  #L295b8e.  if v5 > 0 then goto L295b9c;
  #L295b92.  v5:= v8[v4];
  #L295b96.  v3:= v3 + v5 @kind int;
  #L295b98.  v4:= v4 + 1;
  #L295b9c.  v5:= v1[v4];
  #L295ba0.  v5:= v5 + 1;
  #L295ba4.  v1[v4]:= v5;
  #L295ba8.  v2:= v2 + 1;
  #L295bac.  goto L295b64;
  #L295bae.  return v1 @kind object;
}

record `org.bouncycastle.crypto.util.Pack` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
procedure `void` `<init>`(`org.bouncycastle.crypto.util.Pack` v0 @kind this) @signature `Lorg/bouncycastle/crypto/util/Pack;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {

  # return;
}
procedure `int` `bigEndianToInt`(`byte`[] v2 @kind object, `int` v3 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.bigEndianToInt:([BI)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `bigEndianToInt`(`byte`[] v2 @kind object, `int` v3 , `int`[] v4 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.bigEndianToInt:([BI[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long` `bigEndianToLong`(`byte`[] v4 @kind object, `int` v5 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.bigEndianToLong:([BI)J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `bigEndianToLong`(`byte`[] v3 @kind object, `int` v4 , `long`[] v5 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.bigEndianToLong:([BI[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `intToBigEndian`(`int` v1 , `byte`[] v2 @kind object, `int` v3 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToBigEndian:(I[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `intToBigEndian`(`int`[] v2 @kind object, `byte`[] v3 @kind object, `int` v4 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToBigEndian:([I[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `intToBigEndian`(`int` v2 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToBigEndian:(I)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `intToBigEndian`(`int`[] v2 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToBigEndian:([I)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `intToLittleEndian`(`int` v1 , `byte`[] v2 @kind object, `int` v3 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToLittleEndian:(I[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `intToLittleEndian`(`int`[] v2 @kind object, `byte`[] v3 @kind object, `int` v4 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToLittleEndian:([I[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `intToLittleEndian`(`int` v2 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToLittleEndian:(I)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `intToLittleEndian`(`int`[] v2 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.intToLittleEndian:([I)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `littleEndianToInt`(`byte`[] v2 @kind object, `int` v3 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.littleEndianToInt:([BI)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `littleEndianToInt`(`byte`[] v2 @kind object, `int` v3 , `int`[] v4 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.littleEndianToInt:([BI[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long` `littleEndianToLong`(`byte`[] v5 @kind object, `int` v6 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.littleEndianToLong:([BI)J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `littleEndianToLong`(`byte`[] v3 @kind object, `int` v4 , `long`[] v5 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.littleEndianToLong:([BI[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `longToBigEndian`(`long` v2 , `byte`[] v4 @kind object, `int` v5 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToBigEndian:(J[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `longToBigEndian`(`long`[] v3 @kind object, `byte`[] v4 @kind object, `int` v5 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToBigEndian:([J[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `longToBigEndian`(`long` v2 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToBigEndian:(J)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `longToBigEndian`(`long`[] v2 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToBigEndian:([J)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `longToLittleEndian`(`long` v2 , `byte`[] v4 @kind object, `int` v5 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToLittleEndian:(J[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `longToLittleEndian`(`long`[] v3 @kind object, `byte`[] v4 @kind object, `int` v5 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToLittleEndian:([J[BI)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `longToLittleEndian`(`long` v2 ) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToLittleEndian:(J)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `longToLittleEndian`(`long`[] v2 @kind object) @signature `Lorg/bouncycastle/crypto/util/Pack;.longToLittleEndian:([J)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}

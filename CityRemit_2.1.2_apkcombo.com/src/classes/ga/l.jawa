record `ga.l` @kind class @AccessFlag PUBLIC {
  `boolean` `ga.l.a` @AccessFlag PUBLIC_FINAL;
  `byte`[] `ga.l.b` @AccessFlag PRIVATE;
  `ha.k` `ga.l.c` @AccessFlag PRIVATE;
  `ha.k$d` `ga.l.d` @AccessFlag PRIVATE;
  `boolean` `ga.l.e` @AccessFlag PRIVATE;
  `boolean` `ga.l.f` @AccessFlag PRIVATE;
  `ha.k$c` `ga.l.g` @AccessFlag PRIVATE_FINAL;
}
procedure `void` `<init>`(`ga.l` v1 @kind this, `ha.k` v2 @kind object, `boolean` v3 ) @signature `Lga/l;.<init>:(Lha/k;Z)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L32cfe0.  call `<init>`(v1) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L32cfe6.  v0:= 0I;
  #L32cfe8.  v1.`ga.l.e` @type ^`boolean` := v0 @kind boolean;
  #L32cfec.  v1.`ga.l.f` @type ^`boolean` := v0 @kind boolean;
  #L32cff0.  v0:= new `ga.l$b`;
  #L32cff4.  call `<init>`(v0, v1) @signature `Lga/l$b;.<init>:(Lga/l;)V` @kind direct;
  #L32cffa.  v1.`ga.l.g` @type ^`ha.k$c` := v0 @kind object;
  #L32cffe.  v1.`ga.l.c` @type ^`ha.k` := v2 @kind object;
  #L32d002.  v1.`ga.l.a` @type ^`boolean` := v3 @kind boolean;
  #L32d006.  call `e`(v2, v0) @signature `Lha/k;.e:(Lha/k$c;)V` @kind virtual;
  #L32d00c.  return @kind void;
}
procedure `void` `<init>`(`ga.l` v3 @kind this, `u9.a` v4 @kind object, `boolean` v5 ) @signature `Lga/l;.<init>:(Lu9/a;Z)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;

  #L32d020.  v0:= new `ha.k`;
  #L32d024.  v1:= `@@ha.s.b` @type ^`ha.s` @kind object;
  #L32d028.  v2:= "flutter/restoration" @kind object;
  #L32d02c.  call `<init>`(v0, v4, v2, v1) @signature `Lha/k;.<init>:(Lha/c;Ljava/lang/String;Lha/l;)V` @kind direct;
  #L32d032.  call `<init>`(v3, v0, v5) @signature `Lga/l;.<init>:(Lha/k;Z)V` @kind direct;
  #L32d038.  return @kind void;
}
procedure `byte`[] `a`(`ga.l` v0 @kind object) @signature `Lga/l;.a:(Lga/l;)[B` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L32cf30.  v0:= v0.`ga.l.b` @type ^`byte`[] @kind object;
  #L32cf34.  return v0 @kind object;
}
procedure `byte`[] `b`(`ga.l` v0 @kind object, `byte`[] v1 @kind object) @signature `Lga/l;.b:(Lga/l;[B)[B` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L32cf48.  v0.`ga.l.b` @type ^`byte`[] := v1 @kind object;
  #L32cf4c.  return v1 @kind object;
}
procedure `boolean` `c`(`ga.l` v0 @kind object, `boolean` v1 ) @signature `Lga/l;.c:(Lga/l;Z)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L32cf00.  v0.`ga.l.f` @type ^`boolean` := v1 @kind boolean;
  #L32cf04.  return v1;
}
procedure `boolean` `d`(`ga.l` v0 @kind object) @signature `Lga/l;.d:(Lga/l;)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L32cf18.  v0:= v0.`ga.l.e` @type ^`boolean` @kind boolean;
  #L32cf1c.  return v0;
}
procedure `java.util.Map` `e`(`ga.l` v0 @kind object, `byte`[] v1 @kind object) @signature `Lga/l;.e:(Lga/l;[B)Ljava/util/Map;` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L32cf90.  call temp:= `i`(v0, v1) @signature `Lga/l;.i:([B)Ljava/util/Map;` @kind direct;
  #L32cf96.  v0:= temp @kind object;
  #L32cf98.  return v0 @kind object;
}
procedure `ha.k$d` `f`(`ga.l` v0 @kind object, `ha.k$d` v1 @kind object) @signature `Lga/l;.f:(Lga/l;Lha/k$d;)Lha/k$d;` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L32cf78.  v0.`ga.l.d` @type ^`ha.k$d` := v1 @kind object;
  #L32cf7c.  return v1 @kind object;
}
procedure `java.util.Map` `i`(`ga.l` v3 @kind this, `byte`[] v4 @kind object) @signature `Lga/l;.i:([B)Ljava/util/Map;` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;

  #L32cfac.  v0:= new `java.util.HashMap`;
  #L32cfb0.  call `<init>`(v0) @signature `Ljava/util/HashMap;.<init>:()V` @kind direct;
  #L32cfb6.  v1:= `@@java.lang.Boolean.TRUE` @type ^`java.lang.Boolean` @kind object;
  #L32cfba.  v2:= "enabled" @kind object;
  #L32cfbe.  call temp:= `put`(v0, v2, v1) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L32cfc4.  v1:= "data" @kind object;
  #L32cfc8.  call temp:= `put`(v0, v1, v4) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L32cfce.  return v0 @kind object;
}
procedure `void` `g`(`ga.l` v1 @kind this) @signature `Lga/l;.g:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L32d04c.  v0:= 0I;
  #L32d04e.  v1.`ga.l.b` @type ^`byte`[] := v0 @kind object;
  #L32d052.  return @kind void;
}
procedure `byte`[] `h`(`ga.l` v1 @kind this) @signature `Lga/l;.h:()[B` @AccessFlag PUBLIC {
    temp;
    v0;

  #L32cf60.  v0:= v1.`ga.l.b` @type ^`byte`[] @kind object;
  #L32cf64.  return v0 @kind object;
}
procedure `void` `j`(`ga.l` v3 @kind this, `byte`[] v4 @kind object) @signature `Lga/l;.j:([B)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L32d064.  v0:= 1I;
  #L32d066.  v3.`ga.l.e` @type ^`boolean` := v0 @kind boolean;
  #L32d06a.  v0:= v3.`ga.l.d` @type ^`ha.k$d` @kind object;
  #L32d06e.  if v0 == 0 then goto L32d08c;
  #L32d072.  call temp:= `i`(v3, v4) @signature `Lga/l;.i:([B)Ljava/util/Map;` @kind direct;
  #L32d078.  v1:= temp @kind object;
  #L32d07a.  call `a`(v0, v1) @signature `Lha/k$d;.a:(Ljava/lang/Object;)V` @kind interface;
  #L32d080.  v0:= 0I;
  #L32d082.  v3.`ga.l.d` @type ^`ha.k$d` := v0 @kind object;
  #L32d086.  v3.`ga.l.b` @type ^`byte`[] := v4 @kind object;
  #L32d08a.  goto L32d0b4;
  #L32d08c.  v0:= v3.`ga.l.f` @type ^`boolean` @kind boolean;
  #L32d090.  if v0 == 0 then goto L32d086;
  #L32d094.  v0:= v3.`ga.l.c` @type ^`ha.k` @kind object;
  #L32d098.  call temp:= `i`(v3, v4) @signature `Lga/l;.i:([B)Ljava/util/Map;` @kind direct;
  #L32d09e.  v1:= temp @kind object;
  #L32d0a0.  v2:= new `ga.l$a`;
  #L32d0a4.  call `<init>`(v2, v3, v4) @signature `Lga/l$a;.<init>:(Lga/l;[B)V` @kind direct;
  #L32d0aa.  v4:= "push" @kind object;
  #L32d0ae.  call `d`(v0, v4, v1, v2) @signature `Lha/k;.d:(Ljava/lang/String;Ljava/lang/Object;Lha/k$d;)V` @kind virtual;
  #L32d0b4.  return @kind void;
}

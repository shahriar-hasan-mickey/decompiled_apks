record `b7.a$a` @kind class @AccessFlag  {
  `java.lang.Class` `b7.a$a.a` @AccessFlag PRIVATE_FINAL;
  `java.util.Map` `b7.a$a.b` @AccessFlag PRIVATE_FINAL;
  `java.util.Map` `b7.a$a.c` @AccessFlag PRIVATE_FINAL;
  `java.util.Map` `b7.a$a.d` @AccessFlag PRIVATE_FINAL;
  `java.util.Map` `b7.a$a.e` @AccessFlag PRIVATE_FINAL;
}
procedure `void` `<init>`(`b7.a$a` v10 @kind this, `java.lang.Class` v11 @kind object) @signature `Lb7/a$a;.<init>:(Ljava/lang/Class;)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L1f1e74.  call `<init>`(v10) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L1f1e7a.  v10.`b7.a$a.a` @type ^`java.lang.Class` := v11 @kind object;
  #L1f1e7e.  v0:= constclass @type ^`s6.h` @kind object;
  #L1f1e82.  call temp:= `isAnnotationPresent`(v11, v0) @signature `Ljava/lang/Class;.isAnnotationPresent:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1e88.  v0:= constclass @type ^`s6.f` @kind object;
  #L1f1e8c.  call temp:= `isAnnotationPresent`(v11, v0) @signature `Ljava/lang/Class;.isAnnotationPresent:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1e92.  v0:= new `java.util.HashMap`;
  #L1f1e96.  call `<init>`(v0) @signature `Ljava/util/HashMap;.<init>:()V` @kind direct;
  #L1f1e9c.  v10.`b7.a$a.b` @type ^`java.util.Map` := v0 @kind object;
  #L1f1ea0.  v0:= new `java.util.HashMap`;
  #L1f1ea4.  call `<init>`(v0) @signature `Ljava/util/HashMap;.<init>:()V` @kind direct;
  #L1f1eaa.  v10.`b7.a$a.d` @type ^`java.util.Map` := v0 @kind object;
  #L1f1eae.  v0:= new `java.util.HashMap`;
  #L1f1eb2.  call `<init>`(v0) @signature `Ljava/util/HashMap;.<init>:()V` @kind direct;
  #L1f1eb8.  v10.`b7.a$a.c` @type ^`java.util.Map` := v0 @kind object;
  #L1f1ebc.  v0:= new `java.util.HashMap`;
  #L1f1ec0.  call `<init>`(v0) @signature `Ljava/util/HashMap;.<init>:()V` @kind direct;
  #L1f1ec6.  v10.`b7.a$a.e` @type ^`java.util.Map` := v0 @kind object;
  #L1f1eca.  v0:= 0I;
  #L1f1ecc.  v1:= 1I;
  #L1f1ece.  v2:= new `java.lang.Class`[v0];
  #L1f1ed2.  call temp:= `getDeclaredConstructor`(v11, v2) @signature `Ljava/lang/Class;.getDeclaredConstructor:([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;` @kind virtual;
  #L1f1ed8.  v2:= temp @kind object;
  #L1f1eda.  call `setAccessible`(v2, v1) @signature `Ljava/lang/reflect/Constructor;.setAccessible:(Z)V` @kind virtual;
  #L1f1ee0.  call temp:= `getMethods`(v11) @signature `Ljava/lang/Class;.getMethods:()[Ljava/lang/reflect/Method;` @kind virtual;
  #L1f1ee6.  v2:= temp @kind object;
  #L1f1ee8.  v3:= length @variable v2;
  #L1f1eea.  v4:= 0I;
  #L1f1eec.  if v4 >= v3 then goto L1f1f6c;
  #L1f1ef0.  v5:= v2[v4] @kind object;
  #L1f1ef4.  call temp:= `i`(v5) @signature `Lb7/a$a;.i:(Ljava/lang/reflect/Method;)Z` @kind static;
  #L1f1efa.  v6:= temp;
  #L1f1efc.  if v6 == 0 then goto L1f1f66;
  #L1f1f00.  call temp:= `e`(v5) @signature `Lb7/a$a;.e:(Ljava/lang/reflect/Method;)Ljava/lang/String;` @kind static;
  #L1f1f06.  v6:= temp @kind object;
  #L1f1f08.  call `a`(v10, v6) @signature `Lb7/a$a;.a:(Ljava/lang/String;)V` @kind direct;
  #L1f1f0e.  call `setAccessible`(v5, v1) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L1f1f14.  v7:= v10.`b7.a$a.c` @type ^`java.util.Map` @kind object;
  #L1f1f18.  call temp:= `containsKey`(v7, v6) @signature `Ljava/util/Map;.containsKey:(Ljava/lang/Object;)Z` @kind interface;
  #L1f1f1e.  v7:= temp;
  #L1f1f20.  if v7 != 0 then goto L1f1f30;
  #L1f1f24.  v7:= v10.`b7.a$a.c` @type ^`java.util.Map` @kind object;
  #L1f1f28.  call temp:= `put`(v7, v6, v5) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f1f2e.  goto L1f1f66;
  #L1f1f30.  v11:= new `s6.c`;
  #L1f1f34.  v0:= new `java.lang.StringBuilder`;
  #L1f1f38.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f1f3e.  v1:= "Found conflicting getters for name: " @kind object;
  #L1f1f42.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1f48.  call temp:= `getName`(v5) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1f4e.  v1:= temp @kind object;
  #L1f1f50.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1f56.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f1f5c.  v0:= temp @kind object;
  #L1f1f5e.  call `<init>`(v11, v0) @signature `Ls6/c;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f1f64.  throw v11;
  #L1f1f66.  v4:= v4 + 1;
  #L1f1f6a.  goto L1f1eec;
  #L1f1f6c.  call temp:= `getFields`(v11) @signature `Ljava/lang/Class;.getFields:()[Ljava/lang/reflect/Field;` @kind virtual;
  #L1f1f72.  v2:= temp @kind object;
  #L1f1f74.  v3:= length @variable v2;
  #L1f1f76.  v4:= 0I;
  #L1f1f78.  if v4 >= v3 then goto L1f1fa0;
  #L1f1f7c.  v5:= v2[v4] @kind object;
  #L1f1f80.  call temp:= `h`(v5) @signature `Lb7/a$a;.h:(Ljava/lang/reflect/Field;)Z` @kind static;
  #L1f1f86.  v6:= temp;
  #L1f1f88.  if v6 == 0 then goto L1f1f9a;
  #L1f1f8c.  call temp:= `d`(v5) @signature `Lb7/a$a;.d:(Ljava/lang/reflect/Field;)Ljava/lang/String;` @kind static;
  #L1f1f92.  v5:= temp @kind object;
  #L1f1f94.  call `a`(v10, v5) @signature `Lb7/a$a;.a:(Ljava/lang/String;)V` @kind direct;
  #L1f1f9a.  v4:= v4 + 1;
  #L1f1f9e.  goto L1f1f78;
  #L1f1fa0.  v2:= v11 @kind object;
  #L1f1fa2.  call temp:= `getDeclaredMethods`(v2) @signature `Ljava/lang/Class;.getDeclaredMethods:()[Ljava/lang/reflect/Method;` @kind virtual;
  #L1f1fa8.  v3:= temp @kind object;
  #L1f1faa.  v4:= length @variable v3;
  #L1f1fac.  v5:= 0I;
  #L1f1fae.  if v5 >= v4 then goto L1f20e0;
  #L1f1fb2.  v6:= v3[v5] @kind object;
  #L1f1fb6.  call temp:= `j`(v6) @signature `Lb7/a$a;.j:(Ljava/lang/reflect/Method;)Z` @kind static;
  #L1f1fbc.  v7:= temp;
  #L1f1fbe.  if v7 == 0 then goto L1f20d8;
  #L1f1fc2.  call temp:= `e`(v6) @signature `Lb7/a$a;.e:(Ljava/lang/reflect/Method;)Ljava/lang/String;` @kind static;
  #L1f1fc8.  v7:= temp @kind object;
  #L1f1fca.  v8:= v10.`b7.a$a.b` @type ^`java.util.Map` @kind object;
  #L1f1fce.  v9:= `@@java.util.Locale.US` @type ^`java.util.Locale` @kind object;
  #L1f1fd2.  call temp:= `toLowerCase`(v7, v9) @signature `Ljava/lang/String;.toLowerCase:(Ljava/util/Locale;)Ljava/lang/String;` @kind virtual;
  #L1f1fd8.  v9:= temp @kind object;
  #L1f1fda.  call temp:= `get`(v8, v9) @signature `Ljava/util/Map;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f1fe0.  v8:= temp @kind object;
  #L1f1fe2.  v8:= (`java.lang.String`) v8 @kind object;
  #L1f1fe6.  if v8 == 0 then goto L1f20d8;
  #L1f1fea.  call temp:= `equals`(v8, v7) @signature `Ljava/lang/String;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1ff0.  v8:= temp;
  #L1f1ff2.  if v8 == 0 then goto L1f20a2;
  #L1f1ff6.  v8:= v10.`b7.a$a.d` @type ^`java.util.Map` @kind object;
  #L1f1ffa.  call temp:= `get`(v8, v7) @signature `Ljava/util/Map;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f2000.  v8:= temp @kind object;
  #L1f2002.  v8:= (`java.lang.reflect.Method`) v8 @kind object;
  #L1f2006.  if v8 != 0 then goto L1f201c;
  #L1f200a.  call `setAccessible`(v6, v1) @signature `Ljava/lang/reflect/Method;.setAccessible:(Z)V` @kind virtual;
  #L1f2010.  v8:= v10.`b7.a$a.d` @type ^`java.util.Map` @kind object;
  #L1f2014.  call temp:= `put`(v8, v7, v6) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f201a.  goto L1f20d8;
  #L1f201c.  call temp:= `c`(v6, v8) @signature `Lb7/a$a;.c:(Ljava/lang/reflect/Method;Ljava/lang/reflect/Method;)Z` @kind static;
  #L1f2022.  v7:= temp;
  #L1f2024.  if v7 == 0 then goto L1f202a;
  #L1f2028.  goto L1f20d8;
  #L1f202a.  v11:= new `s6.c`;
  #L1f202e.  v0:= new `java.lang.StringBuilder`;
  #L1f2032.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f2038.  v1:= "Found a conflicting setters with name: " @kind object;
  #L1f203c.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2042.  call temp:= `getName`(v6) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f2048.  v1:= temp @kind object;
  #L1f204a.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2050.  v1:= " (conflicts with " @kind object;
  #L1f2054.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f205a.  call temp:= `getName`(v8) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f2060.  v1:= temp @kind object;
  #L1f2062.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2068.  v1:= " defined on " @kind object;
  #L1f206c.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2072.  call temp:= `getDeclaringClass`(v8) @signature `Ljava/lang/reflect/Method;.getDeclaringClass:()Ljava/lang/Class;` @kind virtual;
  #L1f2078.  v1:= temp @kind object;
  #L1f207a.  call temp:= `getName`(v1) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f2080.  v1:= temp @kind object;
  #L1f2082.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2088.  v1:= ")" @kind object;
  #L1f208c.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2092.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f2098.  v0:= temp @kind object;
  #L1f209a.  call `<init>`(v11, v0) @signature `Ls6/c;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f20a0.  throw v11;
  #L1f20a2.  v11:= new `s6.c`;
  #L1f20a6.  v0:= new `java.lang.StringBuilder`;
  #L1f20aa.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f20b0.  v1:= "Found setter with invalid case-sensitive name: " @kind object;
  #L1f20b4.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f20ba.  call temp:= `getName`(v6) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f20c0.  v1:= temp @kind object;
  #L1f20c2.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f20c8.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f20ce.  v0:= temp @kind object;
  #L1f20d0.  call `<init>`(v11, v0) @signature `Ls6/c;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f20d6.  throw v11;
  #L1f20d8.  v5:= v5 + 1;
  #L1f20dc.  goto L1f1fae;
  #L1f20e0.  call temp:= `getDeclaredFields`(v2) @signature `Ljava/lang/Class;.getDeclaredFields:()[Ljava/lang/reflect/Field;` @kind virtual;
  #L1f20e6.  v3:= temp @kind object;
  #L1f20e8.  v4:= length @variable v3;
  #L1f20ea.  v5:= 0I;
  #L1f20ec.  if v5 >= v4 then goto L1f213e;
  #L1f20f0.  v6:= v3[v5] @kind object;
  #L1f20f4.  call temp:= `d`(v6) @signature `Lb7/a$a;.d:(Ljava/lang/reflect/Field;)Ljava/lang/String;` @kind static;
  #L1f20fa.  v7:= temp @kind object;
  #L1f20fc.  v8:= v10.`b7.a$a.b` @type ^`java.util.Map` @kind object;
  #L1f2100.  v9:= `@@java.util.Locale.US` @type ^`java.util.Locale` @kind object;
  #L1f2104.  call temp:= `toLowerCase`(v7, v9) @signature `Ljava/lang/String;.toLowerCase:(Ljava/util/Locale;)Ljava/lang/String;` @kind virtual;
  #L1f210a.  v9:= temp @kind object;
  #L1f210c.  call temp:= `containsKey`(v8, v9) @signature `Ljava/util/Map;.containsKey:(Ljava/lang/Object;)Z` @kind interface;
  #L1f2112.  v8:= temp;
  #L1f2114.  if v8 == 0 then goto L1f2138;
  #L1f2118.  v8:= v10.`b7.a$a.e` @type ^`java.util.Map` @kind object;
  #L1f211c.  call temp:= `containsKey`(v8, v7) @signature `Ljava/util/Map;.containsKey:(Ljava/lang/Object;)Z` @kind interface;
  #L1f2122.  v8:= temp;
  #L1f2124.  if v8 != 0 then goto L1f2138;
  #L1f2128.  call `setAccessible`(v6, v1) @signature `Ljava/lang/reflect/Field;.setAccessible:(Z)V` @kind virtual;
  #L1f212e.  v8:= v10.`b7.a$a.e` @type ^`java.util.Map` @kind object;
  #L1f2132.  call temp:= `put`(v8, v7, v6) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f2138.  v5:= v5 + 1;
  #L1f213c.  goto L1f20ec;
  #L1f213e.  call temp:= `getSuperclass`(v2) @signature `Ljava/lang/Class;.getSuperclass:()Ljava/lang/Class;` @kind virtual;
  #L1f2144.  v2:= temp @kind object;
  #L1f2146.  if v2 == 0 then goto L1f215a;
  #L1f214a.  v3:= constclass @type ^`java.lang.Object` @kind object;
  #L1f214e.  call temp:= `equals`(v2, v3) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f2154.  v3:= temp;
  #L1f2156.  if v3 == 0 then goto L1f1fa2;
  #L1f215a.  v0:= v10.`b7.a$a.b` @type ^`java.util.Map` @kind object;
  #L1f215e.  call temp:= `isEmpty`(v0) @signature `Ljava/util/Map;.isEmpty:()Z` @kind interface;
  #L1f2164.  v0:= temp;
  #L1f2166.  if v0 != 0 then goto L1f216c;
  #L1f216a.  return @kind void;
  #L1f216c.  v0:= new `s6.c`;
  #L1f2170.  v1:= new `java.lang.StringBuilder`;
  #L1f2174.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f217a.  v2:= "No properties to serialize found on class " @kind object;
  #L1f217e.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2184.  call temp:= `getName`(v11) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f218a.  v11:= temp @kind object;
  #L1f218c.  call temp:= `append`(v1, v11) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2192.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f2198.  v11:= temp @kind object;
  #L1f219a.  call `<init>`(v0, v11) @signature `Ls6/c;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f21a0.  throw v0;
  catch `java.lang.NoSuchMethodException` @[L1f1ece..L1f1ee0] goto L1f1ee0;
}
procedure `void` `a`(`b7.a$a` v4 @kind this, `java.lang.String` v5 @kind object) @signature `Lb7/a$a;.a:(Ljava/lang/String;)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1f21c4.  v0:= v4.`b7.a$a.b` @type ^`java.util.Map` @kind object;
  #L1f21c8.  v1:= `@@java.util.Locale.US` @type ^`java.util.Locale` @kind object;
  #L1f21cc.  call temp:= `toLowerCase`(v5, v1) @signature `Ljava/lang/String;.toLowerCase:(Ljava/util/Locale;)Ljava/lang/String;` @kind virtual;
  #L1f21d2.  v2:= temp @kind object;
  #L1f21d4.  call temp:= `put`(v0, v2, v5) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f21da.  v0:= temp @kind object;
  #L1f21dc.  v0:= (`java.lang.String`) v0 @kind object;
  #L1f21e0.  if v0 == 0 then goto L1f2228;
  #L1f21e4.  call temp:= `equals`(v5, v0) @signature `Ljava/lang/String;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f21ea.  v0:= temp;
  #L1f21ec.  if v0 == 0 then goto L1f21f2;
  #L1f21f0.  goto L1f2228;
  #L1f21f2.  v0:= new `s6.c`;
  #L1f21f6.  v2:= new `java.lang.StringBuilder`;
  #L1f21fa.  call `<init>`(v2) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f2200.  v3:= "Found two getters or fields with conflicting case sensitivity for property: " @kind object;
  #L1f2204.  call temp:= `append`(v2, v3) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f220a.  call temp:= `toLowerCase`(v5, v1) @signature `Ljava/lang/String;.toLowerCase:(Ljava/util/Locale;)Ljava/lang/String;` @kind virtual;
  #L1f2210.  v5:= temp @kind object;
  #L1f2212.  call temp:= `append`(v2, v5) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f2218.  call temp:= `toString`(v2) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f221e.  v5:= temp @kind object;
  #L1f2220.  call `<init>`(v0, v5) @signature `Ls6/c;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f2226.  throw v0;
  #L1f2228.  return @kind void;
}
procedure `java.lang.String` `b`(`java.lang.reflect.AccessibleObject` v1 @kind object) @signature `Lb7/a$a;.b:(Ljava/lang/reflect/AccessibleObject;)Ljava/lang/String;` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1f1b94.  v0:= constclass @type ^`s6.g` @kind object;
  #L1f1b98.  call temp:= `isAnnotationPresent`(v1, v0) @signature `Ljava/lang/reflect/AccessibleObject;.isAnnotationPresent:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1b9e.  v0:= temp;
  #L1f1ba0.  if v0 == 0 then goto L1f1bbe;
  #L1f1ba4.  v0:= constclass @type ^`s6.g` @kind object;
  #L1f1ba8.  call temp:= `getAnnotation`(v1, v0) @signature `Ljava/lang/reflect/AccessibleObject;.getAnnotation:(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;` @kind virtual;
  #L1f1bae.  v1:= temp @kind object;
  #L1f1bb0.  v1:= (`s6.g`) v1 @kind object;
  #L1f1bb4.  call temp:= `value`(v1) @signature `Ls6/g;.value:()Ljava/lang/String;` @kind interface;
  #L1f1bba.  v1:= temp @kind object;
  #L1f1bbc.  return v1 @kind object;
  #L1f1bbe.  v1:= 0I;
  #L1f1bc0.  return v1 @kind object;
}
procedure `boolean` `c`(`java.lang.reflect.Method` v6 @kind object, `java.lang.reflect.Method` v7 @kind object) @signature `Lb7/a$a;.c:(Ljava/lang/reflect/Method;Ljava/lang/reflect/Method;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L1f18cc.  call temp:= `getDeclaringClass`(v6) @signature `Ljava/lang/reflect/Method;.getDeclaringClass:()Ljava/lang/Class;` @kind virtual;
  #L1f18d2.  v0:= temp @kind object;
  #L1f18d4.  call temp:= `getDeclaringClass`(v7) @signature `Ljava/lang/reflect/Method;.getDeclaringClass:()Ljava/lang/Class;` @kind virtual;
  #L1f18da.  v1:= temp @kind object;
  #L1f18dc.  call temp:= `isAssignableFrom`(v0, v1) @signature `Ljava/lang/Class;.isAssignableFrom:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f18e2.  v0:= temp;
  #L1f18e4.  v1:= "Expected override from a base class" @kind object;
  #L1f18e8.  call `g`(v0, v1) @signature `La7/m;.g:(ZLjava/lang/String;)V` @kind static;
  #L1f18ee.  call temp:= `getReturnType`(v6) @signature `Ljava/lang/reflect/Method;.getReturnType:()Ljava/lang/Class;` @kind virtual;
  #L1f18f4.  v0:= temp @kind object;
  #L1f18f6.  v1:= `@@java.lang.Void.TYPE` @type ^`java.lang.Class` @kind object;
  #L1f18fa.  call temp:= `equals`(v0, v1) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1900.  v0:= temp;
  #L1f1902.  v1:= "Expected void return type" @kind object;
  #L1f1906.  call `g`(v0, v1) @signature `La7/m;.g:(ZLjava/lang/String;)V` @kind static;
  #L1f190c.  call temp:= `getReturnType`(v7) @signature `Ljava/lang/reflect/Method;.getReturnType:()Ljava/lang/Class;` @kind virtual;
  #L1f1912.  v0:= temp @kind object;
  #L1f1914.  v2:= `@@java.lang.Void.TYPE` @type ^`java.lang.Class` @kind object;
  #L1f1918.  call temp:= `equals`(v0, v2) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f191e.  v0:= temp;
  #L1f1920.  call `g`(v0, v1) @signature `La7/m;.g:(ZLjava/lang/String;)V` @kind static;
  #L1f1926.  call temp:= `getParameterTypes`(v6) @signature `Ljava/lang/reflect/Method;.getParameterTypes:()[Ljava/lang/Class;` @kind virtual;
  #L1f192c.  v0:= temp @kind object;
  #L1f192e.  call temp:= `getParameterTypes`(v7) @signature `Ljava/lang/reflect/Method;.getParameterTypes:()[Ljava/lang/Class;` @kind virtual;
  #L1f1934.  v1:= temp @kind object;
  #L1f1936.  v2:= length @variable v0;
  #L1f1938.  v3:= 0I;
  #L1f193a.  v4:= 1I;
  #L1f193c.  if v2 != v4 then goto L1f1944;
  #L1f1940.  v2:= 1I;
  #L1f1942.  goto L1f1946;
  #L1f1944.  v2:= 0I;
  #L1f1946.  v5:= "Expected exactly one parameter" @kind object;
  #L1f194a.  call `g`(v2, v5) @signature `La7/m;.g:(ZLjava/lang/String;)V` @kind static;
  #L1f1950.  v2:= length @variable v1;
  #L1f1952.  if v2 != v4 then goto L1f195a;
  #L1f1956.  v2:= 1I;
  #L1f1958.  goto L1f195c;
  #L1f195a.  v2:= 0I;
  #L1f195c.  call `g`(v2, v5) @signature `La7/m;.g:(ZLjava/lang/String;)V` @kind static;
  #L1f1962.  call temp:= `getName`(v6) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1968.  v6:= temp @kind object;
  #L1f196a.  call temp:= `getName`(v7) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1970.  v7:= temp @kind object;
  #L1f1972.  call temp:= `equals`(v6, v7) @signature `Ljava/lang/String;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1978.  v6:= temp;
  #L1f197a.  if v6 == 0 then goto L1f1994;
  #L1f197e.  v6:= v0[v3] @kind object;
  #L1f1982.  v7:= v1[v3] @kind object;
  #L1f1986.  call temp:= `equals`(v6, v7) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f198c.  v6:= temp;
  #L1f198e.  if v6 == 0 then goto L1f1994;
  #L1f1992.  v3:= 1I;
  #L1f1994.  return v3;
}
procedure `java.lang.String` `d`(`java.lang.reflect.Field` v1 @kind object) @signature `Lb7/a$a;.d:(Ljava/lang/reflect/Field;)Ljava/lang/String;` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1f1bd4.  call temp:= `b`(v1) @signature `Lb7/a$a;.b:(Ljava/lang/reflect/AccessibleObject;)Ljava/lang/String;` @kind static;
  #L1f1bda.  v0:= temp @kind object;
  #L1f1bdc.  if v0 == 0 then goto L1f1be2;
  #L1f1be0.  goto L1f1bea;
  #L1f1be2.  call temp:= `getName`(v1) @signature `Ljava/lang/reflect/Field;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1be8.  v0:= temp @kind object;
  #L1f1bea.  return v0 @kind object;
}
procedure `java.lang.String` `e`(`java.lang.reflect.Method` v1 @kind object) @signature `Lb7/a$a;.e:(Ljava/lang/reflect/Method;)Ljava/lang/String;` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1f1bfc.  call temp:= `b`(v1) @signature `Lb7/a$a;.b:(Ljava/lang/reflect/AccessibleObject;)Ljava/lang/String;` @kind static;
  #L1f1c02.  v0:= temp @kind object;
  #L1f1c04.  if v0 == 0 then goto L1f1c0a;
  #L1f1c08.  goto L1f1c1a;
  #L1f1c0a.  call temp:= `getName`(v1) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1c10.  v1:= temp @kind object;
  #L1f1c12.  call temp:= `g`(v1) @signature `Lb7/a$a;.g:(Ljava/lang/String;)Ljava/lang/String;` @kind static;
  #L1f1c18.  v0:= temp @kind object;
  #L1f1c1a.  return v0 @kind object;
}
procedure `java.lang.String` `g`(`java.lang.String` v6 @kind object) @signature `Lb7/a$a;.g:(Ljava/lang/String;)Ljava/lang/String;` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L1f1c2c.  v0:= "get" @kind object;
  #L1f1c30.  v1:= "set" @kind object;
  #L1f1c34.  v2:= "is" @kind object;
  #L1f1c38.  temp:= new `java.lang.String`[v0, v1, v2];
  #L1f1c3e.  v0:= temp @kind object;
  #L1f1c40.  v1:= 0I;
  #L1f1c42.  v2:= 0I;
  #L1f1c44.  v3:= 0I;
  #L1f1c46.  v4:= 3I;
  #L1f1c48.  if v3 >= v4 then goto L1f1c64;
  #L1f1c4c.  v4:= v0[v3] @kind object;
  #L1f1c50.  call temp:= `startsWith`(v6, v4) @signature `Ljava/lang/String;.startsWith:(Ljava/lang/String;)Z` @kind virtual;
  #L1f1c56.  v5:= temp;
  #L1f1c58.  if v5 == 0 then goto L1f1c5e;
  #L1f1c5c.  v2:= v4 @kind object;
  #L1f1c5e.  v3:= v3 + 1;
  #L1f1c62.  goto L1f1c46;
  #L1f1c64.  if v2 == 0 then goto L1f1cb8;
  #L1f1c68.  call temp:= `length`(v2) @signature `Ljava/lang/String;.length:()I` @kind virtual;
  #L1f1c6e.  v0:= temp;
  #L1f1c70.  call temp:= `substring`(v6, v0) @signature `Ljava/lang/String;.substring:(I)Ljava/lang/String;` @kind virtual;
  #L1f1c76.  v6:= temp @kind object;
  #L1f1c78.  call temp:= `toCharArray`(v6) @signature `Ljava/lang/String;.toCharArray:()[C` @kind virtual;
  #L1f1c7e.  v6:= temp @kind object;
  #L1f1c80.  v0:= length @variable v6;
  #L1f1c82.  if v1 >= v0 then goto L1f1cac;
  #L1f1c86.  v0:= v6[v1] @kind char;
  #L1f1c8a.  call temp:= `isUpperCase`(v0) @signature `Ljava/lang/Character;.isUpperCase:(C)Z` @kind static;
  #L1f1c90.  v0:= temp;
  #L1f1c92.  if v0 == 0 then goto L1f1cac;
  #L1f1c96.  v0:= v6[v1] @kind char;
  #L1f1c9a.  call temp:= `toLowerCase`(v0) @signature `Ljava/lang/Character;.toLowerCase:(C)C` @kind static;
  #L1f1ca0.  v0:= temp;
  #L1f1ca2.  v6[v1]:= v0 @kind char;
  #L1f1ca6.  v1:= v1 + 1;
  #L1f1caa.  goto L1f1c80;
  #L1f1cac.  v0:= new `java.lang.String`;
  #L1f1cb0.  call `<init>`(v0, v6) @signature `Ljava/lang/String;.<init>:([C)V` @kind direct;
  #L1f1cb6.  return v0 @kind object;
  #L1f1cb8.  v0:= new `java.lang.IllegalArgumentException`;
  #L1f1cbc.  v1:= new `java.lang.StringBuilder`;
  #L1f1cc0.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f1cc6.  v2:= "Unknown Bean prefix for method: " @kind object;
  #L1f1cca.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1cd0.  call temp:= `append`(v1, v6) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1cd6.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f1cdc.  v6:= temp @kind object;
  #L1f1cde.  call `<init>`(v0, v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f1ce4.  throw v0;
}
procedure `boolean` `h`(`java.lang.reflect.Field` v2 @kind object) @signature `Lb7/a$a;.h:(Ljava/lang/reflect/Field;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L1f19a8.  call temp:= `getDeclaringClass`(v2) @signature `Ljava/lang/reflect/Field;.getDeclaringClass:()Ljava/lang/Class;` @kind virtual;
  #L1f19ae.  v0:= temp @kind object;
  #L1f19b0.  v1:= constclass @type ^`java.lang.Object` @kind object;
  #L1f19b4.  call temp:= `equals`(v0, v1) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f19ba.  v0:= temp;
  #L1f19bc.  v1:= 0I;
  #L1f19be.  if v0 == 0 then goto L1f19c4;
  #L1f19c2.  return v1;
  #L1f19c4.  call temp:= `getModifiers`(v2) @signature `Ljava/lang/reflect/Field;.getModifiers:()I` @kind virtual;
  #L1f19ca.  v0:= temp;
  #L1f19cc.  call temp:= `isPublic`(v0) @signature `Ljava/lang/reflect/Modifier;.isPublic:(I)Z` @kind static;
  #L1f19d2.  v0:= temp;
  #L1f19d4.  if v0 != 0 then goto L1f19da;
  #L1f19d8.  return v1;
  #L1f19da.  call temp:= `getModifiers`(v2) @signature `Ljava/lang/reflect/Field;.getModifiers:()I` @kind virtual;
  #L1f19e0.  v0:= temp;
  #L1f19e2.  call temp:= `isStatic`(v0) @signature `Ljava/lang/reflect/Modifier;.isStatic:(I)Z` @kind static;
  #L1f19e8.  v0:= temp;
  #L1f19ea.  if v0 == 0 then goto L1f19f0;
  #L1f19ee.  return v1;
  #L1f19f0.  call temp:= `getModifiers`(v2) @signature `Ljava/lang/reflect/Field;.getModifiers:()I` @kind virtual;
  #L1f19f6.  v0:= temp;
  #L1f19f8.  call temp:= `isTransient`(v0) @signature `Ljava/lang/reflect/Modifier;.isTransient:(I)Z` @kind static;
  #L1f19fe.  v0:= temp;
  #L1f1a00.  if v0 == 0 then goto L1f1a06;
  #L1f1a04.  return v1;
  #L1f1a06.  v0:= constclass @type ^`s6.e` @kind object;
  #L1f1a0a.  call temp:= `isAnnotationPresent`(v2, v0) @signature `Ljava/lang/reflect/Field;.isAnnotationPresent:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1a10.  v2:= temp;
  #L1f1a12.  if v2 == 0 then goto L1f1a18;
  #L1f1a16.  return v1;
  #L1f1a18.  v2:= 1I;
  #L1f1a1a.  return v2;
}
procedure `boolean` `i`(`java.lang.reflect.Method` v3 @kind object) @signature `Lb7/a$a;.i:(Ljava/lang/reflect/Method;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L1f1a2c.  call temp:= `getName`(v3) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1a32.  v0:= temp @kind object;
  #L1f1a34.  v1:= "get" @kind object;
  #L1f1a38.  call temp:= `startsWith`(v0, v1) @signature `Ljava/lang/String;.startsWith:(Ljava/lang/String;)Z` @kind virtual;
  #L1f1a3e.  v0:= temp;
  #L1f1a40.  v1:= 0I;
  #L1f1a42.  if v0 != 0 then goto L1f1a60;
  #L1f1a46.  call temp:= `getName`(v3) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1a4c.  v0:= temp @kind object;
  #L1f1a4e.  v2:= "is" @kind object;
  #L1f1a52.  call temp:= `startsWith`(v0, v2) @signature `Ljava/lang/String;.startsWith:(Ljava/lang/String;)Z` @kind virtual;
  #L1f1a58.  v0:= temp;
  #L1f1a5a.  if v0 != 0 then goto L1f1a60;
  #L1f1a5e.  return v1;
  #L1f1a60.  call temp:= `getDeclaringClass`(v3) @signature `Ljava/lang/reflect/Method;.getDeclaringClass:()Ljava/lang/Class;` @kind virtual;
  #L1f1a66.  v0:= temp @kind object;
  #L1f1a68.  v2:= constclass @type ^`java.lang.Object` @kind object;
  #L1f1a6c.  call temp:= `equals`(v0, v2) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1a72.  v0:= temp;
  #L1f1a74.  if v0 == 0 then goto L1f1a7a;
  #L1f1a78.  return v1;
  #L1f1a7a.  call temp:= `getModifiers`(v3) @signature `Ljava/lang/reflect/Method;.getModifiers:()I` @kind virtual;
  #L1f1a80.  v0:= temp;
  #L1f1a82.  call temp:= `isPublic`(v0) @signature `Ljava/lang/reflect/Modifier;.isPublic:(I)Z` @kind static;
  #L1f1a88.  v0:= temp;
  #L1f1a8a.  if v0 != 0 then goto L1f1a90;
  #L1f1a8e.  return v1;
  #L1f1a90.  call temp:= `getModifiers`(v3) @signature `Ljava/lang/reflect/Method;.getModifiers:()I` @kind virtual;
  #L1f1a96.  v0:= temp;
  #L1f1a98.  call temp:= `isStatic`(v0) @signature `Ljava/lang/reflect/Modifier;.isStatic:(I)Z` @kind static;
  #L1f1a9e.  v0:= temp;
  #L1f1aa0.  if v0 == 0 then goto L1f1aa6;
  #L1f1aa4.  return v1;
  #L1f1aa6.  call temp:= `getReturnType`(v3) @signature `Ljava/lang/reflect/Method;.getReturnType:()Ljava/lang/Class;` @kind virtual;
  #L1f1aac.  v0:= temp @kind object;
  #L1f1aae.  v2:= `@@java.lang.Void.TYPE` @type ^`java.lang.Class` @kind object;
  #L1f1ab2.  call temp:= `equals`(v0, v2) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1ab8.  v0:= temp;
  #L1f1aba.  if v0 == 0 then goto L1f1ac0;
  #L1f1abe.  return v1;
  #L1f1ac0.  call temp:= `getParameterTypes`(v3) @signature `Ljava/lang/reflect/Method;.getParameterTypes:()[Ljava/lang/Class;` @kind virtual;
  #L1f1ac6.  v0:= temp @kind object;
  #L1f1ac8.  v0:= length @variable v0;
  #L1f1aca.  if v0 == 0 then goto L1f1ad0;
  #L1f1ace.  return v1;
  #L1f1ad0.  v0:= constclass @type ^`s6.e` @kind object;
  #L1f1ad4.  call temp:= `isAnnotationPresent`(v3, v0) @signature `Ljava/lang/reflect/Method;.isAnnotationPresent:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1ada.  v3:= temp;
  #L1f1adc.  if v3 == 0 then goto L1f1ae2;
  #L1f1ae0.  return v1;
  #L1f1ae2.  v3:= 1I;
  #L1f1ae4.  return v3;
}
procedure `boolean` `j`(`java.lang.reflect.Method` v3 @kind object) @signature `Lb7/a$a;.j:(Ljava/lang/reflect/Method;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L1f1af8.  call temp:= `getName`(v3) @signature `Ljava/lang/reflect/Method;.getName:()Ljava/lang/String;` @kind virtual;
  #L1f1afe.  v0:= temp @kind object;
  #L1f1b00.  v1:= "set" @kind object;
  #L1f1b04.  call temp:= `startsWith`(v0, v1) @signature `Ljava/lang/String;.startsWith:(Ljava/lang/String;)Z` @kind virtual;
  #L1f1b0a.  v0:= temp;
  #L1f1b0c.  v1:= 0I;
  #L1f1b0e.  if v0 != 0 then goto L1f1b14;
  #L1f1b12.  return v1;
  #L1f1b14.  call temp:= `getDeclaringClass`(v3) @signature `Ljava/lang/reflect/Method;.getDeclaringClass:()Ljava/lang/Class;` @kind virtual;
  #L1f1b1a.  v0:= temp @kind object;
  #L1f1b1c.  v2:= constclass @type ^`java.lang.Object` @kind object;
  #L1f1b20.  call temp:= `equals`(v0, v2) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1b26.  v0:= temp;
  #L1f1b28.  if v0 == 0 then goto L1f1b2e;
  #L1f1b2c.  return v1;
  #L1f1b2e.  call temp:= `getModifiers`(v3) @signature `Ljava/lang/reflect/Method;.getModifiers:()I` @kind virtual;
  #L1f1b34.  v0:= temp;
  #L1f1b36.  call temp:= `isStatic`(v0) @signature `Ljava/lang/reflect/Modifier;.isStatic:(I)Z` @kind static;
  #L1f1b3c.  v0:= temp;
  #L1f1b3e.  if v0 == 0 then goto L1f1b44;
  #L1f1b42.  return v1;
  #L1f1b44.  call temp:= `getReturnType`(v3) @signature `Ljava/lang/reflect/Method;.getReturnType:()Ljava/lang/Class;` @kind virtual;
  #L1f1b4a.  v0:= temp @kind object;
  #L1f1b4c.  v2:= `@@java.lang.Void.TYPE` @type ^`java.lang.Class` @kind object;
  #L1f1b50.  call temp:= `equals`(v0, v2) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L1f1b56.  v0:= temp;
  #L1f1b58.  if v0 != 0 then goto L1f1b5e;
  #L1f1b5c.  return v1;
  #L1f1b5e.  call temp:= `getParameterTypes`(v3) @signature `Ljava/lang/reflect/Method;.getParameterTypes:()[Ljava/lang/Class;` @kind virtual;
  #L1f1b64.  v0:= temp @kind object;
  #L1f1b66.  v0:= length @variable v0;
  #L1f1b68.  v2:= 1I;
  #L1f1b6a.  if v0 == v2 then goto L1f1b70;
  #L1f1b6e.  return v1;
  #L1f1b70.  v0:= constclass @type ^`s6.e` @kind object;
  #L1f1b74.  call temp:= `isAnnotationPresent`(v3, v0) @signature `Ljava/lang/reflect/Method;.isAnnotationPresent:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1b7a.  v3:= temp;
  #L1f1b7c.  if v3 == 0 then goto L1f1b82;
  #L1f1b80.  return v1;
  #L1f1b82.  return v2;
}
procedure `java.util.Map` `f`(`b7.a$a` v5 @kind this, `java.lang.Object` v6 @kind object) @signature `Lb7/a$a;.f:(Ljava/lang/Object;)Ljava/util/Map;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L1f1cf8.  v0:= v5.`b7.a$a.a` @type ^`java.lang.Class` @kind object;
  #L1f1cfc.  call temp:= `getClass`(v6) @signature `Ljava/lang/Object;.getClass:()Ljava/lang/Class;` @kind virtual;
  #L1f1d02.  v1:= temp @kind object;
  #L1f1d04.  call temp:= `isAssignableFrom`(v0, v1) @signature `Ljava/lang/Class;.isAssignableFrom:(Ljava/lang/Class;)Z` @kind virtual;
  #L1f1d0a.  v0:= temp;
  #L1f1d0c.  if v0 == 0 then goto L1f1dfc;
  #L1f1d10.  v0:= new `java.util.HashMap`;
  #L1f1d14.  call `<init>`(v0) @signature `Ljava/util/HashMap;.<init>:()V` @kind direct;
  #L1f1d1a.  v1:= v5.`b7.a$a.b` @type ^`java.util.Map` @kind object;
  #L1f1d1e.  call temp:= `values`(v1) @signature `Ljava/util/Map;.values:()Ljava/util/Collection;` @kind interface;
  #L1f1d24.  v1:= temp @kind object;
  #L1f1d26.  call temp:= `iterator`(v1) @signature `Ljava/util/Collection;.iterator:()Ljava/util/Iterator;` @kind interface;
  #L1f1d2c.  v1:= temp @kind object;
  #L1f1d2e.  call temp:= `hasNext`(v1) @signature `Ljava/util/Iterator;.hasNext:()Z` @kind interface;
  #L1f1d34.  v2:= temp;
  #L1f1d36.  if v2 == 0 then goto L1f1dfa;
  #L1f1d3a.  call temp:= `next`(v1) @signature `Ljava/util/Iterator;.next:()Ljava/lang/Object;` @kind interface;
  #L1f1d40.  v2:= temp @kind object;
  #L1f1d42.  v2:= (`java.lang.String`) v2 @kind object;
  #L1f1d46.  v3:= v5.`b7.a$a.c` @type ^`java.util.Map` @kind object;
  #L1f1d4a.  call temp:= `containsKey`(v3, v2) @signature `Ljava/util/Map;.containsKey:(Ljava/lang/Object;)Z` @kind interface;
  #L1f1d50.  v3:= temp;
  #L1f1d52.  if v3 == 0 then goto L1f1d92;
  #L1f1d56.  v3:= v5.`b7.a$a.c` @type ^`java.util.Map` @kind object;
  #L1f1d5a.  call temp:= `get`(v3, v2) @signature `Ljava/util/Map;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f1d60.  v3:= temp @kind object;
  #L1f1d62.  v3:= (`java.lang.reflect.Method`) v3 @kind object;
  #L1f1d66.  v4:= 0I;
  #L1f1d68.  v4:= new `java.lang.Object`[v4];
  #L1f1d6c.  call temp:= `invoke`(v3, v6, v4) @signature `Ljava/lang/reflect/Method;.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L1f1d72.  v3:= temp @kind object;
  #L1f1d74.  goto L1f1dae;
  #L1f1d76.  v6:= Exception @type ^`java.lang.reflect.InvocationTargetException` @kind object;
  #L1f1d78.  v0:= new `java.lang.RuntimeException`;
  #L1f1d7c.  call `<init>`(v0, v6) @signature `Ljava/lang/RuntimeException;.<init>:(Ljava/lang/Throwable;)V` @kind direct;
  #L1f1d82.  throw v0;
  #L1f1d84.  v6:= Exception @type ^`java.lang.IllegalAccessException` @kind object;
  #L1f1d86.  v0:= new `java.lang.RuntimeException`;
  #L1f1d8a.  call `<init>`(v0, v6) @signature `Ljava/lang/RuntimeException;.<init>:(Ljava/lang/Throwable;)V` @kind direct;
  #L1f1d90.  throw v0;
  #L1f1d92.  v3:= v5.`b7.a$a.e` @type ^`java.util.Map` @kind object;
  #L1f1d96.  call temp:= `get`(v3, v2) @signature `Ljava/util/Map;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f1d9c.  v3:= temp @kind object;
  #L1f1d9e.  v3:= (`java.lang.reflect.Field`) v3 @kind object;
  #L1f1da2.  if v3 == 0 then goto L1f1dcc;
  #L1f1da6.  call temp:= `get`(v3, v6) @signature `Ljava/lang/reflect/Field;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L1f1dac.  v3:= temp @kind object;
  #L1f1dae.  call temp:= `a`(v3) @signature `Lb7/a;.a:(Ljava/lang/Object;)Ljava/lang/Object;` @kind static;
  #L1f1db4.  v3:= temp @kind object;
  #L1f1db6.  call temp:= `put`(v0, v2, v3) @signature `Ljava/util/Map;.put:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L1f1dbc.  goto L1f1d2e;
  #L1f1dbe.  v6:= Exception @type ^`java.lang.IllegalAccessException` @kind object;
  #L1f1dc0.  v0:= new `java.lang.RuntimeException`;
  #L1f1dc4.  call `<init>`(v0, v6) @signature `Ljava/lang/RuntimeException;.<init>:(Ljava/lang/Throwable;)V` @kind direct;
  #L1f1dca.  throw v0;
  #L1f1dcc.  v6:= new `java.lang.IllegalStateException`;
  #L1f1dd0.  v0:= new `java.lang.StringBuilder`;
  #L1f1dd4.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f1dda.  v1:= "Bean property without field or getter:" @kind object;
  #L1f1dde.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1de4.  call temp:= `append`(v0, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1dea.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f1df0.  v0:= temp @kind object;
  #L1f1df2.  call `<init>`(v6, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f1df8.  throw v6;
  #L1f1dfa.  return v0 @kind object;
  #L1f1dfc.  v0:= new `java.lang.IllegalArgumentException`;
  #L1f1e00.  v1:= new `java.lang.StringBuilder`;
  #L1f1e04.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1f1e0a.  v2:= "Can't serialize object of class " @kind object;
  #L1f1e0e.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1e14.  call temp:= `getClass`(v6) @signature `Ljava/lang/Object;.getClass:()Ljava/lang/Class;` @kind virtual;
  #L1f1e1a.  v6:= temp @kind object;
  #L1f1e1c.  call temp:= `append`(v1, v6) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1e22.  v6:= " with BeanMapper for class " @kind object;
  #L1f1e26.  call temp:= `append`(v1, v6) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1e2c.  v6:= v5.`b7.a$a.a` @type ^`java.lang.Class` @kind object;
  #L1f1e30.  call temp:= `append`(v1, v6) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1f1e36.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1f1e3c.  v6:= temp @kind object;
  #L1f1e3e.  call `<init>`(v0, v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1f1e44.  throw v0;
  catch `java.lang.IllegalAccessException` @[L1f1d68..L1f1d74] goto L1f1d84;
  catch `java.lang.reflect.InvocationTargetException` @[L1f1d68..L1f1d74] goto L1f1d76;
  catch `java.lang.IllegalAccessException` @[L1f1da6..L1f1dae] goto L1f1dbe;
}

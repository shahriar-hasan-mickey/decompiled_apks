record `s3.y` @kind class @AccessFlag PUBLIC_FINAL {
  `byte`[] `s3.y.a` @AccessFlag PUBLIC;
  `int` `s3.y.b` @AccessFlag PRIVATE;
  `int` `s3.y.c` @AccessFlag PRIVATE;
  `int` `s3.y.d` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`s3.y` v1 @kind this) @signature `Ls3/y;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;

  #L45ed58.  call `<init>`(v1) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L45ed5e.  v0:= `@@s3.l0.f` @type ^`byte`[] @kind object;
  #L45ed62.  v1.`s3.y.a` @type ^`byte`[] := v0 @kind object;
  #L45ed66.  return @kind void;
}
procedure `void` `<init>`(`s3.y` v1 @kind this, `byte`[] v2 @kind object) @signature `Ls3/y;.<init>:([B)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;

  #L45ed78.  v0:= length @variable v2;
  #L45ed7a.  call `<init>`(v1, v2, v0) @signature `Ls3/y;.<init>:([BI)V` @kind direct;
  #L45ed80.  return @kind void;
}
procedure `void` `<init>`(`s3.y` v0 @kind this, `byte`[] v1 @kind object, `int` v2 ) @signature `Ls3/y;.<init>:([BI)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L45ed94.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L45ed9a.  v0.`s3.y.a` @type ^`byte`[] := v1 @kind object;
  #L45ed9e.  v0.`s3.y.d` @type ^`int` := v2;
  #L45eda2.  return @kind void;
}
procedure `void` `a`(`s3.y` v2 @kind this) @signature `Ls3/y;.a:()V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;

  #L45edb4.  v0:= v2.`s3.y.b` @type ^`int`;
  #L45edb8.  if v0 < 0 then goto L45edd4;
  #L45edbc.  v1:= v2.`s3.y.d` @type ^`int`;
  #L45edc0.  if v0 < v1 then goto L45edd0;
  #L45edc4.  if v0 != v1 then goto L45edd4;
  #L45edc8.  v0:= v2.`s3.y.c` @type ^`int`;
  #L45edcc.  if v0 != 0 then goto L45edd4;
  #L45edd0.  v0:= 1I;
  #L45edd2.  goto L45edd6;
  #L45edd4.  v0:= 0I;
  #L45edd6.  call `f`(v0) @signature `Ls3/a;.f:(Z)V` @kind static;
  #L45eddc.  return @kind void;
}
procedure `int` `b`(`s3.y` v2 @kind this) @signature `Ls3/y;.b:()I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45ebe0.  v0:= v2.`s3.y.d` @type ^`int`;
  #L45ebe4.  v1:= v2.`s3.y.b` @type ^`int`;
  #L45ebe8.  v0:= v0 - v1 @kind int;
  #L45ebea.  v0:= v0 * 8;
  #L45ebee.  v1:= v2.`s3.y.c` @type ^`int`;
  #L45ebf2.  v0:= v0 - v1 @kind int;
  #L45ebf4.  return v0;
}
procedure `void` `c`(`s3.y` v1 @kind this) @signature `Ls3/y;.c:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L45edf0.  v0:= v1.`s3.y.c` @type ^`int`;
  #L45edf4.  if v0 != 0 then goto L45edfa;
  #L45edf8.  return @kind void;
  #L45edfa.  v0:= 0I;
  #L45edfc.  v1.`s3.y.c` @type ^`int` := v0;
  #L45ee00.  v0:= v1.`s3.y.b` @type ^`int`;
  #L45ee04.  v0:= v0 + 1;
  #L45ee08.  v1.`s3.y.b` @type ^`int` := v0;
  #L45ee0c.  call `a`(v1) @signature `Ls3/y;.a:()V` @kind direct;
  #L45ee12.  return @kind void;
}
procedure `int` `d`(`s3.y` v1 @kind this) @signature `Ls3/y;.d:()I` @AccessFlag PUBLIC {
    temp;
    v0;

  #L45ec08.  v0:= v1.`s3.y.c` @type ^`int`;
  #L45ec0c.  if v0 != 0 then goto L45ec14;
  #L45ec10.  v0:= 1I;
  #L45ec12.  goto L45ec16;
  #L45ec14.  v0:= 0I;
  #L45ec16.  call `f`(v0) @signature `Ls3/a;.f:(Z)V` @kind static;
  #L45ec1c.  v0:= v1.`s3.y.b` @type ^`int`;
  #L45ec20.  return v0;
}
procedure `int` `e`(`s3.y` v2 @kind this) @signature `Ls3/y;.e:()I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45ec34.  v0:= v2.`s3.y.b` @type ^`int`;
  #L45ec38.  v0:= v0 * 8;
  #L45ec3c.  v1:= v2.`s3.y.c` @type ^`int`;
  #L45ec40.  v0:= v0 + v1 @kind int;
  #L45ec42.  return v0;
}
procedure `void` `f`(`s3.y` v8 @kind this, `int` v9 , `int` v10 ) @signature `Ls3/y;.f:(II)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L45ee24.  v0:= 1I;
  #L45ee26.  v1:= 32I;
  #L45ee2a.  if v10 >= v1 then goto L45ee36;
  #L45ee2e.  v1:= v0 ^< v10 @kind int;
  #L45ee32.  v1:= v1 - v0 @kind int;
  #L45ee34.  v9:= v9 ^& v1 @kind int;
  #L45ee36.  v1:= v8.`s3.y.c` @type ^`int`;
  #L45ee3a.  v2:= 8I;
  #L45ee3e.  v1:= v1 - 8;
  #L45ee42.  call temp:= `min`(v1, v10) @signature `Ljava/lang/Math;.min:(II)I` @kind static;
  #L45ee48.  v1:= temp;
  #L45ee4a.  v3:= v8.`s3.y.c` @type ^`int`;
  #L45ee4e.  v4:= v3 - 8;
  #L45ee52.  v4:= v4 - v1 @kind int;
  #L45ee54.  v5:= 65280I;
  #L45ee5a.  v3:= v5 ^> v3 @kind int;
  #L45ee5e.  v5:= v0 ^< v4 @kind int;
  #L45ee62.  v5:= v5 - v0 @kind int;
  #L45ee64.  v3:= v3 ^| v5 @kind int;
  #L45ee66.  v5:= v8.`s3.y.a` @type ^`byte`[] @kind object;
  #L45ee6a.  v6:= v8.`s3.y.b` @type ^`int`;
  #L45ee6e.  v7:= v5[v6] @kind byte;
  #L45ee72.  v3:= v3 ^& v7 @kind int;
  #L45ee74.  v3:= (`byte`) v3 @kind i2b;
  #L45ee76.  v5[v6]:= v3 @kind byte;
  #L45ee7a.  v1:= v10 - v1 @kind int;
  #L45ee7e.  v3:= v9 ^>> v1 @kind int;
  #L45ee82.  v7:= v5[v6] @kind byte;
  #L45ee86.  v3:= v3 ^< v4 @kind int;
  #L45ee88.  v3:= v3 ^| v7 @kind int;
  #L45ee8a.  v3:= (`byte`) v3 @kind i2b;
  #L45ee8c.  v5[v6]:= v3 @kind byte;
  #L45ee90.  v6:= v6 + v0 @kind int;
  #L45ee92.  if v1 <= v2 then goto L45eeb4;
  #L45ee96.  v3:= v8.`s3.y.a` @type ^`byte`[] @kind object;
  #L45ee9a.  v4:= v6 + 1;
  #L45ee9e.  v5:= v1 + -8;
  #L45eea2.  v5:= v9 ^>> v5 @kind int;
  #L45eea6.  v5:= (`byte`) v5 @kind i2b;
  #L45eea8.  v3[v6]:= v5 @kind byte;
  #L45eeac.  v1:= v1 + -8;
  #L45eeb0.  v6:= v4;
  #L45eeb2.  goto L45ee92;
  #L45eeb4.  v2:= v1 - 8;
  #L45eeb8.  v3:= v8.`s3.y.a` @type ^`byte`[] @kind object;
  #L45eebc.  v4:= v3[v6] @kind byte;
  #L45eec0.  v5:= v0 ^< v2 @kind int;
  #L45eec4.  v5:= v5 - v0 @kind int;
  #L45eec6.  v4:= v4 ^& v5 @kind int;
  #L45eec8.  v4:= (`byte`) v4 @kind i2b;
  #L45eeca.  v3[v6]:= v4 @kind byte;
  #L45eece.  v1:= v0 ^< v1 @kind int;
  #L45eed2.  v1:= v1 - v0 @kind int;
  #L45eed4.  v9:= v9 ^& v1 @kind int;
  #L45eed6.  v0:= v3[v6] @kind byte;
  #L45eeda.  v9:= v9 ^< v2 @kind int;
  #L45eedc.  v9:= v9 ^| v0 @kind int;
  #L45eede.  v9:= (`byte`) v9 @kind i2b;
  #L45eee0.  v3[v6]:= v9 @kind byte;
  #L45eee4.  call `r`(v8, v10) @signature `Ls3/y;.r:(I)V` @kind virtual;
  #L45eeea.  call `a`(v8) @signature `Ls3/y;.a:()V` @kind direct;
  #L45eef0.  return @kind void;
}
procedure `boolean` `g`(`s3.y` v3 @kind this) @signature `Ls3/y;.g:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L45eba4.  v0:= v3.`s3.y.a` @type ^`byte`[] @kind object;
  #L45eba8.  v1:= v3.`s3.y.b` @type ^`int`;
  #L45ebac.  v0:= v0[v1] @kind byte;
  #L45ebb0.  v1:= v3.`s3.y.c` @type ^`int`;
  #L45ebb4.  v2:= 128I;
  #L45ebb8.  v1:= v2 ^> v1 @kind int;
  #L45ebbc.  v0:= v0 ^& v1 @kind int;
  #L45ebbe.  if v0 == 0 then goto L45ebc6;
  #L45ebc2.  v0:= 1I;
  #L45ebc4.  goto L45ebc8;
  #L45ebc6.  v0:= 0I;
  #L45ebc8.  call `q`(v3) @signature `Ls3/y;.q:()V` @kind virtual;
  #L45ebce.  return v0;
}
procedure `int` `h`(`s3.y` v7 @kind this, `int` v8 ) @signature `Ls3/y;.h:(I)I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L45ec54.  v0:= 0I;
  #L45ec56.  if v8 != 0 then goto L45ec5c;
  #L45ec5a.  return v0;
  #L45ec5c.  v1:= v7.`s3.y.c` @type ^`int`;
  #L45ec60.  v1:= v1 + v8 @kind int;
  #L45ec62.  v7.`s3.y.c` @type ^`int` := v1;
  #L45ec66.  v1:= 0I;
  #L45ec68.  v2:= v7.`s3.y.c` @type ^`int`;
  #L45ec6c.  v3:= 8I;
  #L45ec70.  if v2 <= v3 then goto L45ec9c;
  #L45ec74.  v2:= v2 + -8;
  #L45ec78.  v7.`s3.y.c` @type ^`int` := v2;
  #L45ec7c.  v3:= v7.`s3.y.a` @type ^`byte`[] @kind object;
  #L45ec80.  v4:= v7.`s3.y.b` @type ^`int`;
  #L45ec84.  v5:= v4 + 1;
  #L45ec88.  v7.`s3.y.b` @type ^`int` := v5;
  #L45ec8c.  v3:= v3[v4] @kind byte;
  #L45ec90.  v3:= v3 ^& 255;
  #L45ec94.  v2:= v3 ^< v2 @kind int;
  #L45ec98.  v1:= v1 ^| v2 @kind int;
  #L45ec9a.  goto L45ec68;
  #L45ec9c.  v4:= v7.`s3.y.a` @type ^`byte`[] @kind object;
  #L45eca0.  v5:= v7.`s3.y.b` @type ^`int`;
  #L45eca4.  v4:= v4[v5] @kind byte;
  #L45eca8.  v4:= v4 ^& 255;
  #L45ecac.  v6:= v2 - 8;
  #L45ecb0.  v4:= v4 ^> v6 @kind int;
  #L45ecb2.  v1:= v1 ^| v4 @kind int;
  #L45ecb4.  v4:= -1I;
  #L45ecb6.  v8:= v8 - 32;
  #L45ecba.  v8:= v4 ^>> v8 @kind int;
  #L45ecbe.  v8:= v8 ^& v1 @kind int;
  #L45ecc0.  if v2 != v3 then goto L45ecd0;
  #L45ecc4.  v7.`s3.y.c` @type ^`int` := v0;
  #L45ecc8.  v5:= v5 + 1;
  #L45eccc.  v7.`s3.y.b` @type ^`int` := v5;
  #L45ecd0.  call `a`(v7) @signature `Ls3/y;.a:()V` @kind direct;
  #L45ecd6.  return v8;
}
procedure `void` `i`(`s3.y` v7 @kind this, `byte`[] v8 @kind object, `int` v9 , `int` v10 ) @signature `Ls3/y;.i:([BII)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L45ef04.  v0:= v10 ^> 3;
  #L45ef08.  v0:= v0 + v9 @kind int;
  #L45ef0a.  v1:= 255I;
  #L45ef0e.  v2:= 8I;
  #L45ef12.  if v9 >= v0 then goto L45ef52;
  #L45ef16.  v3:= v7.`s3.y.a` @type ^`byte`[] @kind object;
  #L45ef1a.  v4:= v7.`s3.y.b` @type ^`int`;
  #L45ef1e.  v5:= v4 + 1;
  #L45ef22.  v7.`s3.y.b` @type ^`int` := v5;
  #L45ef26.  v4:= v3[v4] @kind byte;
  #L45ef2a.  v6:= v7.`s3.y.c` @type ^`int`;
  #L45ef2e.  v4:= v4 ^< v6 @kind int;
  #L45ef30.  v4:= (`byte`) v4 @kind i2b;
  #L45ef32.  v8[v9]:= v4 @kind byte;
  #L45ef36.  v4:= v8[v9] @kind byte;
  #L45ef3a.  v3:= v3[v5] @kind byte;
  #L45ef3e.  v1:= v1 ^& v3 @kind int;
  #L45ef40.  v2:= v2 - v6 @kind int;
  #L45ef42.  v1:= v1 ^> v2 @kind int;
  #L45ef44.  v1:= v1 ^| v4 @kind int;
  #L45ef46.  v1:= (`byte`) v1 @kind i2b;
  #L45ef48.  v8[v9]:= v1 @kind byte;
  #L45ef4c.  v9:= v9 + 1;
  #L45ef50.  goto L45ef0a;
  #L45ef52.  v9:= v10 ^& 7;
  #L45ef56.  if v9 != 0 then goto L45ef5c;
  #L45ef5a.  return @kind void;
  #L45ef5c.  v10:= v8[v0] @kind byte;
  #L45ef60.  v3:= v1 ^> v9 @kind int;
  #L45ef64.  v10:= v10 ^& v3 @kind int;
  #L45ef66.  v10:= (`byte`) v10 @kind i2b;
  #L45ef68.  v8[v0]:= v10 @kind byte;
  #L45ef6c.  v10:= v7.`s3.y.c` @type ^`int`;
  #L45ef70.  v3:= v10 + v9 @kind int;
  #L45ef74.  if v3 <= v2 then goto L45efa2;
  #L45ef78.  v3:= v8[v0] @kind byte;
  #L45ef7c.  v4:= v7.`s3.y.a` @type ^`byte`[] @kind object;
  #L45ef80.  v5:= v7.`s3.y.b` @type ^`int`;
  #L45ef84.  v6:= v5 + 1;
  #L45ef88.  v7.`s3.y.b` @type ^`int` := v6;
  #L45ef8c.  v4:= v4[v5] @kind byte;
  #L45ef90.  v4:= v4 ^& v1 @kind int;
  #L45ef92.  v4:= v4 ^< v10 @kind int;
  #L45ef94.  v3:= v3 ^| v4 @kind int;
  #L45ef96.  v3:= (`byte`) v3 @kind i2b;
  #L45ef98.  v8[v0]:= v3 @kind byte;
  #L45ef9c.  v10:= v10 - v2 @kind int;
  #L45ef9e.  v7.`s3.y.c` @type ^`int` := v10;
  #L45efa2.  v10:= v7.`s3.y.c` @type ^`int`;
  #L45efa6.  v10:= v10 + v9 @kind int;
  #L45efa8.  v7.`s3.y.c` @type ^`int` := v10;
  #L45efac.  v3:= v7.`s3.y.a` @type ^`byte`[] @kind object;
  #L45efb0.  v4:= v7.`s3.y.b` @type ^`int`;
  #L45efb4.  v3:= v3[v4] @kind byte;
  #L45efb8.  v1:= v1 ^& v3 @kind int;
  #L45efba.  v3:= v10 - 8;
  #L45efbe.  v1:= v1 ^> v3 @kind int;
  #L45efc0.  v3:= v8[v0] @kind byte;
  #L45efc4.  v9:= v9 - 8;
  #L45efc8.  v9:= v1 ^< v9 @kind int;
  #L45efcc.  v9:= (`byte`) v9 @kind i2b;
  #L45efce.  v9:= v9 ^| v3 @kind int;
  #L45efd0.  v9:= (`byte`) v9 @kind i2b;
  #L45efd2.  v8[v0]:= v9 @kind byte;
  #L45efd6.  if v10 != v2 then goto L45efe8;
  #L45efda.  v8:= 0I;
  #L45efdc.  v7.`s3.y.c` @type ^`int` := v8;
  #L45efe0.  v4:= v4 + 1;
  #L45efe4.  v7.`s3.y.b` @type ^`int` := v4;
  #L45efe8.  call `a`(v7) @signature `Ls3/y;.a:()V` @kind direct;
  #L45efee.  return @kind void;
}
procedure `long` `j`(`s3.y` v2 @kind this, `int` v3 ) @signature `Ls3/y;.j:(I)J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45ed10.  v0:= 32I;
  #L45ed14.  if v3 > v0 then goto L45ed2a;
  #L45ed18.  call temp:= `h`(v2, v3) @signature `Ls3/y;.h:(I)I` @kind virtual;
  #L45ed1e.  v3:= temp;
  #L45ed20.  call temp:= `V0`(v3) @signature `Ls3/l0;.V0:(I)J` @kind static;
  #L45ed26.  v0:= temp @kind wide;
  #L45ed28.  return v0 @kind wide;
  #L45ed2a.  v3:= v3 - v0 @kind int;
  #L45ed2c.  call temp:= `h`(v2, v3) @signature `Ls3/y;.h:(I)I` @kind virtual;
  #L45ed32.  v3:= temp;
  #L45ed34.  call temp:= `h`(v2, v0) @signature `Ls3/y;.h:(I)I` @kind virtual;
  #L45ed3a.  v0:= temp;
  #L45ed3c.  call temp:= `U0`(v3, v0) @signature `Ls3/l0;.U0:(II)J` @kind static;
  #L45ed42.  v0:= temp @kind wide;
  #L45ed44.  return v0 @kind wide;
}
procedure `void` `k`(`s3.y` v2 @kind this, `byte`[] v3 @kind object, `int` v4 , `int` v5 ) @signature `Ls3/y;.k:([BII)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45f000.  v0:= v2.`s3.y.c` @type ^`int`;
  #L45f004.  if v0 != 0 then goto L45f00c;
  #L45f008.  v0:= 1I;
  #L45f00a.  goto L45f00e;
  #L45f00c.  v0:= 0I;
  #L45f00e.  call `f`(v0) @signature `Ls3/a;.f:(Z)V` @kind static;
  #L45f014.  v0:= v2.`s3.y.a` @type ^`byte`[] @kind object;
  #L45f018.  v1:= v2.`s3.y.b` @type ^`int`;
  #L45f01c.  call `arraycopy`(v0, v1, v3, v4, v5) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L45f022.  v3:= v2.`s3.y.b` @type ^`int`;
  #L45f026.  v3:= v3 + v5 @kind int;
  #L45f028.  v2.`s3.y.b` @type ^`int` := v3;
  #L45f02c.  call `a`(v2) @signature `Ls3/y;.a:()V` @kind direct;
  #L45f032.  return @kind void;
}
procedure `java.lang.String` `l`(`s3.y` v2 @kind this, `int` v3 , `java.nio.charset.Charset` v4 @kind object) @signature `Ls3/y;.l:(ILjava/nio/charset/Charset;)Ljava/lang/String;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45ece8.  v0:= new `byte`[v3];
  #L45ecec.  v1:= 0I;
  #L45ecee.  call `k`(v2, v0, v1, v3) @signature `Ls3/y;.k:([BII)V` @kind virtual;
  #L45ecf4.  v3:= new `java.lang.String`;
  #L45ecf8.  call `<init>`(v3, v0, v4) @signature `Ljava/lang/String;.<init>:([BLjava/nio/charset/Charset;)V` @kind direct;
  #L45ecfe.  return v3 @kind object;
}
procedure `void` `m`(`s3.y` v2 @kind this, `s3.z` v3 @kind object) @signature `Ls3/y;.m:(Ls3/z;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45f084.  call temp:= `d`(v3) @signature `Ls3/z;.d:()[B` @kind virtual;
  #L45f08a.  v0:= temp @kind object;
  #L45f08c.  call temp:= `f`(v3) @signature `Ls3/z;.f:()I` @kind virtual;
  #L45f092.  v1:= temp;
  #L45f094.  call `o`(v2, v0, v1) @signature `Ls3/y;.o:([BI)V` @kind virtual;
  #L45f09a.  call temp:= `e`(v3) @signature `Ls3/z;.e:()I` @kind virtual;
  #L45f0a0.  v3:= temp;
  #L45f0a2.  v3:= v3 * 8;
  #L45f0a6.  call `p`(v2, v3) @signature `Ls3/y;.p:(I)V` @kind virtual;
  #L45f0ac.  return @kind void;
}
procedure `void` `n`(`s3.y` v1 @kind this, `byte`[] v2 @kind object) @signature `Ls3/y;.n:([B)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L45f044.  v0:= length @variable v2;
  #L45f046.  call `o`(v1, v2, v0) @signature `Ls3/y;.o:([BI)V` @kind virtual;
  #L45f04c.  return @kind void;
}
procedure `void` `o`(`s3.y` v0 @kind this, `byte`[] v1 @kind object, `int` v2 ) @signature `Ls3/y;.o:([BI)V` @AccessFlag PUBLIC {
    temp;

  #L45f060.  v0.`s3.y.a` @type ^`byte`[] := v1 @kind object;
  #L45f064.  v1:= 0I;
  #L45f066.  v0.`s3.y.b` @type ^`int` := v1;
  #L45f06a.  v0.`s3.y.c` @type ^`int` := v1;
  #L45f06e.  v0.`s3.y.d` @type ^`int` := v2;
  #L45f072.  return @kind void;
}
procedure `void` `p`(`s3.y` v1 @kind this, `int` v2 ) @signature `Ls3/y;.p:(I)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L45f0c0.  v0:= v2 / 8;
  #L45f0c4.  v1.`s3.y.b` @type ^`int` := v0;
  #L45f0c8.  v0:= v0 * 8;
  #L45f0cc.  v2:= v2 - v0 @kind int;
  #L45f0ce.  v1.`s3.y.c` @type ^`int` := v2;
  #L45f0d2.  call `a`(v1) @signature `Ls3/y;.a:()V` @kind direct;
  #L45f0d8.  return @kind void;
}
procedure `void` `q`(`s3.y` v2 @kind this) @signature `Ls3/y;.q:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L45f0ec.  v0:= v2.`s3.y.c` @type ^`int`;
  #L45f0f0.  v0:= v0 + 1;
  #L45f0f4.  v2.`s3.y.c` @type ^`int` := v0;
  #L45f0f8.  v1:= 8I;
  #L45f0fc.  if v0 != v1 then goto L45f112;
  #L45f100.  v0:= 0I;
  #L45f102.  v2.`s3.y.c` @type ^`int` := v0;
  #L45f106.  v0:= v2.`s3.y.b` @type ^`int`;
  #L45f10a.  v0:= v0 + 1;
  #L45f10e.  v2.`s3.y.b` @type ^`int` := v0;
  #L45f112.  call `a`(v2) @signature `Ls3/y;.a:()V` @kind direct;
  #L45f118.  return @kind void;
}
procedure `void` `r`(`s3.y` v3 @kind this, `int` v4 ) @signature `Ls3/y;.r:(I)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L45f12c.  v0:= v4 / 8;
  #L45f130.  v1:= v3.`s3.y.b` @type ^`int`;
  #L45f134.  v1:= v1 + v0 @kind int;
  #L45f136.  v3.`s3.y.b` @type ^`int` := v1;
  #L45f13a.  v2:= v3.`s3.y.c` @type ^`int`;
  #L45f13e.  v0:= v0 * 8;
  #L45f142.  v4:= v4 - v0 @kind int;
  #L45f144.  v2:= v2 + v4 @kind int;
  #L45f146.  v3.`s3.y.c` @type ^`int` := v2;
  #L45f14a.  v4:= 7I;
  #L45f14c.  if v2 <= v4 then goto L45f160;
  #L45f150.  v1:= v1 + 1;
  #L45f154.  v3.`s3.y.b` @type ^`int` := v1;
  #L45f158.  v2:= v2 + -8;
  #L45f15c.  v3.`s3.y.c` @type ^`int` := v2;
  #L45f160.  call `a`(v3) @signature `Ls3/y;.a:()V` @kind direct;
  #L45f166.  return @kind void;
}
procedure `void` `s`(`s3.y` v1 @kind this, `int` v2 ) @signature `Ls3/y;.s:(I)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L45f178.  v0:= v1.`s3.y.c` @type ^`int`;
  #L45f17c.  if v0 != 0 then goto L45f184;
  #L45f180.  v0:= 1I;
  #L45f182.  goto L45f186;
  #L45f184.  v0:= 0I;
  #L45f186.  call `f`(v0) @signature `Ls3/a;.f:(Z)V` @kind static;
  #L45f18c.  v0:= v1.`s3.y.b` @type ^`int`;
  #L45f190.  v0:= v0 + v2 @kind int;
  #L45f192.  v1.`s3.y.b` @type ^`int` := v0;
  #L45f196.  call `a`(v1) @signature `Ls3/y;.a:()V` @kind direct;
  #L45f19c.  return @kind void;
}

record `x1.i0` @kind class @AccessFlag PUBLIC_FINAL extends `x1.f` @kind interface {
  `int` `x1.i0.b` @AccessFlag PRIVATE;
  `float` `x1.i0.c` @AccessFlag PRIVATE;
  `float` `x1.i0.d` @AccessFlag PRIVATE;
  `x1.f$a` `x1.i0.e` @AccessFlag PRIVATE;
  `x1.f$a` `x1.i0.f` @AccessFlag PRIVATE;
  `x1.f$a` `x1.i0.g` @AccessFlag PRIVATE;
  `x1.f$a` `x1.i0.h` @AccessFlag PRIVATE;
  `boolean` `x1.i0.i` @AccessFlag PRIVATE;
  `x1.h0` `x1.i0.j` @AccessFlag PRIVATE;
  `java.nio.ByteBuffer` `x1.i0.k` @AccessFlag PRIVATE;
  `java.nio.ShortBuffer` `x1.i0.l` @AccessFlag PRIVATE;
  `java.nio.ByteBuffer` `x1.i0.m` @AccessFlag PRIVATE;
  `long` `x1.i0.n` @AccessFlag PRIVATE;
  `long` `x1.i0.o` @AccessFlag PRIVATE;
  `boolean` `x1.i0.p` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`x1.i0` v2 @kind this) @signature `Lx1/i0;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L4d8328.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L4d832e.  v0:= 1.0F;
  #L4d8332.  v2.`x1.i0.c` @type ^`float` := v0;
  #L4d8336.  v2.`x1.i0.d` @type ^`float` := v0;
  #L4d833a.  v0:= `@@x1.f$a.e` @type ^`x1.f$a` @kind object;
  #L4d833e.  v2.`x1.i0.e` @type ^`x1.f$a` := v0 @kind object;
  #L4d8342.  v2.`x1.i0.f` @type ^`x1.f$a` := v0 @kind object;
  #L4d8346.  v2.`x1.i0.g` @type ^`x1.f$a` := v0 @kind object;
  #L4d834a.  v2.`x1.i0.h` @type ^`x1.f$a` := v0 @kind object;
  #L4d834e.  v0:= `@@x1.f.a` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d8352.  v2.`x1.i0.k` @type ^`java.nio.ByteBuffer` := v0 @kind object;
  #L4d8356.  call temp:= `asShortBuffer`(v0) @signature `Ljava/nio/ByteBuffer;.asShortBuffer:()Ljava/nio/ShortBuffer;` @kind virtual;
  #L4d835c.  v1:= temp @kind object;
  #L4d835e.  v2.`x1.i0.l` @type ^`java.nio.ShortBuffer` := v1 @kind object;
  #L4d8362.  v2.`x1.i0.m` @type ^`java.nio.ByteBuffer` := v0 @kind object;
  #L4d8366.  v0:= -1I;
  #L4d8368.  v2.`x1.i0.b` @type ^`int` := v0;
  #L4d836c.  return @kind void;
}
procedure `boolean` `a`(`x1.i0` v3 @kind this) @signature `Lx1/i0;.a:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4d8140.  v0:= v3.`x1.i0.f` @type ^`x1.f$a` @kind object;
  #L4d8144.  v0:= v0.`x1.f$a.a` @type ^`int`;
  #L4d8148.  v1:= -1I;
  #L4d814a.  if v0 == v1 then goto L4d819c;
  #L4d814e.  v0:= v3.`x1.i0.c` @type ^`float`;
  #L4d8152.  v1:= 1.0F;
  #L4d8156.  v0:= v0 - v1 @kind float;
  #L4d8158.  call temp:= `abs`(v0) @signature `Ljava/lang/Math;.abs:(F)F` @kind static;
  #L4d815e.  v0:= temp;
  #L4d8160.  v2:= 953267991I;
  #L4d8166.  v0:= fcmpl(v0, v2);
  #L4d816a.  if v0 >= 0 then goto L4d8198;
  #L4d816e.  v0:= v3.`x1.i0.d` @type ^`float`;
  #L4d8172.  v0:= v0 - v1 @kind float;
  #L4d8174.  call temp:= `abs`(v0) @signature `Ljava/lang/Math;.abs:(F)F` @kind static;
  #L4d817a.  v0:= temp;
  #L4d817c.  v0:= fcmpl(v0, v2);
  #L4d8180.  if v0 >= 0 then goto L4d8198;
  #L4d8184.  v0:= v3.`x1.i0.f` @type ^`x1.f$a` @kind object;
  #L4d8188.  v0:= v0.`x1.f$a.a` @type ^`int`;
  #L4d818c.  v1:= v3.`x1.i0.e` @type ^`x1.f$a` @kind object;
  #L4d8190.  v1:= v1.`x1.f$a.a` @type ^`int`;
  #L4d8194.  if v0 == v1 then goto L4d819c;
  #L4d8198.  v0:= 1I;
  #L4d819a.  goto L4d819e;
  #L4d819c.  v0:= 0I;
  #L4d819e.  return v0;
}
procedure `boolean` `b`(`x1.i0` v1 @kind this) @signature `Lx1/i0;.b:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d81b0.  v0:= v1.`x1.i0.p` @type ^`boolean` @kind boolean;
  #L4d81b4.  if v0 == 0 then goto L4d81d0;
  #L4d81b8.  v0:= v1.`x1.i0.j` @type ^`x1.h0` @kind object;
  #L4d81bc.  if v0 == 0 then goto L4d81cc;
  #L4d81c0.  call temp:= `k`(v0) @signature `Lx1/h0;.k:()I` @kind virtual;
  #L4d81c6.  v0:= temp;
  #L4d81c8.  if v0 != 0 then goto L4d81d0;
  #L4d81cc.  v0:= 1I;
  #L4d81ce.  goto L4d81d2;
  #L4d81d0.  v0:= 0I;
  #L4d81d2.  return v0;
}
procedure `void` `c`(`x1.i0` v3 @kind this) @signature `Lx1/i0;.c:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4d8490.  v0:= 1.0F;
  #L4d8494.  v3.`x1.i0.c` @type ^`float` := v0;
  #L4d8498.  v3.`x1.i0.d` @type ^`float` := v0;
  #L4d849c.  v0:= `@@x1.f$a.e` @type ^`x1.f$a` @kind object;
  #L4d84a0.  v3.`x1.i0.e` @type ^`x1.f$a` := v0 @kind object;
  #L4d84a4.  v3.`x1.i0.f` @type ^`x1.f$a` := v0 @kind object;
  #L4d84a8.  v3.`x1.i0.g` @type ^`x1.f$a` := v0 @kind object;
  #L4d84ac.  v3.`x1.i0.h` @type ^`x1.f$a` := v0 @kind object;
  #L4d84b0.  v0:= `@@x1.f.a` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d84b4.  v3.`x1.i0.k` @type ^`java.nio.ByteBuffer` := v0 @kind object;
  #L4d84b8.  call temp:= `asShortBuffer`(v0) @signature `Ljava/nio/ByteBuffer;.asShortBuffer:()Ljava/nio/ShortBuffer;` @kind virtual;
  #L4d84be.  v1:= temp @kind object;
  #L4d84c0.  v3.`x1.i0.l` @type ^`java.nio.ShortBuffer` := v1 @kind object;
  #L4d84c4.  v3.`x1.i0.m` @type ^`java.nio.ByteBuffer` := v0 @kind object;
  #L4d84c8.  v0:= -1I;
  #L4d84ca.  v3.`x1.i0.b` @type ^`int` := v0;
  #L4d84ce.  v0:= 0I;
  #L4d84d0.  v3.`x1.i0.i` @type ^`boolean` := v0 @kind boolean;
  #L4d84d4.  v1:= 0I;
  #L4d84d6.  v3.`x1.i0.j` @type ^`x1.h0` := v1 @kind object;
  #L4d84da.  v1:= 0L;
  #L4d84de.  v3.`x1.i0.n` @type ^`long` := v1 @kind wide;
  #L4d84e2.  v3.`x1.i0.o` @type ^`long` := v1 @kind wide;
  #L4d84e6.  v3.`x1.i0.p` @type ^`boolean` := v0 @kind boolean;
  #L4d84ea.  return @kind void;
}
procedure `x1.f$a` `d`(`x1.i0` v3 @kind this, `x1.f$a` v4 @kind object) @signature `Lx1/i0;.d:(Lx1/f$a;)Lx1/f$a;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4d854c.  v0:= v4.`x1.f$a.c` @type ^`int`;
  #L4d8550.  v1:= 2I;
  #L4d8552.  if v0 != v1 then goto L4d8582;
  #L4d8556.  v0:= v3.`x1.i0.b` @type ^`int`;
  #L4d855a.  v2:= -1I;
  #L4d855c.  if v0 != v2 then goto L4d8564;
  #L4d8560.  v0:= v4.`x1.f$a.a` @type ^`int`;
  #L4d8564.  v3.`x1.i0.e` @type ^`x1.f$a` := v4 @kind object;
  #L4d8568.  v2:= new `x1.f$a`;
  #L4d856c.  v4:= v4.`x1.f$a.b` @type ^`int`;
  #L4d8570.  call `<init>`(v2, v0, v4, v1) @signature `Lx1/f$a;.<init>:(III)V` @kind direct;
  #L4d8576.  v3.`x1.i0.f` @type ^`x1.f$a` := v2 @kind object;
  #L4d857a.  v4:= 1I;
  #L4d857c.  v3.`x1.i0.i` @type ^`boolean` := v4 @kind boolean;
  #L4d8580.  return v2 @kind object;
  #L4d8582.  v0:= new `x1.f$b`;
  #L4d8586.  call `<init>`(v0, v4) @signature `Lx1/f$b;.<init>:(Lx1/f$a;)V` @kind direct;
  #L4d858c.  throw v0;
}
procedure `java.nio.ByteBuffer` `e`(`x1.i0` v6 @kind this) @signature `Lx1/i0;.e:()Ljava/nio/ByteBuffer;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4d81e4.  v0:= v6.`x1.i0.j` @type ^`x1.h0` @kind object;
  #L4d81e8.  if v0 == 0 then goto L4d826e;
  #L4d81ec.  call temp:= `k`(v0) @signature `Lx1/h0;.k:()I` @kind virtual;
  #L4d81f2.  v1:= temp;
  #L4d81f4.  if v1 <= 0 then goto L4d826e;
  #L4d81f8.  v2:= v6.`x1.i0.k` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d81fc.  call temp:= `capacity`(v2) @signature `Ljava/nio/ByteBuffer;.capacity:()I` @kind virtual;
  #L4d8202.  v2:= temp;
  #L4d8204.  if v2 >= v1 then goto L4d8232;
  #L4d8208.  call temp:= `allocateDirect`(v1) @signature `Ljava/nio/ByteBuffer;.allocateDirect:(I)Ljava/nio/ByteBuffer;` @kind static;
  #L4d820e.  v2:= temp @kind object;
  #L4d8210.  call temp:= `nativeOrder`() @signature `Ljava/nio/ByteOrder;.nativeOrder:()Ljava/nio/ByteOrder;` @kind static;
  #L4d8216.  v3:= temp @kind object;
  #L4d8218.  call temp:= `order`(v2, v3) @signature `Ljava/nio/ByteBuffer;.order:(Ljava/nio/ByteOrder;)Ljava/nio/ByteBuffer;` @kind virtual;
  #L4d821e.  v2:= temp @kind object;
  #L4d8220.  v6.`x1.i0.k` @type ^`java.nio.ByteBuffer` := v2 @kind object;
  #L4d8224.  call temp:= `asShortBuffer`(v2) @signature `Ljava/nio/ByteBuffer;.asShortBuffer:()Ljava/nio/ShortBuffer;` @kind virtual;
  #L4d822a.  v2:= temp @kind object;
  #L4d822c.  v6.`x1.i0.l` @type ^`java.nio.ShortBuffer` := v2 @kind object;
  #L4d8230.  goto L4d8246;
  #L4d8232.  v2:= v6.`x1.i0.k` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d8236.  call temp:= `clear`(v2) @signature `Ljava/nio/ByteBuffer;.clear:()Ljava/nio/Buffer;` @kind virtual;
  #L4d823c.  v2:= v6.`x1.i0.l` @type ^`java.nio.ShortBuffer` @kind object;
  #L4d8240.  call temp:= `clear`(v2) @signature `Ljava/nio/ShortBuffer;.clear:()Ljava/nio/Buffer;` @kind virtual;
  #L4d8246.  v2:= v6.`x1.i0.l` @type ^`java.nio.ShortBuffer` @kind object;
  #L4d824a.  call `j`(v0, v2) @signature `Lx1/h0;.j:(Ljava/nio/ShortBuffer;)V` @kind virtual;
  #L4d8250.  v2:= v6.`x1.i0.o` @type ^`long` @kind wide;
  #L4d8254.  v4:= (`long`) v1 @kind i2l;
  #L4d8256.  v2:= v2 + v4 @kind long;
  #L4d8258.  v6.`x1.i0.o` @type ^`long` := v2 @kind wide;
  #L4d825c.  v0:= v6.`x1.i0.k` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d8260.  call temp:= `limit`(v0, v1) @signature `Ljava/nio/ByteBuffer;.limit:(I)Ljava/nio/Buffer;` @kind virtual;
  #L4d8266.  v0:= v6.`x1.i0.k` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d826a.  v6.`x1.i0.m` @type ^`java.nio.ByteBuffer` := v0 @kind object;
  #L4d826e.  v0:= v6.`x1.i0.m` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d8272.  v1:= `@@x1.f.a` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d8276.  v6.`x1.i0.m` @type ^`java.nio.ByteBuffer` := v1 @kind object;
  #L4d827a.  return v0 @kind object;
}
procedure `void` `f`(`x1.i0` v1 @kind this) @signature `Lx1/i0;.f:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d8404.  v0:= v1.`x1.i0.j` @type ^`x1.h0` @kind object;
  #L4d8408.  if v0 == 0 then goto L4d8412;
  #L4d840c.  call `s`(v0) @signature `Lx1/h0;.s:()V` @kind virtual;
  #L4d8412.  v0:= 1I;
  #L4d8414.  v1.`x1.i0.p` @type ^`boolean` := v0 @kind boolean;
  #L4d8418.  return @kind void;
}
procedure `void` `flush`(`x1.i0` v9 @kind this) @signature `Lx1/i0;.flush:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L4d8380.  call temp:= `a`(v9) @signature `Lx1/i0;.a:()Z` @kind virtual;
  #L4d8386.  v0:= temp;
  #L4d8388.  if v0 == 0 then goto L4d83d8;
  #L4d838c.  v0:= v9.`x1.i0.e` @type ^`x1.f$a` @kind object;
  #L4d8390.  v9.`x1.i0.g` @type ^`x1.f$a` := v0 @kind object;
  #L4d8394.  v1:= v9.`x1.i0.f` @type ^`x1.f$a` @kind object;
  #L4d8398.  v9.`x1.i0.h` @type ^`x1.f$a` := v1 @kind object;
  #L4d839c.  v2:= v9.`x1.i0.i` @type ^`boolean` @kind boolean;
  #L4d83a0.  if v2 == 0 then goto L4d83ca;
  #L4d83a4.  v2:= new `x1.h0`;
  #L4d83a8.  v4:= v0.`x1.f$a.a` @type ^`int`;
  #L4d83ac.  v5:= v0.`x1.f$a.b` @type ^`int`;
  #L4d83b0.  v6:= v9.`x1.i0.c` @type ^`float`;
  #L4d83b4.  v7:= v9.`x1.i0.d` @type ^`float`;
  #L4d83b8.  v8:= v1.`x1.f$a.a` @type ^`int`;
  #L4d83bc.  v3:= v2 @kind object;
  #L4d83be.  call `<init>`(v3, v4, v5, v6, v7, v8) @signature `Lx1/h0;.<init>:(IIFFI)V` @kind direct;
  #L4d83c4.  v9.`x1.i0.j` @type ^`x1.h0` := v2 @kind object;
  #L4d83c8.  goto L4d83d8;
  #L4d83ca.  v0:= v9.`x1.i0.j` @type ^`x1.h0` @kind object;
  #L4d83ce.  if v0 == 0 then goto L4d83d8;
  #L4d83d2.  call `i`(v0) @signature `Lx1/h0;.i:()V` @kind virtual;
  #L4d83d8.  v0:= `@@x1.f.a` @type ^`java.nio.ByteBuffer` @kind object;
  #L4d83dc.  v9.`x1.i0.m` @type ^`java.nio.ByteBuffer` := v0 @kind object;
  #L4d83e0.  v0:= 0L;
  #L4d83e4.  v9.`x1.i0.n` @type ^`long` := v0 @kind wide;
  #L4d83e8.  v9.`x1.i0.o` @type ^`long` := v0 @kind wide;
  #L4d83ec.  v0:= 0I;
  #L4d83ee.  v9.`x1.i0.p` @type ^`boolean` := v0 @kind boolean;
  #L4d83f2.  return @kind void;
}
procedure `void` `g`(`x1.i0` v7 @kind this, `java.nio.ByteBuffer` v8 @kind object) @signature `Lx1/i0;.g:(Ljava/nio/ByteBuffer;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L4d842c.  call temp:= `hasRemaining`(v8) @signature `Ljava/nio/ByteBuffer;.hasRemaining:()Z` @kind virtual;
  #L4d8432.  v0:= temp;
  #L4d8434.  if v0 != 0 then goto L4d843a;
  #L4d8438.  return @kind void;
  #L4d843a.  v0:= v7.`x1.i0.j` @type ^`x1.h0` @kind object;
  #L4d843e.  call temp:= `e`(v0) @signature `Ls3/a;.e:(Ljava/lang/Object;)Ljava/lang/Object;` @kind static;
  #L4d8444.  v0:= temp @kind object;
  #L4d8446.  v0:= (`x1.h0`) v0 @kind object;
  #L4d844a.  call temp:= `asShortBuffer`(v8) @signature `Ljava/nio/ByteBuffer;.asShortBuffer:()Ljava/nio/ShortBuffer;` @kind virtual;
  #L4d8450.  v1:= temp @kind object;
  #L4d8452.  call temp:= `remaining`(v8) @signature `Ljava/nio/ByteBuffer;.remaining:()I` @kind virtual;
  #L4d8458.  v2:= temp;
  #L4d845a.  v3:= v7.`x1.i0.n` @type ^`long` @kind wide;
  #L4d845e.  v5:= (`long`) v2 @kind i2l;
  #L4d8460.  v3:= v3 + v5 @kind long;
  #L4d8462.  v7.`x1.i0.n` @type ^`long` := v3 @kind wide;
  #L4d8466.  call `t`(v0, v1) @signature `Lx1/h0;.t:(Ljava/nio/ShortBuffer;)V` @kind virtual;
  #L4d846c.  call temp:= `position`(v8) @signature `Ljava/nio/ByteBuffer;.position:()I` @kind virtual;
  #L4d8472.  v0:= temp;
  #L4d8474.  v0:= v0 + v2 @kind int;
  #L4d8476.  call temp:= `position`(v8, v0) @signature `Ljava/nio/ByteBuffer;.position:(I)Ljava/nio/Buffer;` @kind virtual;
  #L4d847c.  return @kind void;
}
procedure `long` `h`(`x1.i0` v15 @kind this, `long` v16 ) @signature `Lx1/i0;.h:(J)J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;

  #L4d828c.  v0:= v15 @kind object;
  #L4d828e.  v1:= v0.`x1.i0.o` @type ^`long` @kind wide;
  #L4d8292.  v3:= 1024L;
  #L4d8296.  v5:= lcmp(v1, v3);
  #L4d829a.  if v5 < 0 then goto L4d8304;
  #L4d829e.  v1:= v0.`x1.i0.n` @type ^`long` @kind wide;
  #L4d82a2.  v3:= v0.`x1.i0.j` @type ^`x1.h0` @kind object;
  #L4d82a6.  call temp:= `e`(v3) @signature `Ls3/a;.e:(Ljava/lang/Object;)Ljava/lang/Object;` @kind static;
  #L4d82ac.  v3:= temp @kind object;
  #L4d82ae.  v3:= (`x1.h0`) v3 @kind object;
  #L4d82b2.  call temp:= `l`(v3) @signature `Lx1/h0;.l:()I` @kind virtual;
  #L4d82b8.  v3:= temp;
  #L4d82ba.  v3:= (`long`) v3 @kind i2l;
  #L4d82bc.  v7:= v1 - v3 @kind long;
  #L4d82c0.  v1:= v0.`x1.i0.h` @type ^`x1.f$a` @kind object;
  #L4d82c4.  v1:= v1.`x1.f$a.a` @type ^`int`;
  #L4d82c8.  v2:= v0.`x1.i0.g` @type ^`x1.f$a` @kind object;
  #L4d82cc.  v2:= v2.`x1.f$a.a` @type ^`int`;
  #L4d82d0.  if v1 != v2 then goto L4d82e6;
  #L4d82d4.  v9:= v0.`x1.i0.o` @type ^`long` @kind wide;
  #L4d82d8.  v5:= v16 @kind wide;
  #L4d82dc.  call temp:= `M0`(v5, v7, v9) @signature `Ls3/l0;.M0:(JJJ)J` @kind static;
  #L4d82e2.  v1:= temp @kind wide;
  #L4d82e4.  goto L4d8302;
  #L4d82e6.  v3:= (`long`) v1 @kind i2l;
  #L4d82e8.  v11:= v7 * v3 @kind long;
  #L4d82ec.  v3:= v0.`x1.i0.o` @type ^`long` @kind wide;
  #L4d82f0.  v1:= (`long`) v2 @kind i2l;
  #L4d82f2.  v13:= v3 * v1 @kind long;
  #L4d82f6.  v9:= v16 @kind wide;
  #L4d82fa.  call temp:= `M0`(v9, v11, v13) @signature `Ls3/l0;.M0:(JJJ)J` @kind static;
  #L4d8300.  v1:= temp @kind wide;
  #L4d8302.  return v1 @kind wide;
  #L4d8304.  v1:= v0.`x1.i0.c` @type ^`float`;
  #L4d8308.  v1:= (`double`) v1 @kind f2d;
  #L4d830a.  v3:= v16 @kind wide;
  #L4d830e.  v3:= (`double`) v3 @kind l2d;
  #L4d8310.  v1:= v1 * v3 @kind double;
  #L4d8314.  v1:= (`long`) v1 @kind d2l;
  #L4d8316.  return v1 @kind wide;
}
procedure `void` `i`(`x1.i0` v1 @kind this, `float` v2 ) @signature `Lx1/i0;.i:(F)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d84fc.  v0:= v1.`x1.i0.d` @type ^`float`;
  #L4d8500.  v0:= fcmpl(v0, v2);
  #L4d8504.  if v0 == 0 then goto L4d8512;
  #L4d8508.  v1.`x1.i0.d` @type ^`float` := v2;
  #L4d850c.  v2:= 1I;
  #L4d850e.  v1.`x1.i0.i` @type ^`boolean` := v2 @kind boolean;
  #L4d8512.  return @kind void;
}
procedure `void` `j`(`x1.i0` v1 @kind this, `float` v2 ) @signature `Lx1/i0;.j:(F)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d8524.  v0:= v1.`x1.i0.c` @type ^`float`;
  #L4d8528.  v0:= fcmpl(v0, v2);
  #L4d852c.  if v0 == 0 then goto L4d853a;
  #L4d8530.  v1.`x1.i0.c` @type ^`float` := v2;
  #L4d8534.  v2:= 1I;
  #L4d8536.  v1.`x1.i0.i` @type ^`boolean` := v2 @kind boolean;
  #L4d853a.  return @kind void;
}

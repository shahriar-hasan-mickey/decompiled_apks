record `x1.h0` @kind class @AccessFlag FINAL {
  `int` `x1.h0.a` @AccessFlag PRIVATE_FINAL;
  `int` `x1.h0.b` @AccessFlag PRIVATE_FINAL;
  `float` `x1.h0.c` @AccessFlag PRIVATE_FINAL;
  `float` `x1.h0.d` @AccessFlag PRIVATE_FINAL;
  `float` `x1.h0.e` @AccessFlag PRIVATE_FINAL;
  `int` `x1.h0.f` @AccessFlag PRIVATE_FINAL;
  `int` `x1.h0.g` @AccessFlag PRIVATE_FINAL;
  `int` `x1.h0.h` @AccessFlag PRIVATE_FINAL;
  `short`[] `x1.h0.i` @AccessFlag PRIVATE_FINAL;
  `short`[] `x1.h0.j` @AccessFlag PRIVATE;
  `int` `x1.h0.k` @AccessFlag PRIVATE;
  `short`[] `x1.h0.l` @AccessFlag PRIVATE;
  `int` `x1.h0.m` @AccessFlag PRIVATE;
  `short`[] `x1.h0.n` @AccessFlag PRIVATE;
  `int` `x1.h0.o` @AccessFlag PRIVATE;
  `int` `x1.h0.p` @AccessFlag PRIVATE;
  `int` `x1.h0.q` @AccessFlag PRIVATE;
  `int` `x1.h0.r` @AccessFlag PRIVATE;
  `int` `x1.h0.s` @AccessFlag PRIVATE;
  `int` `x1.h0.t` @AccessFlag PRIVATE;
  `int` `x1.h0.u` @AccessFlag PRIVATE;
  `int` `x1.h0.v` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`x1.h0` v0 @kind this, `int` v1 , `int` v2 , `float` v3 , `float` v4 , `int` v5 ) @signature `Lx1/h0;.<init>:(IIFFI)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L4d8974.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L4d897a.  v0.`x1.h0.a` @type ^`int` := v1;
  #L4d897e.  v0.`x1.h0.b` @type ^`int` := v2;
  #L4d8982.  v0.`x1.h0.c` @type ^`float` := v3;
  #L4d8986.  v0.`x1.h0.d` @type ^`float` := v4;
  #L4d898a.  v3:= (`float`) v1 @kind i2f;
  #L4d898c.  v4:= (`float`) v5 @kind i2f;
  #L4d898e.  v3:= v3 / v4 @kind float;
  #L4d8990.  v0.`x1.h0.e` @type ^`float` := v3;
  #L4d8994.  v3:= v1 / 400;
  #L4d8998.  v0.`x1.h0.f` @type ^`int` := v3;
  #L4d899c.  v1:= v1 / 65;
  #L4d89a0.  v0.`x1.h0.g` @type ^`int` := v1;
  #L4d89a4.  v1:= v1 * 2;
  #L4d89a8.  v0.`x1.h0.h` @type ^`int` := v1;
  #L4d89ac.  v3:= new `short`[v1];
  #L4d89b0.  v0.`x1.h0.i` @type ^`short`[] := v3 @kind object;
  #L4d89b4.  v3:= v1 * v2 @kind int;
  #L4d89b8.  v3:= new `short`[v3];
  #L4d89bc.  v0.`x1.h0.j` @type ^`short`[] := v3 @kind object;
  #L4d89c0.  v3:= v1 * v2 @kind int;
  #L4d89c4.  v3:= new `short`[v3];
  #L4d89c8.  v0.`x1.h0.l` @type ^`short`[] := v3 @kind object;
  #L4d89cc.  v1:= v1 * v2 @kind int;
  #L4d89d0.  v1:= new `short`[v1];
  #L4d89d4.  v0.`x1.h0.n` @type ^`short`[] := v1 @kind object;
  #L4d89d8.  return @kind void;
}
procedure `void` `a`(`x1.h0` v8 @kind this, `float` v9 , `int` v10 ) @signature `Lx1/h0;.a:(FI)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L4d89ec.  v0:= v8.`x1.h0.m` @type ^`int`;
  #L4d89f0.  if v0 != v10 then goto L4d89f6;
  #L4d89f4.  return @kind void;
  #L4d89f6.  v0:= v8.`x1.h0.a` @type ^`int`;
  #L4d89fa.  v1:= (`float`) v0 @kind i2f;
  #L4d89fc.  v1:= v1 / v9 @kind float;
  #L4d89fe.  v9:= (`int`) v1 @kind f2i;
  #L4d8a00.  v1:= 16384I;
  #L4d8a04.  if v9 > v1 then goto L4d8ace;
  #L4d8a08.  if v0 <= v1 then goto L4d8a0e;
  #L4d8a0c.  goto L4d8ace;
  #L4d8a0e.  call `o`(v8, v10) @signature `Lx1/h0;.o:(I)V` @kind direct;
  #L4d8a14.  v10:= 0I;
  #L4d8a16.  v1:= 0I;
  #L4d8a18.  v2:= v8.`x1.h0.o` @type ^`int`;
  #L4d8a1c.  v3:= v2 + -1;
  #L4d8a20.  v4:= 1I;
  #L4d8a22.  if v1 >= v3 then goto L4d8ac4;
  #L4d8a26.  v2:= v8.`x1.h0.p` @type ^`int`;
  #L4d8a2a.  v3:= v2 + 1;
  #L4d8a2e.  v3:= v3 * v9 @kind int;
  #L4d8a32.  v5:= v8.`x1.h0.q` @type ^`int`;
  #L4d8a36.  v6:= v5 * v0 @kind int;
  #L4d8a3a.  if v3 <= v6 then goto L4d8a9c;
  #L4d8a3e.  v2:= v8.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8a42.  v3:= v8.`x1.h0.m` @type ^`int`;
  #L4d8a46.  call temp:= `f`(v8, v2, v3, v4) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d8a4c.  v2:= temp @kind object;
  #L4d8a4e.  v8.`x1.h0.l` @type ^`short`[] := v2 @kind object;
  #L4d8a52.  v2:= 0I;
  #L4d8a54.  v3:= v8.`x1.h0.b` @type ^`int`;
  #L4d8a58.  if v2 >= v3 then goto L4d8a86;
  #L4d8a5c.  v5:= v8.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8a60.  v6:= v8.`x1.h0.m` @type ^`int`;
  #L4d8a64.  v6:= v6 * v3 @kind int;
  #L4d8a68.  v6:= v6 + v2 @kind int;
  #L4d8a6a.  v7:= v8.`x1.h0.n` @type ^`short`[] @kind object;
  #L4d8a6e.  v3:= v3 * v1 @kind int;
  #L4d8a72.  v3:= v3 + v2 @kind int;
  #L4d8a74.  call temp:= `n`(v8, v7, v3, v0, v9) @signature `Lx1/h0;.n:([SIII)S` @kind direct;
  #L4d8a7a.  v3:= temp;
  #L4d8a7c.  v5[v6]:= v3 @kind short;
  #L4d8a80.  v2:= v2 + 1;
  #L4d8a84.  goto L4d8a54;
  #L4d8a86.  v2:= v8.`x1.h0.q` @type ^`int`;
  #L4d8a8a.  v2:= v2 + v4 @kind int;
  #L4d8a8c.  v8.`x1.h0.q` @type ^`int` := v2;
  #L4d8a90.  v2:= v8.`x1.h0.m` @type ^`int`;
  #L4d8a94.  v2:= v2 + v4 @kind int;
  #L4d8a96.  v8.`x1.h0.m` @type ^`int` := v2;
  #L4d8a9a.  goto L4d8a26;
  #L4d8a9c.  v2:= v2 + 1;
  #L4d8aa0.  v8.`x1.h0.p` @type ^`int` := v2;
  #L4d8aa4.  if v2 != v0 then goto L4d8abe;
  #L4d8aa8.  v8.`x1.h0.p` @type ^`int` := v10;
  #L4d8aac.  if v5 != v9 then goto L4d8ab2;
  #L4d8ab0.  goto L4d8ab4;
  #L4d8ab2.  v4:= 0I;
  #L4d8ab4.  call `f`(v4) @signature `Ls3/a;.f:(Z)V` @kind static;
  #L4d8aba.  v8.`x1.h0.q` @type ^`int` := v10;
  #L4d8abe.  v1:= v1 + 1;
  #L4d8ac2.  goto L4d8a18;
  #L4d8ac4.  v2:= v2 - v4 @kind int;
  #L4d8ac6.  call `u`(v8, v2) @signature `Lx1/h0;.u:(I)V` @kind direct;
  #L4d8acc.  return @kind void;
  #L4d8ace.  v9:= v9 / 2;
  #L4d8ad2.  v0:= v0 / 2;
  #L4d8ad6.  goto L4d8a00;
}
procedure `void` `b`(`x1.h0` v8 @kind this, `float` v9 ) @signature `Lx1/h0;.b:(F)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L4d8ae8.  v0:= v8.`x1.h0.k` @type ^`int`;
  #L4d8aec.  v1:= v8.`x1.h0.h` @type ^`int`;
  #L4d8af0.  if v0 >= v1 then goto L4d8af6;
  #L4d8af4.  return @kind void;
  #L4d8af6.  v1:= 0I;
  #L4d8af8.  v2:= v8.`x1.h0.r` @type ^`int`;
  #L4d8afc.  if v2 <= 0 then goto L4d8b0c;
  #L4d8b00.  call temp:= `c`(v8, v1) @signature `Lx1/h0;.c:(I)I` @kind direct;
  #L4d8b06.  v2:= temp;
  #L4d8b08.  v1:= v1 + v2 @kind int;
  #L4d8b0a.  goto L4d8b40;
  #L4d8b0c.  v2:= v8.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8b10.  call temp:= `g`(v8, v2, v1) @signature `Lx1/h0;.g:([SI)I` @kind direct;
  #L4d8b16.  v2:= temp;
  #L4d8b18.  v3:= (`double`) v9 @kind f2d;
  #L4d8b1a.  v5:= 1.0D;
  #L4d8b1e.  v7:= dcmpl(v3, v5);
  #L4d8b22.  v3:= v8.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8b26.  if v7 <= 0 then goto L4d8b36;
  #L4d8b2a.  call temp:= `w`(v8, v3, v1, v9, v2) @signature `Lx1/h0;.w:([SIFI)I` @kind direct;
  #L4d8b30.  v3:= temp;
  #L4d8b32.  v2:= v2 + v3 @kind int;
  #L4d8b34.  goto L4d8b08;
  #L4d8b36.  call temp:= `m`(v8, v3, v1, v9, v2) @signature `Lx1/h0;.m:([SIFI)I` @kind direct;
  #L4d8b3c.  v2:= temp;
  #L4d8b3e.  goto L4d8b08;
  #L4d8b40.  v2:= v8.`x1.h0.h` @type ^`int`;
  #L4d8b44.  v2:= v2 + v1 @kind int;
  #L4d8b46.  if v2 <= v0 then goto L4d8af8;
  #L4d8b4a.  call `v`(v8, v1) @signature `Lx1/h0;.v:(I)V` @kind direct;
  #L4d8b50.  return @kind void;
}
procedure `int` `c`(`x1.h0` v2 @kind this, `int` v3 ) @signature `Lx1/h0;.c:(I)I` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;

  #L4d85e4.  v0:= v2.`x1.h0.h` @type ^`int`;
  #L4d85e8.  v1:= v2.`x1.h0.r` @type ^`int`;
  #L4d85ec.  call temp:= `min`(v0, v1) @signature `Ljava/lang/Math;.min:(II)I` @kind static;
  #L4d85f2.  v0:= temp;
  #L4d85f4.  v1:= v2.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d85f8.  call `d`(v2, v1, v3, v0) @signature `Lx1/h0;.d:([SII)V` @kind direct;
  #L4d85fe.  v3:= v2.`x1.h0.r` @type ^`int`;
  #L4d8602.  v3:= v3 - v0 @kind int;
  #L4d8604.  v2.`x1.h0.r` @type ^`int` := v3;
  #L4d8608.  return v0;
}
procedure `void` `d`(`x1.h0` v3 @kind this, `short`[] v4 @kind object, `int` v5 , `int` v6 ) @signature `Lx1/h0;.d:([SII)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;

  #L4d8b64.  v0:= v3.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8b68.  v1:= v3.`x1.h0.m` @type ^`int`;
  #L4d8b6c.  call temp:= `f`(v3, v0, v1, v6) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d8b72.  v0:= temp @kind object;
  #L4d8b74.  v3.`x1.h0.l` @type ^`short`[] := v0 @kind object;
  #L4d8b78.  v1:= v3.`x1.h0.b` @type ^`int`;
  #L4d8b7c.  v5:= v5 * v1 @kind int;
  #L4d8b80.  v2:= v3.`x1.h0.m` @type ^`int`;
  #L4d8b84.  v2:= v2 * v1 @kind int;
  #L4d8b88.  v1:= v1 * v6 @kind int;
  #L4d8b8c.  call `arraycopy`(v4, v5, v0, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4d8b92.  v4:= v3.`x1.h0.m` @type ^`int`;
  #L4d8b96.  v4:= v4 + v6 @kind int;
  #L4d8b98.  v3.`x1.h0.m` @type ^`int` := v4;
  #L4d8b9c.  return @kind void;
}
procedure `void` `e`(`x1.h0` v6 @kind this, `short`[] v7 @kind object, `int` v8 , `int` v9 ) @signature `Lx1/h0;.e:([SII)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4d8bb0.  v0:= v6.`x1.h0.h` @type ^`int`;
  #L4d8bb4.  v0:= v0 / v9 @kind int;
  #L4d8bb6.  v1:= v6.`x1.h0.b` @type ^`int`;
  #L4d8bba.  v9:= v9 * v1 @kind int;
  #L4d8bbe.  v8:= v8 * v1 @kind int;
  #L4d8bc2.  v1:= 0I;
  #L4d8bc4.  v2:= 0I;
  #L4d8bc6.  if v2 >= v0 then goto L4d8bf8;
  #L4d8bca.  v3:= 0I;
  #L4d8bcc.  v4:= 0I;
  #L4d8bce.  if v3 >= v9 then goto L4d8be6;
  #L4d8bd2.  v5:= v2 * v9 @kind int;
  #L4d8bd6.  v5:= v5 + v8 @kind int;
  #L4d8bd8.  v5:= v5 + v3 @kind int;
  #L4d8bda.  v5:= v7[v5] @kind short;
  #L4d8bde.  v4:= v4 + v5 @kind int;
  #L4d8be0.  v3:= v3 + 1;
  #L4d8be4.  goto L4d8bce;
  #L4d8be6.  v4:= v4 / v9 @kind int;
  #L4d8be8.  v3:= v6.`x1.h0.i` @type ^`short`[] @kind object;
  #L4d8bec.  v4:= (`short`) v4 @kind i2s;
  #L4d8bee.  v3[v2]:= v4 @kind short;
  #L4d8bf2.  v2:= v2 + 1;
  #L4d8bf6.  goto L4d8bc6;
  #L4d8bf8.  return @kind void;
}
procedure `short`[] `f`(`x1.h0` v2 @kind this, `short`[] v3 @kind object, `int` v4 , `int` v5 ) @signature `Lx1/h0;.f:([SII)[S` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;

  #L4d893c.  v0:= length @variable v3;
  #L4d893e.  v1:= v2.`x1.h0.b` @type ^`int`;
  #L4d8942.  v0:= v0 / v1 @kind int;
  #L4d8944.  v4:= v4 + v5 @kind int;
  #L4d8946.  if v4 > v0 then goto L4d894c;
  #L4d894a.  return v3 @kind object;
  #L4d894c.  v0:= v0 * 3;
  #L4d8950.  v0:= v0 / 2;
  #L4d8954.  v0:= v0 + v5 @kind int;
  #L4d8956.  v0:= v0 * v1 @kind int;
  #L4d895a.  call temp:= `copyOf`(v3, v0) @signature `Ljava/util/Arrays;.copyOf:([SI)[S` @kind static;
  #L4d8960.  v3:= temp @kind object;
  #L4d8962.  return v3 @kind object;
}
procedure `int` `g`(`x1.h0` v6 @kind this, `short`[] v7 @kind object, `int` v8 ) @signature `Lx1/h0;.g:([SI)I` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4d861c.  v0:= v6.`x1.h0.a` @type ^`int`;
  #L4d8620.  v1:= 4000I;
  #L4d8624.  v2:= 1I;
  #L4d8626.  if v0 <= v1 then goto L4d862e;
  #L4d862a.  v0:= v0 / v1 @kind int;
  #L4d862c.  goto L4d8630;
  #L4d862e.  v0:= 1I;
  #L4d8630.  v1:= v6.`x1.h0.b` @type ^`int`;
  #L4d8634.  if v1 != v2 then goto L4d864e;
  #L4d8638.  if v0 != v2 then goto L4d864e;
  #L4d863c.  v0:= v6.`x1.h0.f` @type ^`int`;
  #L4d8640.  v1:= v6.`x1.h0.g` @type ^`int`;
  #L4d8644.  call temp:= `h`(v6, v7, v8, v0, v1) @signature `Lx1/h0;.h:([SIII)I` @kind direct;
  #L4d864a.  v7:= temp;
  #L4d864c.  goto L4d86bc;
  #L4d864e.  call `e`(v6, v7, v8, v0) @signature `Lx1/h0;.e:([SII)V` @kind direct;
  #L4d8654.  v1:= v6.`x1.h0.i` @type ^`short`[] @kind object;
  #L4d8658.  v3:= v6.`x1.h0.f` @type ^`int`;
  #L4d865c.  v3:= v3 / v0 @kind int;
  #L4d865e.  v4:= v6.`x1.h0.g` @type ^`int`;
  #L4d8662.  v4:= v4 / v0 @kind int;
  #L4d8664.  v5:= 0I;
  #L4d8666.  call temp:= `h`(v6, v1, v5, v3, v4) @signature `Lx1/h0;.h:([SIII)I` @kind direct;
  #L4d866c.  v1:= temp;
  #L4d866e.  if v0 == v2 then goto L4d86ba;
  #L4d8672.  v1:= v1 * v0 @kind int;
  #L4d8676.  v0:= v0 * 4;
  #L4d867a.  v3:= v1 - v0 @kind int;
  #L4d867e.  v1:= v1 + v0 @kind int;
  #L4d8680.  v0:= v6.`x1.h0.f` @type ^`int`;
  #L4d8684.  if v3 >= v0 then goto L4d868a;
  #L4d8688.  v3:= v0;
  #L4d868a.  v0:= v6.`x1.h0.g` @type ^`int`;
  #L4d868e.  if v1 <= v0 then goto L4d8694;
  #L4d8692.  v1:= v0;
  #L4d8694.  v0:= v6.`x1.h0.b` @type ^`int`;
  #L4d8698.  if v0 != v2 then goto L4d86a6;
  #L4d869c.  call temp:= `h`(v6, v7, v8, v3, v1) @signature `Lx1/h0;.h:([SIII)I` @kind direct;
  #L4d86a2.  v7:= temp;
  #L4d86a4.  goto L4d86bc;
  #L4d86a6.  call `e`(v6, v7, v8, v2) @signature `Lx1/h0;.e:([SII)V` @kind direct;
  #L4d86ac.  v7:= v6.`x1.h0.i` @type ^`short`[] @kind object;
  #L4d86b0.  call temp:= `h`(v6, v7, v5, v3, v1) @signature `Lx1/h0;.h:([SIII)I` @kind direct;
  #L4d86b6.  v7:= temp;
  #L4d86b8.  goto L4d86bc;
  #L4d86ba.  v7:= v1;
  #L4d86bc.  v8:= v6.`x1.h0.u` @type ^`int`;
  #L4d86c0.  v0:= v6.`x1.h0.v` @type ^`int`;
  #L4d86c4.  call temp:= `q`(v6, v8, v0) @signature `Lx1/h0;.q:(II)Z` @kind direct;
  #L4d86ca.  v8:= temp;
  #L4d86cc.  if v8 == 0 then goto L4d86d6;
  #L4d86d0.  v8:= v6.`x1.h0.s` @type ^`int`;
  #L4d86d4.  goto L4d86d8;
  #L4d86d6.  v8:= v7;
  #L4d86d8.  v0:= v6.`x1.h0.u` @type ^`int`;
  #L4d86dc.  v6.`x1.h0.t` @type ^`int` := v0;
  #L4d86e0.  v6.`x1.h0.s` @type ^`int` := v7;
  #L4d86e4.  return v8;
}
procedure `int` `h`(`x1.h0` v9 @kind this, `short`[] v10 @kind object, `int` v11 , `int` v12 , `int` v13 ) @signature `Lx1/h0;.h:([SIII)I` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L4d86f8.  v0:= v9.`x1.h0.b` @type ^`int`;
  #L4d86fc.  v11:= v11 * v0 @kind int;
  #L4d8700.  v0:= 1I;
  #L4d8702.  v1:= 0I;
  #L4d8704.  v2:= 255I;
  #L4d8708.  v3:= 0I;
  #L4d870a.  v4:= 0I;
  #L4d870c.  if v12 > v13 then goto L4d8762;
  #L4d8710.  v5:= 0I;
  #L4d8712.  v6:= 0I;
  #L4d8714.  if v5 >= v12 then goto L4d873c;
  #L4d8718.  v7:= v11 + v5 @kind int;
  #L4d871c.  v7:= v10[v7] @kind short;
  #L4d8720.  v8:= v11 + v12 @kind int;
  #L4d8724.  v8:= v8 + v5 @kind int;
  #L4d8726.  v8:= v10[v8] @kind short;
  #L4d872a.  v7:= v7 - v8 @kind int;
  #L4d872c.  call temp:= `abs`(v7) @signature `Ljava/lang/Math;.abs:(I)I` @kind static;
  #L4d8732.  v7:= temp;
  #L4d8734.  v6:= v6 + v7 @kind int;
  #L4d8736.  v5:= v5 + 1;
  #L4d873a.  goto L4d8714;
  #L4d873c.  v5:= v6 * v3 @kind int;
  #L4d8740.  v7:= v0 * v12 @kind int;
  #L4d8744.  if v5 >= v7 then goto L4d874c;
  #L4d8748.  v3:= v12;
  #L4d874a.  v0:= v6;
  #L4d874c.  v5:= v6 * v2 @kind int;
  #L4d8750.  v7:= v4 * v12 @kind int;
  #L4d8754.  if v5 <= v7 then goto L4d875c;
  #L4d8758.  v2:= v12;
  #L4d875a.  v4:= v6;
  #L4d875c.  v12:= v12 + 1;
  #L4d8760.  goto L4d870c;
  #L4d8762.  v0:= v0 / v3 @kind int;
  #L4d8764.  v9.`x1.h0.u` @type ^`int` := v0;
  #L4d8768.  v4:= v4 / v2 @kind int;
  #L4d876a.  v9.`x1.h0.v` @type ^`int` := v4;
  #L4d876e.  return v3;
}
procedure `int` `m`(`x1.h0` v9 @kind this, `short`[] v10 @kind object, `int` v11 , `float` v12 , `int` v13 ) @signature `Lx1/h0;.m:([SIFI)I` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L4d87c8.  v0:= 1.0F;
  #L4d87cc.  v1:= 0.5F;
  #L4d87d0.  v1:= fcmpg(v12, v1);
  #L4d87d4.  if v1 >= 0 then goto L4d87e6;
  #L4d87d8.  v1:= (`float`) v13 @kind i2f;
  #L4d87da.  v1:= v1 * v12 @kind float;
  #L4d87de.  v0:= v0 - v12 @kind float;
  #L4d87e0.  v1:= v1 / v0 @kind float;
  #L4d87e2.  v12:= (`int`) v1 @kind f2i;
  #L4d87e4.  goto L4d8802;
  #L4d87e6.  v1:= (`float`) v13 @kind i2f;
  #L4d87e8.  v2:= 2.0F;
  #L4d87ec.  v2:= v2 * v12 @kind float;
  #L4d87f0.  v2:= v2 - v0 @kind float;
  #L4d87f2.  v1:= v1 * v2 @kind float;
  #L4d87f6.  v0:= v0 - v12 @kind float;
  #L4d87f8.  v1:= v1 / v0 @kind float;
  #L4d87fa.  v12:= (`int`) v1 @kind f2i;
  #L4d87fc.  v9.`x1.h0.r` @type ^`int` := v12;
  #L4d8800.  v12:= v13;
  #L4d8802.  v0:= v9.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8806.  v1:= v9.`x1.h0.m` @type ^`int`;
  #L4d880a.  v8:= v13 + v12 @kind int;
  #L4d880e.  call temp:= `f`(v9, v0, v1, v8) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d8814.  v0:= temp @kind object;
  #L4d8816.  v9.`x1.h0.l` @type ^`short`[] := v0 @kind object;
  #L4d881a.  v1:= v9.`x1.h0.b` @type ^`int`;
  #L4d881e.  v2:= v11 * v1 @kind int;
  #L4d8822.  v3:= v9.`x1.h0.m` @type ^`int`;
  #L4d8826.  v3:= v3 * v1 @kind int;
  #L4d882a.  v1:= v1 * v13 @kind int;
  #L4d882e.  call `arraycopy`(v10, v2, v0, v3, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4d8834.  v1:= v9.`x1.h0.b` @type ^`int`;
  #L4d8838.  v2:= v9.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d883c.  v0:= v9.`x1.h0.m` @type ^`int`;
  #L4d8840.  v3:= v0 + v13 @kind int;
  #L4d8844.  v5:= v11 + v13 @kind int;
  #L4d8848.  v0:= v12;
  #L4d884a.  v4:= v10 @kind object;
  #L4d884c.  v6:= v10 @kind object;
  #L4d884e.  v7:= v11;
  #L4d8850.  call `p`(v0, v1, v2, v3, v4, v5, v6, v7) @signature `Lx1/h0;.p:(II[SI[SI[SI)V` @kind static;
  #L4d8856.  v10:= v9.`x1.h0.m` @type ^`int`;
  #L4d885a.  v10:= v10 + v8 @kind int;
  #L4d885c.  v9.`x1.h0.m` @type ^`int` := v10;
  #L4d8860.  return v12;
}
procedure `short` `n`(`x1.h0` v2 @kind this, `short`[] v3 @kind object, `int` v4 , `int` v5 , `int` v6 ) @signature `Lx1/h0;.n:([SIII)S` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;

  #L4d88ec.  v0:= v3[v4] @kind short;
  #L4d88f0.  v1:= v2.`x1.h0.b` @type ^`int`;
  #L4d88f4.  v4:= v4 + v1 @kind int;
  #L4d88f6.  v3:= v3[v4] @kind short;
  #L4d88fa.  v4:= v2.`x1.h0.q` @type ^`int`;
  #L4d88fe.  v4:= v4 * v5 @kind int;
  #L4d8902.  v5:= v2.`x1.h0.p` @type ^`int`;
  #L4d8906.  v1:= v5 * v6 @kind int;
  #L4d890a.  v5:= v5 + 1;
  #L4d890e.  v5:= v5 * v6 @kind int;
  #L4d8912.  v4:= v5 - v4 @kind int;
  #L4d8916.  v5:= v5 - v1 @kind int;
  #L4d8918.  v0:= v0 * v4 @kind int;
  #L4d891c.  v4:= v5 - v4 @kind int;
  #L4d8920.  v4:= v4 * v3 @kind int;
  #L4d8924.  v0:= v0 + v4 @kind int;
  #L4d8926.  v0:= v0 / v5 @kind int;
  #L4d8928.  v3:= (`short`) v0 @kind i2s;
  #L4d892a.  return v3;
}
procedure `void` `o`(`x1.h0` v6 @kind this, `int` v7 ) @signature `Lx1/h0;.o:(I)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4d8ca8.  v0:= v6.`x1.h0.m` @type ^`int`;
  #L4d8cac.  v0:= v0 - v7 @kind int;
  #L4d8cae.  v1:= v6.`x1.h0.n` @type ^`short`[] @kind object;
  #L4d8cb2.  v2:= v6.`x1.h0.o` @type ^`int`;
  #L4d8cb6.  call temp:= `f`(v6, v1, v2, v0) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d8cbc.  v1:= temp @kind object;
  #L4d8cbe.  v6.`x1.h0.n` @type ^`short`[] := v1 @kind object;
  #L4d8cc2.  v2:= v6.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8cc6.  v3:= v6.`x1.h0.b` @type ^`int`;
  #L4d8cca.  v4:= v7 * v3 @kind int;
  #L4d8cce.  v5:= v6.`x1.h0.o` @type ^`int`;
  #L4d8cd2.  v5:= v5 * v3 @kind int;
  #L4d8cd6.  v3:= v3 * v0 @kind int;
  #L4d8cda.  call `arraycopy`(v2, v4, v1, v5, v3) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4d8ce0.  v6.`x1.h0.m` @type ^`int` := v7;
  #L4d8ce4.  v7:= v6.`x1.h0.o` @type ^`int`;
  #L4d8ce8.  v7:= v7 + v0 @kind int;
  #L4d8cea.  v6.`x1.h0.o` @type ^`int` := v7;
  #L4d8cee.  return @kind void;
}
procedure `void` `p`(`int` v8 , `int` v9 , `short`[] v10 @kind object, `int` v11 , `short`[] v12 @kind object, `int` v13 , `short`[] v14 @kind object, `int` v15 ) @signature `Lx1/h0;.p:(II[SI[SI[SI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L4d8d00.  v0:= 0I;
  #L4d8d02.  v1:= 0I;
  #L4d8d04.  if v1 >= v9 then goto L4d8d50;
  #L4d8d08.  v2:= v11 * v9 @kind int;
  #L4d8d0c.  v2:= v2 + v1 @kind int;
  #L4d8d0e.  v3:= v15 * v9 @kind int;
  #L4d8d12.  v3:= v3 + v1 @kind int;
  #L4d8d14.  v4:= v13 * v9 @kind int;
  #L4d8d18.  v4:= v4 + v1 @kind int;
  #L4d8d1a.  v5:= 0I;
  #L4d8d1c.  if v5 >= v8 then goto L4d8d4a;
  #L4d8d20.  v6:= v12[v4] @kind short;
  #L4d8d24.  v7:= v8 - v5 @kind int;
  #L4d8d28.  v6:= v6 * v7 @kind int;
  #L4d8d2c.  v7:= v14[v3] @kind short;
  #L4d8d30.  v7:= v7 * v5 @kind int;
  #L4d8d34.  v6:= v6 + v7 @kind int;
  #L4d8d36.  v6:= v6 / v8 @kind int;
  #L4d8d38.  v6:= (`short`) v6 @kind i2s;
  #L4d8d3a.  v10[v2]:= v6 @kind short;
  #L4d8d3e.  v2:= v2 + v9 @kind int;
  #L4d8d40.  v4:= v4 + v9 @kind int;
  #L4d8d42.  v3:= v3 + v9 @kind int;
  #L4d8d44.  v5:= v5 + 1;
  #L4d8d48.  goto L4d8d1c;
  #L4d8d4a.  v1:= v1 + 1;
  #L4d8d4e.  goto L4d8d04;
  #L4d8d50.  return @kind void;
}
procedure `boolean` `q`(`x1.h0` v2 @kind this, `int` v3 , `int` v4 ) @signature `Lx1/h0;.q:(II)Z` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;

  #L4d85a0.  v0:= 0I;
  #L4d85a2.  if v3 == 0 then goto L4d85d0;
  #L4d85a6.  v1:= v2.`x1.h0.s` @type ^`int`;
  #L4d85aa.  if v1 != 0 then goto L4d85b0;
  #L4d85ae.  goto L4d85d0;
  #L4d85b0.  v1:= v3 * 3;
  #L4d85b4.  if v4 <= v1 then goto L4d85ba;
  #L4d85b8.  return v0;
  #L4d85ba.  v3:= v3 * 2;
  #L4d85be.  v4:= v2.`x1.h0.t` @type ^`int`;
  #L4d85c2.  v4:= v4 * 3;
  #L4d85c6.  if v3 > v4 then goto L4d85cc;
  #L4d85ca.  return v0;
  #L4d85cc.  v3:= 1I;
  #L4d85ce.  return v3;
  #L4d85d0.  return v0;
}
procedure `void` `r`(`x1.h0` v8 @kind this) @signature `Lx1/h0;.r:()V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L4d8d64.  v0:= v8.`x1.h0.m` @type ^`int`;
  #L4d8d68.  v1:= v8.`x1.h0.c` @type ^`float`;
  #L4d8d6c.  v2:= v8.`x1.h0.d` @type ^`float`;
  #L4d8d70.  v1:= v1 / v2 @kind float;
  #L4d8d72.  v3:= v8.`x1.h0.e` @type ^`float`;
  #L4d8d76.  v3:= v3 * v2 @kind float;
  #L4d8d7a.  v4:= (`double`) v1 @kind f2d;
  #L4d8d7c.  v6:= 1.00001D;
  #L4d8d86.  v2:= dcmpl(v4, v6);
  #L4d8d8a.  if v2 > 0 then goto L4d8db8;
  #L4d8d8e.  v6:= 0.99999D;
  #L4d8d98.  v2:= dcmpg(v4, v6);
  #L4d8d9c.  if v2 >= 0 then goto L4d8da2;
  #L4d8da0.  goto L4d8db8;
  #L4d8da2.  v1:= v8.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8da6.  v2:= v8.`x1.h0.k` @type ^`int`;
  #L4d8daa.  v4:= 0I;
  #L4d8dac.  call `d`(v8, v1, v4, v2) @signature `Lx1/h0;.d:([SII)V` @kind direct;
  #L4d8db2.  v8.`x1.h0.k` @type ^`int` := v4;
  #L4d8db6.  goto L4d8dbe;
  #L4d8db8.  call `b`(v8, v1) @signature `Lx1/h0;.b:(F)V` @kind direct;
  #L4d8dbe.  v1:= 1.0F;
  #L4d8dc2.  v1:= fcmpl(v3, v1);
  #L4d8dc6.  if v1 == 0 then goto L4d8dd0;
  #L4d8dca.  call `a`(v8, v3, v0) @signature `Lx1/h0;.a:(FI)V` @kind direct;
  #L4d8dd0.  return @kind void;
}
procedure `void` `u`(`x1.h0` v5 @kind this, `int` v6 ) @signature `Lx1/h0;.u:(I)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L4d8f00.  if v6 != 0 then goto L4d8f06;
  #L4d8f04.  return @kind void;
  #L4d8f06.  v0:= v5.`x1.h0.n` @type ^`short`[] @kind object;
  #L4d8f0a.  v1:= v5.`x1.h0.b` @type ^`int`;
  #L4d8f0e.  v2:= v6 * v1 @kind int;
  #L4d8f12.  v3:= 0I;
  #L4d8f14.  v4:= v5.`x1.h0.o` @type ^`int`;
  #L4d8f18.  v4:= v4 - v6 @kind int;
  #L4d8f1a.  v4:= v4 * v1 @kind int;
  #L4d8f1e.  call `arraycopy`(v0, v2, v0, v3, v4) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4d8f24.  v0:= v5.`x1.h0.o` @type ^`int`;
  #L4d8f28.  v0:= v0 - v6 @kind int;
  #L4d8f2a.  v5.`x1.h0.o` @type ^`int` := v0;
  #L4d8f2e.  return @kind void;
}
procedure `void` `v`(`x1.h0` v4 @kind this, `int` v5 ) @signature `Lx1/h0;.v:(I)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4d8f40.  v0:= v4.`x1.h0.k` @type ^`int`;
  #L4d8f44.  v0:= v0 - v5 @kind int;
  #L4d8f46.  v1:= v4.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8f4a.  v2:= v4.`x1.h0.b` @type ^`int`;
  #L4d8f4e.  v5:= v5 * v2 @kind int;
  #L4d8f52.  v2:= v2 * v0 @kind int;
  #L4d8f56.  v3:= 0I;
  #L4d8f58.  call `arraycopy`(v1, v5, v1, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4d8f5e.  v4.`x1.h0.k` @type ^`int` := v0;
  #L4d8f62.  return @kind void;
}
procedure `int` `w`(`x1.h0` v8 @kind this, `short`[] v9 @kind object, `int` v10 , `float` v11 , `int` v12 ) @signature `Lx1/h0;.w:([SIFI)I` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L4d8874.  v0:= 1.0F;
  #L4d8878.  v1:= 2.0F;
  #L4d887c.  v2:= fcmpl(v11, v1);
  #L4d8880.  if v2 < 0 then goto L4d888e;
  #L4d8884.  v1:= (`float`) v12 @kind i2f;
  #L4d8886.  v11:= v11 - v0 @kind float;
  #L4d8888.  v1:= v1 / v11 @kind float;
  #L4d888a.  v11:= (`int`) v1 @kind f2i;
  #L4d888c.  goto L4d88a2;
  #L4d888e.  v2:= (`float`) v12 @kind i2f;
  #L4d8890.  v1:= v1 - v11 @kind float;
  #L4d8892.  v2:= v2 * v1 @kind float;
  #L4d8896.  v11:= v11 - v0 @kind float;
  #L4d8898.  v2:= v2 / v11 @kind float;
  #L4d889a.  v11:= (`int`) v2 @kind f2i;
  #L4d889c.  v8.`x1.h0.r` @type ^`int` := v11;
  #L4d88a0.  v11:= v12;
  #L4d88a2.  v0:= v8.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d88a6.  v1:= v8.`x1.h0.m` @type ^`int`;
  #L4d88aa.  call temp:= `f`(v8, v0, v1, v11) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d88b0.  v2:= temp @kind object;
  #L4d88b2.  v8.`x1.h0.l` @type ^`short`[] := v2 @kind object;
  #L4d88b6.  v1:= v8.`x1.h0.b` @type ^`int`;
  #L4d88ba.  v3:= v8.`x1.h0.m` @type ^`int`;
  #L4d88be.  v7:= v10 + v12 @kind int;
  #L4d88c2.  v0:= v11;
  #L4d88c4.  v4:= v9 @kind object;
  #L4d88c6.  v5:= v10;
  #L4d88c8.  v6:= v9 @kind object;
  #L4d88ca.  call `p`(v0, v1, v2, v3, v4, v5, v6, v7) @signature `Lx1/h0;.p:(II[SI[SI[SI)V` @kind static;
  #L4d88d0.  v9:= v8.`x1.h0.m` @type ^`int`;
  #L4d88d4.  v9:= v9 + v11 @kind int;
  #L4d88d6.  v8.`x1.h0.m` @type ^`int` := v9;
  #L4d88da.  return v11;
}
procedure `void` `i`(`x1.h0` v1 @kind this) @signature `Lx1/h0;.i:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d8c0c.  v0:= 0I;
  #L4d8c0e.  v1.`x1.h0.k` @type ^`int` := v0;
  #L4d8c12.  v1.`x1.h0.m` @type ^`int` := v0;
  #L4d8c16.  v1.`x1.h0.o` @type ^`int` := v0;
  #L4d8c1a.  v1.`x1.h0.p` @type ^`int` := v0;
  #L4d8c1e.  v1.`x1.h0.q` @type ^`int` := v0;
  #L4d8c22.  v1.`x1.h0.r` @type ^`int` := v0;
  #L4d8c26.  v1.`x1.h0.s` @type ^`int` := v0;
  #L4d8c2a.  v1.`x1.h0.t` @type ^`int` := v0;
  #L4d8c2e.  v1.`x1.h0.u` @type ^`int` := v0;
  #L4d8c32.  v1.`x1.h0.v` @type ^`int` := v0;
  #L4d8c36.  return @kind void;
}
procedure `void` `j`(`x1.h0` v4 @kind this, `java.nio.ShortBuffer` v5 @kind object) @signature `Lx1/h0;.j:(Ljava/nio/ShortBuffer;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4d8c48.  call temp:= `remaining`(v5) @signature `Ljava/nio/ShortBuffer;.remaining:()I` @kind virtual;
  #L4d8c4e.  v0:= temp;
  #L4d8c50.  v1:= v4.`x1.h0.b` @type ^`int`;
  #L4d8c54.  v0:= v0 / v1 @kind int;
  #L4d8c56.  v1:= v4.`x1.h0.m` @type ^`int`;
  #L4d8c5a.  call temp:= `min`(v0, v1) @signature `Ljava/lang/Math;.min:(II)I` @kind static;
  #L4d8c60.  v0:= temp;
  #L4d8c62.  v1:= v4.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8c66.  v2:= v4.`x1.h0.b` @type ^`int`;
  #L4d8c6a.  v2:= v2 * v0 @kind int;
  #L4d8c6e.  v3:= 0I;
  #L4d8c70.  call temp:= `put`(v5, v1, v3, v2) @signature `Ljava/nio/ShortBuffer;.put:([SII)Ljava/nio/ShortBuffer;` @kind virtual;
  #L4d8c76.  v5:= v4.`x1.h0.m` @type ^`int`;
  #L4d8c7a.  v5:= v5 - v0 @kind int;
  #L4d8c7c.  v4.`x1.h0.m` @type ^`int` := v5;
  #L4d8c80.  v1:= v4.`x1.h0.l` @type ^`short`[] @kind object;
  #L4d8c84.  v2:= v4.`x1.h0.b` @type ^`int`;
  #L4d8c88.  v0:= v0 * v2 @kind int;
  #L4d8c8c.  v5:= v5 * v2 @kind int;
  #L4d8c90.  call `arraycopy`(v1, v0, v1, v3, v5) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4d8c96.  return @kind void;
}
procedure `int` `k`(`x1.h0` v2 @kind this) @signature `Lx1/h0;.k:()I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4d8780.  v0:= v2.`x1.h0.m` @type ^`int`;
  #L4d8784.  v1:= v2.`x1.h0.b` @type ^`int`;
  #L4d8788.  v0:= v0 * v1 @kind int;
  #L4d878c.  v0:= v0 * 2;
  #L4d8790.  return v0;
}
procedure `int` `l`(`x1.h0` v2 @kind this) @signature `Lx1/h0;.l:()I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4d87a4.  v0:= v2.`x1.h0.k` @type ^`int`;
  #L4d87a8.  v1:= v2.`x1.h0.b` @type ^`int`;
  #L4d87ac.  v0:= v0 * v1 @kind int;
  #L4d87b0.  v0:= v0 * 2;
  #L4d87b4.  return v0;
}
procedure `void` `s`(`x1.h0` v7 @kind this) @signature `Lx1/h0;.s:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L4d8de4.  v0:= v7.`x1.h0.k` @type ^`int`;
  #L4d8de8.  v1:= v7.`x1.h0.c` @type ^`float`;
  #L4d8dec.  v2:= v7.`x1.h0.d` @type ^`float`;
  #L4d8df0.  v1:= v1 / v2 @kind float;
  #L4d8df2.  v3:= v7.`x1.h0.e` @type ^`float`;
  #L4d8df6.  v3:= v3 * v2 @kind float;
  #L4d8dfa.  v2:= v7.`x1.h0.m` @type ^`int`;
  #L4d8dfe.  v4:= (`float`) v0 @kind i2f;
  #L4d8e00.  v4:= v4 / v1 @kind float;
  #L4d8e02.  v1:= v7.`x1.h0.o` @type ^`int`;
  #L4d8e06.  v1:= (`float`) v1 @kind i2f;
  #L4d8e08.  v4:= v4 + v1 @kind float;
  #L4d8e0a.  v4:= v4 / v3 @kind float;
  #L4d8e0c.  v1:= 0.5F;
  #L4d8e10.  v4:= v4 + v1 @kind float;
  #L4d8e12.  v1:= (`int`) v4 @kind f2i;
  #L4d8e14.  v2:= v2 + v1 @kind int;
  #L4d8e16.  v1:= v7.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8e1a.  v3:= v7.`x1.h0.h` @type ^`int`;
  #L4d8e1e.  v3:= v3 * 2;
  #L4d8e22.  v3:= v3 + v0 @kind int;
  #L4d8e24.  call temp:= `f`(v7, v1, v0, v3) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d8e2a.  v1:= temp @kind object;
  #L4d8e2c.  v7.`x1.h0.j` @type ^`short`[] := v1 @kind object;
  #L4d8e30.  v1:= 0I;
  #L4d8e32.  v3:= 0I;
  #L4d8e34.  v4:= v7.`x1.h0.h` @type ^`int`;
  #L4d8e38.  v5:= v4 * 2;
  #L4d8e3c.  v6:= v7.`x1.h0.b` @type ^`int`;
  #L4d8e40.  v5:= v5 * v6 @kind int;
  #L4d8e44.  if v3 >= v5 then goto L4d8e5c;
  #L4d8e48.  v4:= v7.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8e4c.  v6:= v6 * v0 @kind int;
  #L4d8e50.  v6:= v6 + v3 @kind int;
  #L4d8e52.  v4[v6]:= v1 @kind short;
  #L4d8e56.  v3:= v3 + 1;
  #L4d8e5a.  goto L4d8e34;
  #L4d8e5c.  v0:= v7.`x1.h0.k` @type ^`int`;
  #L4d8e60.  v4:= v4 * 2;
  #L4d8e64.  v0:= v0 + v4 @kind int;
  #L4d8e66.  v7.`x1.h0.k` @type ^`int` := v0;
  #L4d8e6a.  call `r`(v7) @signature `Lx1/h0;.r:()V` @kind direct;
  #L4d8e70.  v0:= v7.`x1.h0.m` @type ^`int`;
  #L4d8e74.  if v0 <= v2 then goto L4d8e7c;
  #L4d8e78.  v7.`x1.h0.m` @type ^`int` := v2;
  #L4d8e7c.  v7.`x1.h0.k` @type ^`int` := v1;
  #L4d8e80.  v7.`x1.h0.r` @type ^`int` := v1;
  #L4d8e84.  v7.`x1.h0.o` @type ^`int` := v1;
  #L4d8e88.  return @kind void;
}
procedure `void` `t`(`x1.h0` v5 @kind this, `java.nio.ShortBuffer` v6 @kind object) @signature `Lx1/h0;.t:(Ljava/nio/ShortBuffer;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L4d8e9c.  call temp:= `remaining`(v6) @signature `Ljava/nio/ShortBuffer;.remaining:()I` @kind virtual;
  #L4d8ea2.  v0:= temp;
  #L4d8ea4.  v1:= v5.`x1.h0.b` @type ^`int`;
  #L4d8ea8.  v0:= v0 / v1 @kind int;
  #L4d8eaa.  v1:= v1 * v0 @kind int;
  #L4d8eae.  v1:= v1 * 2;
  #L4d8eb2.  v2:= v5.`x1.h0.j` @type ^`short`[] @kind object;
  #L4d8eb6.  v3:= v5.`x1.h0.k` @type ^`int`;
  #L4d8eba.  call temp:= `f`(v5, v2, v3, v0) @signature `Lx1/h0;.f:([SII)[S` @kind direct;
  #L4d8ec0.  v2:= temp @kind object;
  #L4d8ec2.  v5.`x1.h0.j` @type ^`short`[] := v2 @kind object;
  #L4d8ec6.  v3:= v5.`x1.h0.k` @type ^`int`;
  #L4d8eca.  v4:= v5.`x1.h0.b` @type ^`int`;
  #L4d8ece.  v3:= v3 * v4 @kind int;
  #L4d8ed2.  v1:= v1 / 2;
  #L4d8ed6.  call temp:= `get`(v6, v2, v3, v1) @signature `Ljava/nio/ShortBuffer;.get:([SII)Ljava/nio/ShortBuffer;` @kind virtual;
  #L4d8edc.  v6:= v5.`x1.h0.k` @type ^`int`;
  #L4d8ee0.  v6:= v6 + v0 @kind int;
  #L4d8ee2.  v5.`x1.h0.k` @type ^`int` := v6;
  #L4d8ee6.  call `r`(v5) @signature `Lx1/h0;.r:()V` @kind direct;
  #L4d8eec.  return @kind void;
}

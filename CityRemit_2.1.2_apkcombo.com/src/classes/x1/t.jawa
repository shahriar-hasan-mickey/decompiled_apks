record `x1.t` @kind class @AccessFlag FINAL {
  `x1.t$a` `x1.t.a` @AccessFlag PRIVATE_FINAL;
  `int` `x1.t.b` @AccessFlag PRIVATE;
  `long` `x1.t.c` @AccessFlag PRIVATE;
  `long` `x1.t.d` @AccessFlag PRIVATE;
  `long` `x1.t.e` @AccessFlag PRIVATE;
  `long` `x1.t.f` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`x1.t` v2 @kind this, `android.media.AudioTrack` v3 @kind object) @signature `Lx1/t;.<init>:(Landroid/media/AudioTrack;)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L4d1d54.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L4d1d5a.  v0:= `@@s3.l0.a` @type ^`int`;
  #L4d1d5e.  v1:= 19I;
  #L4d1d62.  if v0 < v1 then goto L4d1d7c;
  #L4d1d66.  v0:= new `x1.t$a`;
  #L4d1d6a.  call `<init>`(v0, v3) @signature `Lx1/t$a;.<init>:(Landroid/media/AudioTrack;)V` @kind direct;
  #L4d1d70.  v2.`x1.t.a` @type ^`x1.t$a` := v0 @kind object;
  #L4d1d74.  call `g`(v2) @signature `Lx1/t;.g:()V` @kind virtual;
  #L4d1d7a.  goto L4d1d8a;
  #L4d1d7c.  v3:= 0I;
  #L4d1d7e.  v2.`x1.t.a` @type ^`x1.t$a` := v3 @kind object;
  #L4d1d82.  v3:= 3I;
  #L4d1d84.  call `h`(v2, v3) @signature `Lx1/t;.h:(I)V` @kind direct;
  #L4d1d8a.  return @kind void;
}
procedure `void` `h`(`x1.t` v6 @kind this, `int` v7 ) @signature `Lx1/t;.h:(I)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4d1e00.  v6.`x1.t.b` @type ^`int` := v7;
  #L4d1e04.  v0:= 10000L;
  #L4d1e08.  if v7 == 0 then goto L4d1e40;
  #L4d1e0c.  v2:= 1I;
  #L4d1e0e.  if v7 == v2 then goto L4d1e62;
  #L4d1e12.  v0:= 2I;
  #L4d1e14.  if v7 == v0 then goto L4d1e38;
  #L4d1e18.  v0:= 3I;
  #L4d1e1a.  if v7 == v0 then goto L4d1e38;
  #L4d1e1e.  v0:= 4I;
  #L4d1e20.  if v7 != v0 then goto L4d1e2c;
  #L4d1e24.  v0:= 500000L;
  #L4d1e2a.  goto L4d1e62;
  #L4d1e2c.  v7:= new `java.lang.IllegalStateException`;
  #L4d1e30.  call `<init>`(v7) @signature `Ljava/lang/IllegalStateException;.<init>:()V` @kind direct;
  #L4d1e36.  throw v7;
  #L4d1e38.  v0:= 10000000L;
  #L4d1e3e.  goto L4d1e62;
  #L4d1e40.  v2:= 0L;
  #L4d1e44.  v6.`x1.t.e` @type ^`long` := v2 @kind wide;
  #L4d1e48.  v2:= -1L;
  #L4d1e4c.  v6.`x1.t.f` @type ^`long` := v2 @kind wide;
  #L4d1e50.  call temp:= `nanoTime`() @signature `Ljava/lang/System;.nanoTime:()J` @kind static;
  #L4d1e56.  v2:= temp @kind wide;
  #L4d1e58.  v4:= 1000L;
  #L4d1e5c.  v2:= v2 / v4 @kind long;
  #L4d1e5e.  v6.`x1.t.c` @type ^`long` := v2 @kind wide;
  #L4d1e62.  v6.`x1.t.d` @type ^`long` := v0 @kind wide;
  #L4d1e66.  return @kind void;
}
procedure `void` `a`(`x1.t` v2 @kind this) @signature `Lx1/t;.a:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4d1d9c.  v0:= v2.`x1.t.b` @type ^`int`;
  #L4d1da0.  v1:= 4I;
  #L4d1da2.  if v0 != v1 then goto L4d1dac;
  #L4d1da6.  call `g`(v2) @signature `Lx1/t;.g:()V` @kind virtual;
  #L4d1dac.  return @kind void;
}
procedure `long` `b`(`x1.t` v2 @kind this) @signature `Lx1/t;.b:()J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4d1cfc.  v0:= v2.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1d00.  if v0 == 0 then goto L4d1d0e;
  #L4d1d04.  call temp:= `a`(v0) @signature `Lx1/t$a;.a:()J` @kind virtual;
  #L4d1d0a.  v0:= temp @kind wide;
  #L4d1d0c.  goto L4d1d12;
  #L4d1d0e.  v0:= -1L;
  #L4d1d12.  return v0 @kind wide;
}
procedure `long` `c`(`x1.t` v2 @kind this) @signature `Lx1/t;.c:()J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4d1d24.  v0:= v2.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1d28.  if v0 == 0 then goto L4d1d36;
  #L4d1d2c.  call temp:= `b`(v0) @signature `Lx1/t$a;.b:()J` @kind virtual;
  #L4d1d32.  v0:= temp @kind wide;
  #L4d1d34.  goto L4d1d40;
  #L4d1d36.  v0:= -4.9E-324D;
  #L4d1d40.  return v0 @kind wide;
}
procedure `boolean` `d`(`x1.t` v2 @kind this) @signature `Lx1/t;.d:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4d1be4.  v0:= v2.`x1.t.b` @type ^`int`;
  #L4d1be8.  v1:= 2I;
  #L4d1bea.  if v0 != v1 then goto L4d1bf2;
  #L4d1bee.  v0:= 1I;
  #L4d1bf0.  goto L4d1bf4;
  #L4d1bf2.  v0:= 0I;
  #L4d1bf4.  return v0;
}
procedure `boolean` `e`(`x1.t` v7 @kind this, `long` v8 ) @signature `Lx1/t;.e:(J)Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L4d1c08.  v0:= v7.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1c0c.  v1:= 0I;
  #L4d1c0e.  if v0 == 0 then goto L4d1cea;
  #L4d1c12.  v2:= v7.`x1.t.e` @type ^`long` @kind wide;
  #L4d1c16.  v2:= v8 - v2 @kind long;
  #L4d1c1a.  v4:= v7.`x1.t.d` @type ^`long` @kind wide;
  #L4d1c1e.  v6:= lcmp(v2, v4);
  #L4d1c22.  if v6 >= 0 then goto L4d1c28;
  #L4d1c26.  goto L4d1cea;
  #L4d1c28.  v7.`x1.t.e` @type ^`long` := v8 @kind wide;
  #L4d1c2c.  call temp:= `c`(v0) @signature `Lx1/t$a;.c:()Z` @kind virtual;
  #L4d1c32.  v0:= temp;
  #L4d1c34.  v2:= v7.`x1.t.b` @type ^`int`;
  #L4d1c38.  v3:= 3I;
  #L4d1c3a.  v4:= 1I;
  #L4d1c3c.  if v2 == 0 then goto L4d1c9a;
  #L4d1c40.  v8:= 2I;
  #L4d1c42.  if v2 == v4 then goto L4d1c6e;
  #L4d1c46.  if v2 == v8 then goto L4d1c68;
  #L4d1c4a.  if v2 == v3 then goto L4d1c62;
  #L4d1c4e.  v8:= 4I;
  #L4d1c50.  if v2 != v8 then goto L4d1c56;
  #L4d1c54.  goto L4d1ce8;
  #L4d1c56.  v8:= new `java.lang.IllegalStateException`;
  #L4d1c5a.  call `<init>`(v8) @signature `Ljava/lang/IllegalStateException;.<init>:()V` @kind direct;
  #L4d1c60.  throw v8;
  #L4d1c62.  if v0 == 0 then goto L4d1ce8;
  #L4d1c66.  goto L4d1c92;
  #L4d1c68.  if v0 != 0 then goto L4d1ce8;
  #L4d1c6c.  goto L4d1c92;
  #L4d1c6e.  if v0 == 0 then goto L4d1c92;
  #L4d1c72.  v9:= v7.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1c76.  call temp:= `a`(v9) @signature `Lx1/t$a;.a:()J` @kind virtual;
  #L4d1c7c.  v1:= temp @kind wide;
  #L4d1c7e.  v3:= v7.`x1.t.f` @type ^`long` @kind wide;
  #L4d1c82.  v9:= lcmp(v1, v3);
  #L4d1c86.  if v9 <= 0 then goto L4d1ce8;
  #L4d1c8a.  call `h`(v7, v8) @signature `Lx1/t;.h:(I)V` @kind direct;
  #L4d1c90.  goto L4d1ce8;
  #L4d1c92.  call `g`(v7) @signature `Lx1/t;.g:()V` @kind virtual;
  #L4d1c98.  goto L4d1ce8;
  #L4d1c9a.  if v0 == 0 then goto L4d1cce;
  #L4d1c9e.  v8:= v7.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1ca2.  call temp:= `b`(v8) @signature `Lx1/t$a;.b:()J` @kind virtual;
  #L4d1ca8.  v8:= temp @kind wide;
  #L4d1caa.  v2:= v7.`x1.t.c` @type ^`long` @kind wide;
  #L4d1cae.  v5:= lcmp(v8, v2);
  #L4d1cb2.  if v5 < 0 then goto L4d1cea;
  #L4d1cb6.  v8:= v7.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1cba.  call temp:= `a`(v8) @signature `Lx1/t$a;.a:()J` @kind virtual;
  #L4d1cc0.  v8:= temp @kind wide;
  #L4d1cc2.  v7.`x1.t.f` @type ^`long` := v8 @kind wide;
  #L4d1cc6.  call `h`(v7, v4) @signature `Lx1/t;.h:(I)V` @kind direct;
  #L4d1ccc.  goto L4d1ce8;
  #L4d1cce.  v1:= v7.`x1.t.c` @type ^`long` @kind wide;
  #L4d1cd2.  v8:= v8 - v1 @kind long;
  #L4d1cd4.  v1:= 500000L;
  #L4d1cda.  v4:= lcmp(v8, v1);
  #L4d1cde.  if v4 <= 0 then goto L4d1ce8;
  #L4d1ce2.  call `h`(v7, v3) @signature `Lx1/t;.h:(I)V` @kind direct;
  #L4d1ce8.  v1:= v0;
  #L4d1cea.  return v1;
}
procedure `void` `f`(`x1.t` v1 @kind this) @signature `Lx1/t;.f:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d1dc0.  v0:= 4I;
  #L4d1dc2.  call `h`(v1, v0) @signature `Lx1/t;.h:(I)V` @kind direct;
  #L4d1dc8.  return @kind void;
}
procedure `void` `g`(`x1.t` v1 @kind this) @signature `Lx1/t;.g:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4d1ddc.  v0:= v1.`x1.t.a` @type ^`x1.t$a` @kind object;
  #L4d1de0.  if v0 == 0 then goto L4d1dec;
  #L4d1de4.  v0:= 0I;
  #L4d1de6.  call `h`(v1, v0) @signature `Lx1/t;.h:(I)V` @kind direct;
  #L4d1dec.  return @kind void;
}

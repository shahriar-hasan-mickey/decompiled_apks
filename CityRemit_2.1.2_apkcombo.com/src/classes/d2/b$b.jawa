record `d2.b$b` @kind class @AccessFlag FINAL extends `a2.a$f` @kind interface {
  `a2.u` `d2.b$b.a` @AccessFlag PRIVATE_FINAL;
  `int` `d2.b$b.b` @AccessFlag PRIVATE_FINAL;
  `a2.r$a` `d2.b$b.c` @AccessFlag PRIVATE_FINAL;
}
procedure `void` `<init>`(`d2.b$b` v0 @kind this, `a2.u` v1 @kind object, `int` v2 ) @signature `Ld2/b$b;.<init>:(La2/u;I)V` @AccessFlag PRIVATE_CONSTRUCTOR {
    temp;

  #L2f1ff4.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L2f1ffa.  v0.`d2.b$b.a` @type ^`a2.u` := v1 @kind object;
  #L2f1ffe.  v0.`d2.b$b.b` @type ^`int` := v2;
  #L2f2002.  v1:= new `a2.r$a`;
  #L2f2006.  call `<init>`(v1) @signature `La2/r$a;.<init>:()V` @kind direct;
  #L2f200c.  v0.`d2.b$b.c` @type ^`a2.r$a` := v1 @kind object;
  #L2f2010.  return @kind void;
}
procedure `void` `<init>`(`d2.b$b` v0 @kind this, `a2.u` v1 @kind object, `int` v2 , `d2.b$a` v3 @kind object) @signature `Ld2/b$b;.<init>:(La2/u;ILd2/b$a;)V` @AccessFlag SYNTHETIC_CONSTRUCTOR {
    temp;

  #L2f2024.  call `<init>`(v0, v1, v2) @signature `Ld2/b$b;.<init>:(La2/u;I)V` @kind direct;
  #L2f202a.  return @kind void;
}
procedure `long` `c`(`d2.b$b` v7 @kind this, `a2.m` v8 @kind object) @signature `Ld2/b$b;.c:(La2/m;)J` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L2f1f5c.  call temp:= `n`(v8) @signature `La2/m;.n:()J` @kind interface;
  #L2f1f62.  v0:= temp @kind wide;
  #L2f1f64.  call temp:= `a`(v8) @signature `La2/m;.a:()J` @kind interface;
  #L2f1f6a.  v2:= temp @kind wide;
  #L2f1f6c.  v4:= 6L;
  #L2f1f70.  v2:= v2 - v4 @kind long;
  #L2f1f72.  v6:= lcmp(v0, v2);
  #L2f1f76.  if v6 >= 0 then goto L2f1f9c;
  #L2f1f7a.  v0:= v7.`d2.b$b.a` @type ^`a2.u` @kind object;
  #L2f1f7e.  v1:= v7.`d2.b$b.b` @type ^`int`;
  #L2f1f82.  v2:= v7.`d2.b$b.c` @type ^`a2.r$a` @kind object;
  #L2f1f86.  call temp:= `h`(v8, v0, v1, v2) @signature `La2/r;.h:(La2/m;La2/u;ILa2/r$a;)Z` @kind static;
  #L2f1f8c.  v0:= temp;
  #L2f1f8e.  if v0 != 0 then goto L2f1f9c;
  #L2f1f92.  v0:= 1I;
  #L2f1f94.  call `p`(v8, v0) @signature `La2/m;.p:(I)V` @kind interface;
  #L2f1f9a.  goto L2f1f5c;
  #L2f1f9c.  call temp:= `n`(v8) @signature `La2/m;.n:()J` @kind interface;
  #L2f1fa2.  v0:= temp @kind wide;
  #L2f1fa4.  call temp:= `a`(v8) @signature `La2/m;.a:()J` @kind interface;
  #L2f1faa.  v2:= temp @kind wide;
  #L2f1fac.  v2:= v2 - v4 @kind long;
  #L2f1fae.  v4:= lcmp(v0, v2);
  #L2f1fb2.  if v4 < 0 then goto L2f1fda;
  #L2f1fb6.  call temp:= `a`(v8) @signature `La2/m;.a:()J` @kind interface;
  #L2f1fbc.  v0:= temp @kind wide;
  #L2f1fbe.  call temp:= `n`(v8) @signature `La2/m;.n:()J` @kind interface;
  #L2f1fc4.  v2:= temp @kind wide;
  #L2f1fc6.  v0:= v0 - v2 @kind long;
  #L2f1fc8.  v1:= (`int`) v0 @kind l2i;
  #L2f1fca.  call `p`(v8, v1) @signature `La2/m;.p:(I)V` @kind interface;
  #L2f1fd0.  v8:= v7.`d2.b$b.a` @type ^`a2.u` @kind object;
  #L2f1fd4.  v0:= v8.`a2.u.j` @type ^`long` @kind wide;
  #L2f1fd8.  return v0 @kind wide;
  #L2f1fda.  v8:= v7.`d2.b$b.c` @type ^`a2.r$a` @kind object;
  #L2f1fde.  v0:= v8.`a2.r$a.a` @type ^`long` @kind wide;
  #L2f1fe2.  return v0 @kind wide;
}
procedure `a2.a$e` `a`(`d2.b$b` v10 @kind this, `a2.m` v11 @kind object, `long` v12 ) @signature `Ld2/b$b;.a:(La2/m;J)La2/a$e;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L2f1ed4.  call temp:= `q`(v11) @signature `La2/m;.q:()J` @kind interface;
  #L2f1eda.  v0:= temp @kind wide;
  #L2f1edc.  call temp:= `c`(v10, v11) @signature `Ld2/b$b;.c:(La2/m;)J` @kind direct;
  #L2f1ee2.  v2:= temp @kind wide;
  #L2f1ee4.  call temp:= `n`(v11) @signature `La2/m;.n:()J` @kind interface;
  #L2f1eea.  v4:= temp @kind wide;
  #L2f1eec.  v6:= v10.`d2.b$b.a` @type ^`a2.u` @kind object;
  #L2f1ef0.  v6:= v6.`a2.u.c` @type ^`int`;
  #L2f1ef4.  v7:= 6I;
  #L2f1ef6.  call temp:= `max`(v7, v6) @signature `Ljava/lang/Math;.max:(II)I` @kind static;
  #L2f1efc.  v6:= temp;
  #L2f1efe.  call `p`(v11, v6) @signature `La2/m;.p:(I)V` @kind interface;
  #L2f1f04.  call temp:= `c`(v10, v11) @signature `Ld2/b$b;.c:(La2/m;)J` @kind direct;
  #L2f1f0a.  v6:= temp @kind wide;
  #L2f1f0c.  call temp:= `n`(v11) @signature `La2/m;.n:()J` @kind interface;
  #L2f1f12.  v8:= temp @kind wide;
  #L2f1f14.  v11:= lcmp(v2, v12);
  #L2f1f18.  if v11 > 0 then goto L2f1f2e;
  #L2f1f1c.  v11:= lcmp(v6, v12);
  #L2f1f20.  if v11 <= 0 then goto L2f1f2e;
  #L2f1f24.  call temp:= `e`(v4) @signature `La2/a$e;.e:(J)La2/a$e;` @kind static;
  #L2f1f2a.  v11:= temp @kind object;
  #L2f1f2c.  return v11 @kind object;
  #L2f1f2e.  v11:= lcmp(v6, v12);
  #L2f1f32.  if v11 > 0 then goto L2f1f40;
  #L2f1f36.  call temp:= `f`(v6, v8) @signature `La2/a$e;.f:(JJ)La2/a$e;` @kind static;
  #L2f1f3c.  v11:= temp @kind object;
  #L2f1f3e.  return v11 @kind object;
  #L2f1f40.  call temp:= `d`(v2, v0) @signature `La2/a$e;.d:(JJ)La2/a$e;` @kind static;
  #L2f1f46.  v11:= temp @kind object;
  #L2f1f48.  return v11 @kind object;
}
procedure `void` `b`(`d2.b$b` v0 @kind this) @signature `Ld2/b$b;.b:()V` @AccessFlag PUBLIC_SYNTHETIC {
    temp;

  #L2f203c.  call `a`(v0) @signature `La2/b;.a:(La2/a$f;)V` @kind static;
  #L2f2042.  return @kind void;
}

record `c2.e` @kind class @AccessFlag FINAL {
  `a2.d0` `c2.e.a` @AccessFlag PROTECTED_FINAL;
  `int` `c2.e.b` @AccessFlag PRIVATE_FINAL;
  `int` `c2.e.c` @AccessFlag PRIVATE_FINAL;
  `long` `c2.e.d` @AccessFlag PRIVATE_FINAL;
  `int` `c2.e.e` @AccessFlag PRIVATE_FINAL;
  `int` `c2.e.f` @AccessFlag PRIVATE;
  `int` `c2.e.g` @AccessFlag PRIVATE;
  `int` `c2.e.h` @AccessFlag PRIVATE;
  `int` `c2.e.i` @AccessFlag PRIVATE;
  `int` `c2.e.j` @AccessFlag PRIVATE;
  `long`[] `c2.e.k` @AccessFlag PRIVATE;
  `int`[] `c2.e.l` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`c2.e` v2 @kind this, `int` v3 , `int` v4 , `long` v5 , `int` v7 , `a2.d0` v8 @kind object) @signature `Lc2/e;.<init>:(IIJILa2/d0;)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L1f48e4.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L1f48ea.  v0:= 1I;
  #L1f48ec.  v1:= 2I;
  #L1f48ee.  if v4 == v0 then goto L1f48fa;
  #L1f48f2.  if v4 != v1 then goto L1f48f8;
  #L1f48f6.  goto L1f48fa;
  #L1f48f8.  v0:= 0I;
  #L1f48fa.  call `a`(v0) @signature `Ls3/a;.a:(Z)V` @kind static;
  #L1f4900.  v2.`c2.e.d` @type ^`long` := v5 @kind wide;
  #L1f4904.  v2.`c2.e.e` @type ^`int` := v7;
  #L1f4908.  v2.`c2.e.a` @type ^`a2.d0` := v8 @kind object;
  #L1f490c.  if v4 != v1 then goto L1f4916;
  #L1f4910.  v5:= 1667497984I;
  #L1f4914.  goto L1f491a;
  #L1f4916.  v5:= 1651965952I;
  #L1f491a.  call temp:= `d`(v3, v5) @signature `Lc2/e;.d:(II)I` @kind static;
  #L1f4920.  v5:= temp;
  #L1f4922.  v2.`c2.e.b` @type ^`int` := v5;
  #L1f4926.  if v4 != v1 then goto L1f4938;
  #L1f492a.  v4:= 1650720768I;
  #L1f492e.  call temp:= `d`(v3, v4) @signature `Lc2/e;.d:(II)I` @kind static;
  #L1f4934.  v3:= temp;
  #L1f4936.  goto L1f493a;
  #L1f4938.  v3:= -1I;
  #L1f493a.  v2.`c2.e.c` @type ^`int` := v3;
  #L1f493e.  v3:= 512I;
  #L1f4942.  v4:= new `long`[v3];
  #L1f4946.  v2.`c2.e.k` @type ^`long`[] := v4 @kind object;
  #L1f494a.  v3:= new `int`[v3];
  #L1f494e.  v2.`c2.e.l` @type ^`int`[] := v3 @kind object;
  #L1f4952.  return @kind void;
}
procedure `int` `d`(`int` v1 , `int` v2 ) @signature `Lc2/e;.d:(II)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1f4858.  v0:= v1 / 10;
  #L1f485c.  v1:= v1 %% 10;
  #L1f4860.  v1:= v1 + 48;
  #L1f4864.  v1:= v1 ^< 8;
  #L1f4868.  v0:= v0 + 48;
  #L1f486c.  v1:= v1 ^| v0 @kind int;
  #L1f486e.  v1:= v1 ^| v2 @kind int;
  #L1f4870.  return v1;
}
procedure `long` `e`(`c2.e` v4 @kind this, `int` v5 ) @signature `Lc2/e;.e:(I)J` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1f4884.  v0:= v4.`c2.e.d` @type ^`long` @kind wide;
  #L1f4888.  v2:= (`long`) v5 @kind i2l;
  #L1f488a.  v0:= v0 * v2 @kind long;
  #L1f488e.  v5:= v4.`c2.e.e` @type ^`int`;
  #L1f4892.  v2:= (`long`) v5 @kind i2l;
  #L1f4894.  v0:= v0 / v2 @kind long;
  #L1f4896.  return v0 @kind wide;
}
procedure `a2.b0` `h`(`c2.e` v6 @kind this, `int` v7 ) @signature `Lc2/e;.h:(I)La2/b0;` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L1f4760.  v0:= new `a2.b0`;
  #L1f4764.  v1:= v6.`c2.e.l` @type ^`int`[] @kind object;
  #L1f4768.  v1:= v1[v7];
  #L1f476c.  v1:= (`long`) v1 @kind i2l;
  #L1f476e.  call temp:= `g`(v6) @signature `Lc2/e;.g:()J` @kind virtual;
  #L1f4774.  v3:= temp @kind wide;
  #L1f4776.  v1:= v1 * v3 @kind long;
  #L1f477a.  v3:= v6.`c2.e.k` @type ^`long`[] @kind object;
  #L1f477e.  v4:= v3[v7] @kind wide;
  #L1f4782.  call `<init>`(v0, v1, v4) @signature `La2/b0;.<init>:(JJ)V` @kind direct;
  #L1f4788.  return v0 @kind object;
}
procedure `void` `a`(`c2.e` v1 @kind this) @signature `Lc2/e;.a:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1f4964.  v0:= v1.`c2.e.h` @type ^`int`;
  #L1f4968.  v0:= v0 + 1;
  #L1f496c.  v1.`c2.e.h` @type ^`int` := v0;
  #L1f4970.  return @kind void;
}
procedure `void` `b`(`c2.e` v2 @kind this, `long` v3 ) @signature `Lc2/e;.b:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f4984.  v0:= v2.`c2.e.j` @type ^`int`;
  #L1f4988.  v1:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f498c.  v1:= length @variable v1;
  #L1f498e.  if v0 != v1 then goto L1f49c6;
  #L1f4992.  v0:= v2.`c2.e.k` @type ^`long`[] @kind object;
  #L1f4996.  v1:= length @variable v0;
  #L1f4998.  v1:= v1 * 3;
  #L1f499c.  v1:= v1 / 2;
  #L1f49a0.  call temp:= `copyOf`(v0, v1) @signature `Ljava/util/Arrays;.copyOf:([JI)[J` @kind static;
  #L1f49a6.  v0:= temp @kind object;
  #L1f49a8.  v2.`c2.e.k` @type ^`long`[] := v0 @kind object;
  #L1f49ac.  v0:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f49b0.  v1:= length @variable v0;
  #L1f49b2.  v1:= v1 * 3;
  #L1f49b6.  v1:= v1 / 2;
  #L1f49ba.  call temp:= `copyOf`(v0, v1) @signature `Ljava/util/Arrays;.copyOf:([II)[I` @kind static;
  #L1f49c0.  v0:= temp @kind object;
  #L1f49c2.  v2.`c2.e.l` @type ^`int`[] := v0 @kind object;
  #L1f49c6.  v0:= v2.`c2.e.k` @type ^`long`[] @kind object;
  #L1f49ca.  v1:= v2.`c2.e.j` @type ^`int`;
  #L1f49ce.  v0[v1]:= v3 @kind wide;
  #L1f49d2.  v3:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f49d6.  v4:= v2.`c2.e.i` @type ^`int`;
  #L1f49da.  v3[v1]:= v4;
  #L1f49de.  v1:= v1 + 1;
  #L1f49e2.  v2.`c2.e.j` @type ^`int` := v1;
  #L1f49e6.  return @kind void;
}
procedure `void` `c`(`c2.e` v2 @kind this) @signature `Lc2/e;.c:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f49f8.  v0:= v2.`c2.e.k` @type ^`long`[] @kind object;
  #L1f49fc.  v1:= v2.`c2.e.j` @type ^`int`;
  #L1f4a00.  call temp:= `copyOf`(v0, v1) @signature `Ljava/util/Arrays;.copyOf:([JI)[J` @kind static;
  #L1f4a06.  v0:= temp @kind object;
  #L1f4a08.  v2.`c2.e.k` @type ^`long`[] := v0 @kind object;
  #L1f4a0c.  v0:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f4a10.  v1:= v2.`c2.e.j` @type ^`int`;
  #L1f4a14.  call temp:= `copyOf`(v0, v1) @signature `Ljava/util/Arrays;.copyOf:([II)[I` @kind static;
  #L1f4a1a.  v0:= temp @kind object;
  #L1f4a1c.  v2.`c2.e.l` @type ^`int`[] := v0 @kind object;
  #L1f4a20.  return @kind void;
}
procedure `long` `f`(`c2.e` v2 @kind this) @signature `Lc2/e;.f:()J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f48a8.  v0:= v2.`c2.e.h` @type ^`int`;
  #L1f48ac.  call temp:= `e`(v2, v0) @signature `Lc2/e;.e:(I)J` @kind direct;
  #L1f48b2.  v0:= temp @kind wide;
  #L1f48b4.  return v0 @kind wide;
}
procedure `long` `g`(`c2.e` v2 @kind this) @signature `Lc2/e;.g:()J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f48c8.  v0:= 1I;
  #L1f48ca.  call temp:= `e`(v2, v0) @signature `Lc2/e;.e:(I)J` @kind direct;
  #L1f48d0.  v0:= temp @kind wide;
  #L1f48d2.  return v0 @kind wide;
}
procedure `a2.a0$a` `i`(`c2.e` v2 @kind this, `long` v3 ) @signature `Lc2/e;.i:(J)La2/a0$a;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f46e0.  call temp:= `g`(v2) @signature `Lc2/e;.g:()J` @kind virtual;
  #L1f46e6.  v0:= temp @kind wide;
  #L1f46e8.  v3:= v3 / v0 @kind long;
  #L1f46ea.  v4:= (`int`) v3 @kind l2i;
  #L1f46ec.  v3:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f46f0.  v0:= 1I;
  #L1f46f2.  call temp:= `h`(v3, v4, v0, v0) @signature `Ls3/l0;.h:([IIZZ)I` @kind static;
  #L1f46f8.  v3:= temp;
  #L1f46fa.  v1:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f46fe.  v1:= v1[v3];
  #L1f4702.  if v1 != v4 then goto L1f471a;
  #L1f4706.  v4:= new `a2.a0$a`;
  #L1f470a.  call temp:= `h`(v2, v3) @signature `Lc2/e;.h:(I)La2/b0;` @kind direct;
  #L1f4710.  v3:= temp @kind object;
  #L1f4712.  call `<init>`(v4, v3) @signature `La2/a0$a;.<init>:(La2/b0;)V` @kind direct;
  #L1f4718.  return v4 @kind object;
  #L1f471a.  call temp:= `h`(v2, v3) @signature `Lc2/e;.h:(I)La2/b0;` @kind direct;
  #L1f4720.  v4:= temp @kind object;
  #L1f4722.  v3:= v3 + v0 @kind int;
  #L1f4724.  v0:= v2.`c2.e.k` @type ^`long`[] @kind object;
  #L1f4728.  v0:= length @variable v0;
  #L1f472a.  if v3 >= v0 then goto L1f4742;
  #L1f472e.  v0:= new `a2.a0$a`;
  #L1f4732.  call temp:= `h`(v2, v3) @signature `Lc2/e;.h:(I)La2/b0;` @kind direct;
  #L1f4738.  v3:= temp @kind object;
  #L1f473a.  call `<init>`(v0, v4, v3) @signature `La2/a0$a;.<init>:(La2/b0;La2/b0;)V` @kind direct;
  #L1f4740.  return v0 @kind object;
  #L1f4742.  v3:= new `a2.a0$a`;
  #L1f4746.  call `<init>`(v3, v4) @signature `La2/a0$a;.<init>:(La2/b0;)V` @kind direct;
  #L1f474c.  return v3 @kind object;
}
procedure `boolean` `j`(`c2.e` v1 @kind this, `int` v2 ) @signature `Lc2/e;.j:(I)Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1f479c.  v0:= v1.`c2.e.b` @type ^`int`;
  #L1f47a0.  if v0 == v2 then goto L1f47b2;
  #L1f47a4.  v0:= v1.`c2.e.c` @type ^`int`;
  #L1f47a8.  if v0 != v2 then goto L1f47ae;
  #L1f47ac.  goto L1f47b2;
  #L1f47ae.  v2:= 0I;
  #L1f47b0.  goto L1f47b4;
  #L1f47b2.  v2:= 1I;
  #L1f47b4.  return v2;
}
procedure `void` `k`(`c2.e` v1 @kind this) @signature `Lc2/e;.k:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1f4a34.  v0:= v1.`c2.e.i` @type ^`int`;
  #L1f4a38.  v0:= v0 + 1;
  #L1f4a3c.  v1.`c2.e.i` @type ^`int` := v0;
  #L1f4a40.  return @kind void;
}
procedure `boolean` `l`(`c2.e` v2 @kind this) @signature `Lc2/e;.l:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f47c8.  v0:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f47cc.  v1:= v2.`c2.e.h` @type ^`int`;
  #L1f47d0.  call temp:= `binarySearch`(v0, v1) @signature `Ljava/util/Arrays;.binarySearch:([II)I` @kind static;
  #L1f47d6.  v0:= temp;
  #L1f47d8.  if v0 < 0 then goto L1f47e0;
  #L1f47dc.  v0:= 1I;
  #L1f47de.  goto L1f47e2;
  #L1f47e0.  v0:= 0I;
  #L1f47e2.  return v0;
}
procedure `boolean` `m`(`c2.e` v10 @kind this, `a2.m` v11 @kind object) @signature `Lc2/e;.m:(La2/m;)Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L1f47f4.  v0:= v10.`c2.e.g` @type ^`int`;
  #L1f47f8.  v1:= v10.`c2.e.a` @type ^`a2.d0` @kind object;
  #L1f47fc.  v2:= 0I;
  #L1f47fe.  call temp:= `d`(v1, v11, v0, v2) @signature `La2/d0;.d:(Lr3/i;IZ)I` @kind interface;
  #L1f4804.  v11:= temp;
  #L1f4806.  v0:= v0 - v11 @kind int;
  #L1f4808.  v10.`c2.e.g` @type ^`int` := v0;
  #L1f480c.  if v0 != 0 then goto L1f4812;
  #L1f4810.  v2:= 1I;
  #L1f4812.  if v2 == 0 then goto L1f4846;
  #L1f4816.  v11:= v10.`c2.e.f` @type ^`int`;
  #L1f481a.  if v11 <= 0 then goto L1f4840;
  #L1f481e.  v3:= v10.`c2.e.a` @type ^`a2.d0` @kind object;
  #L1f4822.  call temp:= `f`(v10) @signature `Lc2/e;.f:()J` @kind virtual;
  #L1f4828.  v4:= temp @kind wide;
  #L1f482a.  call temp:= `l`(v10) @signature `Lc2/e;.l:()Z` @kind virtual;
  #L1f4830.  v6:= temp;
  #L1f4832.  v7:= v10.`c2.e.f` @type ^`int`;
  #L1f4836.  v8:= 0I;
  #L1f4838.  v9:= 0I;
  #L1f483a.  call `f`(v3, v4, v6, v7, v8, v9) @signature `La2/d0;.f:(JIIILa2/d0$a;)V` @kind interface;
  #L1f4840.  call `a`(v10) @signature `Lc2/e;.a:()V` @kind virtual;
  #L1f4846.  return v2;
}
procedure `void` `n`(`c2.e` v0 @kind this, `int` v1 ) @signature `Lc2/e;.n:(I)V` @AccessFlag PUBLIC {
    temp;

  #L1f4a54.  v0.`c2.e.f` @type ^`int` := v1;
  #L1f4a58.  v0.`c2.e.g` @type ^`int` := v1;
  #L1f4a5c.  return @kind void;
}
procedure `void` `o`(`c2.e` v2 @kind this, `long` v3 ) @signature `Lc2/e;.o:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L1f4a70.  v0:= v2.`c2.e.j` @type ^`int`;
  #L1f4a74.  if v0 != 0 then goto L1f4a7c;
  #L1f4a78.  v3:= 0I;
  #L1f4a7a.  goto L1f4a92;
  #L1f4a7c.  v0:= v2.`c2.e.k` @type ^`long`[] @kind object;
  #L1f4a80.  v1:= 1I;
  #L1f4a82.  call temp:= `i`(v0, v3, v1, v1) @signature `Ls3/l0;.i:([JJZZ)I` @kind static;
  #L1f4a88.  v3:= temp;
  #L1f4a8a.  v4:= v2.`c2.e.l` @type ^`int`[] @kind object;
  #L1f4a8e.  v3:= v4[v3];
  #L1f4a92.  v2.`c2.e.h` @type ^`int` := v3;
  #L1f4a96.  return @kind void;
}

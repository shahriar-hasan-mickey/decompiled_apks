record `a2.r` @kind class @AccessFlag PUBLIC_FINAL {
}
procedure `boolean` `a`(`s3.z` v0 @kind object, `a2.u` v1 @kind object, `int` v2 ) @signature `La2/r;.a:(Ls3/z;La2/u;I)Z` @AccessFlag PRIVATE_STATIC {
    temp;

  #L159e10.  call temp:= `j`(v0, v2) @signature `La2/r;.j:(Ls3/z;I)I` @kind static;
  #L159e16.  v0:= temp;
  #L159e18.  v2:= -1I;
  #L159e1a.  if v0 == v2 then goto L159e2a;
  #L159e1e.  v1:= v1.`a2.u.b` @type ^`int`;
  #L159e22.  if v0 > v1 then goto L159e2a;
  #L159e26.  v0:= 1I;
  #L159e28.  goto L159e2c;
  #L159e2a.  v0:= 0I;
  #L159e2c.  return v0;
}
procedure `boolean` `b`(`s3.z` v4 @kind object, `int` v5 ) @signature `La2/r;.b:(Ls3/z;I)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L159e40.  call temp:= `C`(v4) @signature `Ls3/z;.C:()I` @kind virtual;
  #L159e46.  v0:= temp;
  #L159e48.  call temp:= `e`(v4) @signature `Ls3/z;.e:()I` @kind virtual;
  #L159e4e.  v1:= temp;
  #L159e50.  call temp:= `d`(v4) @signature `Ls3/z;.d:()[B` @kind virtual;
  #L159e56.  v4:= temp @kind object;
  #L159e58.  v2:= 1I;
  #L159e5a.  v1:= v1 - v2 @kind int;
  #L159e5c.  v3:= 0I;
  #L159e5e.  call temp:= `u`(v4, v5, v1, v3) @signature `Ls3/l0;.u:([BIII)I` @kind static;
  #L159e64.  v4:= temp;
  #L159e66.  if v0 != v4 then goto L159e6c;
  #L159e6a.  goto L159e6e;
  #L159e6c.  v2:= 0I;
  #L159e6e.  return v2;
}
procedure `boolean` `c`(`s3.z` v2 @kind object, `a2.u` v3 @kind object, `boolean` v4 , `a2.r$a` v5 @kind object) @signature `La2/r;.c:(Ls3/z;La2/u;ZLa2/r$a;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L159e80.  call temp:= `J`(v2) @signature `Ls3/z;.J:()J` @kind virtual;
  #L159e86.  v0:= temp @kind wide;
  #L159e88.  if v4 == 0 then goto L159e8e;
  #L159e8c.  goto L159e98;
  #L159e8e.  v2:= v3.`a2.u.b` @type ^`int`;
  #L159e92.  v2:= (`long`) v2 @kind i2l;
  #L159e94.  v0:= v0 * v2 @kind long;
  #L159e98.  v5.`a2.r$a.a` @type ^`long` := v0 @kind wide;
  #L159e9c.  v2:= 1I;
  #L159e9e.  return v2;
  #L159ea0.  v2:= 0I;
  #L159ea2.  return v2;
  catch `java.lang.NumberFormatException` @[L159e80..L159e88] goto L159ea0;
}
procedure `boolean` `d`(`s3.z` v17 @kind object, `a2.u` v18 @kind object, `int` v19 , `a2.r$a` v20 @kind object) @signature `La2/r;.d:(Ls3/z;La2/u;ILa2/r$a;)Z` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;

  #L159ec4.  v0:= v17 @kind object;
  #L159ec8.  v1:= v18 @kind object;
  #L159ecc.  call temp:= `e`(v17) @signature `Ls3/z;.e:()I` @kind virtual;
  #L159ed2.  v2:= temp;
  #L159ed4.  call temp:= `E`(v17) @signature `Ls3/z;.E:()J` @kind virtual;
  #L159eda.  v3:= temp @kind wide;
  #L159edc.  v5:= 16I;
  #L159ee0.  v5:= v3 ^>> v5 @kind long;
  #L159ee4.  v7:= v19;
  #L159ee8.  v7:= (`long`) v7 @kind i2l;
  #L159eea.  v9:= 0I;
  #L159eec.  v10:= lcmp(v5, v7);
  #L159ef0.  if v10 == 0 then goto L159ef6;
  #L159ef4.  return v9;
  #L159ef6.  v7:= 1L;
  #L159efa.  v5:= v5 ^& v7 @kind long;
  #L159efc.  v10:= 1I;
  #L159efe.  v11:= lcmp(v5, v7);
  #L159f02.  if v11 != 0 then goto L159f0a;
  #L159f06.  v5:= 1I;
  #L159f08.  goto L159f0c;
  #L159f0a.  v5:= 0I;
  #L159f0c.  v6:= 12I;
  #L159f10.  v11:= v3 ^> v6 @kind long;
  #L159f14.  v13:= 15L;
  #L159f18.  v11:= v11 ^& v13 @kind long;
  #L159f1a.  v6:= (`int`) v11 @kind l2i;
  #L159f1c.  v11:= 8I;
  #L159f20.  v11:= v3 ^> v11 @kind long;
  #L159f24.  v11:= v11 ^& v13 @kind long;
  #L159f26.  v12:= (`int`) v11 @kind l2i;
  #L159f28.  v11:= 4I;
  #L159f2a.  v15:= v3 ^> v11 @kind long;
  #L159f2e.  v13:= v13 ^& v15 @kind long;
  #L159f30.  v11:= (`int`) v13 @kind l2i;
  #L159f32.  v13:= v3 ^> v10 @kind long;
  #L159f36.  v15:= 7L;
  #L159f3a.  v13:= v13 ^& v15 @kind long;
  #L159f3c.  v14:= (`int`) v13 @kind l2i;
  #L159f3e.  v3:= v3 ^& v7 @kind long;
  #L159f40.  v13:= lcmp(v3, v7);
  #L159f44.  if v13 != 0 then goto L159f4c;
  #L159f48.  v3:= 1I;
  #L159f4a.  goto L159f4e;
  #L159f4c.  v3:= 0I;
  #L159f4e.  call temp:= `g`(v11, v1) @signature `La2/r;.g:(ILa2/u;)Z` @kind static;
  #L159f54.  v4:= temp;
  #L159f56.  if v4 == 0 then goto L159fa0;
  #L159f5a.  call temp:= `f`(v14, v1) @signature `La2/r;.f:(ILa2/u;)Z` @kind static;
  #L159f60.  v4:= temp;
  #L159f62.  if v4 == 0 then goto L159fa0;
  #L159f66.  if v3 != 0 then goto L159fa0;
  #L159f6a.  v3:= v20 @kind object;
  #L159f6e.  call temp:= `c`(v0, v1, v5, v3) @signature `La2/r;.c:(Ls3/z;La2/u;ZLa2/r$a;)Z` @kind static;
  #L159f74.  v3:= temp;
  #L159f76.  if v3 == 0 then goto L159fa0;
  #L159f7a.  call temp:= `a`(v0, v1, v6) @signature `La2/r;.a:(Ls3/z;La2/u;I)Z` @kind static;
  #L159f80.  v3:= temp;
  #L159f82.  if v3 == 0 then goto L159fa0;
  #L159f86.  call temp:= `e`(v0, v1, v12) @signature `La2/r;.e:(Ls3/z;La2/u;I)Z` @kind static;
  #L159f8c.  v1:= temp;
  #L159f8e.  if v1 == 0 then goto L159fa0;
  #L159f92.  call temp:= `b`(v0, v2) @signature `La2/r;.b:(Ls3/z;I)Z` @kind static;
  #L159f98.  v0:= temp;
  #L159f9a.  if v0 == 0 then goto L159fa0;
  #L159f9e.  v9:= 1I;
  #L159fa0.  return v9;
}
procedure `boolean` `e`(`s3.z` v4 @kind object, `a2.u` v5 @kind object, `int` v6 ) @signature `La2/r;.e:(Ls3/z;La2/u;I)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L159fb4.  v0:= v5.`a2.u.e` @type ^`int`;
  #L159fb8.  v1:= 1I;
  #L159fba.  if v6 != 0 then goto L159fc0;
  #L159fbe.  return v1;
  #L159fc0.  v2:= 11I;
  #L159fc4.  v3:= 0I;
  #L159fc6.  if v6 > v2 then goto L159fd8;
  #L159fca.  v4:= v5.`a2.u.f` @type ^`int`;
  #L159fce.  if v6 != v4 then goto L159fd4;
  #L159fd2.  goto L159fd6;
  #L159fd4.  v1:= 0I;
  #L159fd6.  return v1;
  #L159fd8.  v5:= 12I;
  #L159fdc.  if v6 != v5 then goto L159ff6;
  #L159fe0.  call temp:= `C`(v4) @signature `Ls3/z;.C:()I` @kind virtual;
  #L159fe6.  v4:= temp;
  #L159fe8.  v4:= v4 * 1000;
  #L159fec.  if v4 != v0 then goto L159ff2;
  #L159ff0.  goto L159ff4;
  #L159ff2.  v1:= 0I;
  #L159ff4.  return v1;
  #L159ff6.  v5:= 14I;
  #L159ffa.  if v6 > v5 then goto L15a018;
  #L159ffe.  call temp:= `I`(v4) @signature `Ls3/z;.I:()I` @kind virtual;
  #L15a004.  v4:= temp;
  #L15a006.  if v6 != v5 then goto L15a00e;
  #L15a00a.  v4:= v4 * 10;
  #L15a00e.  if v4 != v0 then goto L15a014;
  #L15a012.  goto L15a016;
  #L15a014.  v1:= 0I;
  #L15a016.  return v1;
  #L15a018.  return v3;
}
procedure `boolean` `f`(`int` v1 , `a2.u` v2 @kind object) @signature `La2/r;.f:(ILa2/u;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L15a02c.  v0:= 1I;
  #L15a02e.  if v1 != 0 then goto L15a034;
  #L15a032.  return v0;
  #L15a034.  v2:= v2.`a2.u.i` @type ^`int`;
  #L15a038.  if v1 != v2 then goto L15a03e;
  #L15a03c.  goto L15a040;
  #L15a03e.  v0:= 0I;
  #L15a040.  return v0;
}
procedure `boolean` `g`(`int` v3 , `a2.u` v4 @kind object) @signature `La2/r;.g:(ILa2/u;)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L15a054.  v0:= 0I;
  #L15a056.  v1:= 1I;
  #L15a058.  v2:= 7I;
  #L15a05a.  if v3 > v2 then goto L15a06c;
  #L15a05e.  v4:= v4.`a2.u.g` @type ^`int`;
  #L15a062.  v4:= v4 - v1 @kind int;
  #L15a064.  if v3 != v4 then goto L15a06a;
  #L15a068.  v0:= 1I;
  #L15a06a.  return v0;
  #L15a06c.  v2:= 10I;
  #L15a070.  if v3 > v2 then goto L15a080;
  #L15a074.  v3:= v4.`a2.u.g` @type ^`int`;
  #L15a078.  v4:= 2I;
  #L15a07a.  if v3 != v4 then goto L15a080;
  #L15a07e.  v0:= 1I;
  #L15a080.  return v0;
}
procedure `boolean` `h`(`a2.m` v7 @kind object, `a2.u` v8 @kind object, `int` v9 , `a2.r$a` v10 @kind object) @signature `La2/r;.h:(La2/m;La2/u;ILa2/r$a;)Z` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L15a094.  call temp:= `n`(v7) @signature `La2/m;.n:()J` @kind interface;
  #L15a09a.  v0:= temp @kind wide;
  #L15a09c.  v2:= 2I;
  #L15a09e.  v3:= new `byte`[v2];
  #L15a0a2.  v4:= 0I;
  #L15a0a4.  call `o`(v7, v3, v4, v2) @signature `La2/m;.o:([BII)V` @kind interface;
  #L15a0aa.  v5:= v3[v4] @kind byte;
  #L15a0ae.  v5:= v5 ^& 255;
  #L15a0b2.  v5:= v5 ^< 8;
  #L15a0b6.  v6:= 1I;
  #L15a0b8.  v6:= v3[v6] @kind byte;
  #L15a0bc.  v6:= v6 ^& 255;
  #L15a0c0.  v5:= v5 ^| v6 @kind int;
  #L15a0c2.  if v5 == v9 then goto L15a0e0;
  #L15a0c6.  call `i`(v7) @signature `La2/m;.i:()V` @kind interface;
  #L15a0cc.  call temp:= `q`(v7) @signature `La2/m;.q:()J` @kind interface;
  #L15a0d2.  v8:= temp @kind wide;
  #L15a0d4.  v0:= v0 - v8 @kind long;
  #L15a0d6.  v8:= (`int`) v0 @kind l2i;
  #L15a0d8.  call `p`(v7, v8) @signature `La2/m;.p:(I)V` @kind interface;
  #L15a0de.  return v4;
  #L15a0e0.  v5:= new `s3.z`;
  #L15a0e4.  v6:= 16I;
  #L15a0e8.  call `<init>`(v5, v6) @signature `Ls3/z;.<init>:(I)V` @kind direct;
  #L15a0ee.  call temp:= `d`(v5) @signature `Ls3/z;.d:()[B` @kind virtual;
  #L15a0f4.  v6:= temp @kind object;
  #L15a0f6.  call `arraycopy`(v3, v4, v6, v4, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L15a0fc.  call temp:= `d`(v5) @signature `Ls3/z;.d:()[B` @kind virtual;
  #L15a102.  v3:= temp @kind object;
  #L15a104.  v4:= 14I;
  #L15a108.  call temp:= `c`(v7, v3, v2, v4) @signature `La2/o;.c:(La2/m;[BII)I` @kind static;
  #L15a10e.  v2:= temp;
  #L15a110.  call `N`(v5, v2) @signature `Ls3/z;.N:(I)V` @kind virtual;
  #L15a116.  call `i`(v7) @signature `La2/m;.i:()V` @kind interface;
  #L15a11c.  call temp:= `q`(v7) @signature `La2/m;.q:()J` @kind interface;
  #L15a122.  v2:= temp @kind wide;
  #L15a124.  v0:= v0 - v2 @kind long;
  #L15a126.  v1:= (`int`) v0 @kind l2i;
  #L15a128.  call `p`(v7, v1) @signature `La2/m;.p:(I)V` @kind interface;
  #L15a12e.  call temp:= `d`(v5, v8, v9, v10) @signature `La2/r;.d:(Ls3/z;La2/u;ILa2/r$a;)Z` @kind static;
  #L15a134.  v7:= temp;
  #L15a136.  return v7;
}
procedure `long` `i`(`a2.m` v5 @kind object, `a2.u` v6 @kind object) @signature `La2/r;.i:(La2/m;La2/u;)J` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L15a1e0.  call `i`(v5) @signature `La2/m;.i:()V` @kind interface;
  #L15a1e6.  v0:= 1I;
  #L15a1e8.  call `p`(v5, v0) @signature `La2/m;.p:(I)V` @kind interface;
  #L15a1ee.  v1:= new `byte`[v0];
  #L15a1f2.  v2:= 0I;
  #L15a1f4.  call `o`(v5, v1, v2, v0) @signature `La2/m;.o:([BII)V` @kind interface;
  #L15a1fa.  v1:= v1[v2] @kind byte;
  #L15a1fe.  v1:= v1 ^& v0 @kind int;
  #L15a200.  if v1 != v0 then goto L15a206;
  #L15a204.  goto L15a208;
  #L15a206.  v0:= 0I;
  #L15a208.  v1:= 2I;
  #L15a20a.  call `p`(v5, v1) @signature `La2/m;.p:(I)V` @kind interface;
  #L15a210.  if v0 == 0 then goto L15a218;
  #L15a214.  v1:= 7I;
  #L15a216.  goto L15a21a;
  #L15a218.  v1:= 6I;
  #L15a21a.  v3:= new `s3.z`;
  #L15a21e.  call `<init>`(v3, v1) @signature `Ls3/z;.<init>:(I)V` @kind direct;
  #L15a224.  call temp:= `d`(v3) @signature `Ls3/z;.d:()[B` @kind virtual;
  #L15a22a.  v4:= temp @kind object;
  #L15a22c.  call temp:= `c`(v5, v4, v2, v1) @signature `La2/o;.c:(La2/m;[BII)I` @kind static;
  #L15a232.  v1:= temp;
  #L15a234.  call `N`(v3, v1) @signature `Ls3/z;.N:(I)V` @kind virtual;
  #L15a23a.  call `i`(v5) @signature `La2/m;.i:()V` @kind interface;
  #L15a240.  v5:= new `a2.r$a`;
  #L15a244.  call `<init>`(v5) @signature `La2/r$a;.<init>:()V` @kind direct;
  #L15a24a.  call temp:= `c`(v3, v6, v0, v5) @signature `La2/r;.c:(Ls3/z;La2/u;ZLa2/r$a;)Z` @kind static;
  #L15a250.  v6:= temp;
  #L15a252.  if v6 == 0 then goto L15a25c;
  #L15a256.  v5:= v5.`a2.r$a.a` @type ^`long` @kind wide;
  #L15a25a.  return v5 @kind wide;
  #L15a25c.  v5:= 0I;
  #L15a25e.  call temp:= `a`(v5, v5) @signature `Lv1/e2;.a:(Ljava/lang/String;Ljava/lang/Throwable;)Lv1/e2;` @kind static;
  #L15a264.  v5:= temp @kind object;
  #L15a266.  throw v5;
}
procedure `int` `j`(`s3.z` v0 @kind object, `int` v1 ) @signature `La2/r;.j:(Ls3/z;I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L15a148.  goto L15a18c;
  #L15a14e.  v0:= -1I;
  #L15a150.  return v0;
  #L15a152.  v0:= 256I;
  #L15a156.  v1:= v1 + -8;
  #L15a15a.  v0:= v0 ^< v1 @kind int;
  #L15a15c.  return v0;
  #L15a15e.  call temp:= `I`(v0) @signature `Ls3/z;.I:()I` @kind virtual;
  #L15a164.  v0:= temp;
  #L15a166.  v0:= v0 + 1;
  #L15a16a.  return v0;
  #L15a16c.  call temp:= `C`(v0) @signature `Ls3/z;.C:()I` @kind virtual;
  #L15a172.  v0:= temp;
  #L15a174.  v0:= v0 + 1;
  #L15a178.  return v0;
  #L15a17a.  v0:= 576I;
  #L15a17e.  v1:= v1 + -2;
  #L15a182.  v0:= v0 ^< v1 @kind int;
  #L15a184.  return v0;
  #L15a186.  v0:= 192I;
  #L15a18a.  return v0;
  #L15a18c.  switch v1
                  | 1 => goto L15a186
                  | 2 => goto L15a17a
                  | 3 => goto L15a17a
                  | 4 => goto L15a17a
                  | 5 => goto L15a17a
                  | 6 => goto L15a16c
                  | 7 => goto L15a15e
                  | 8 => goto L15a152
                  | 9 => goto L15a152
                  | 10 => goto L15a152
                  | 11 => goto L15a152
                  | 12 => goto L15a152
                  | 13 => goto L15a152
                  | 14 => goto L15a152
                  | 15 => goto L15a152
                  | else => goto L15a14e;
}

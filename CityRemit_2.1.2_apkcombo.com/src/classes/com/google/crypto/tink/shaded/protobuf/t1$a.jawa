record `com.google.crypto.tink.shaded.protobuf.t1$a` @kind class @AccessFlag  {
}
procedure `void` `a`(`byte` v0 , `byte` v1 , `byte` v2 , `byte` v3 , `char`[] v4 @kind object, `int` v5 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.a:(BBBB[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7ef4.  call `h`(v0, v1, v2, v3, v4, v5) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.h:(BBBB[CI)V` @kind static;
  #L2d7efa.  return @kind void;
}
procedure `boolean` `b`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.b:(B)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7dcc.  call temp:= `n`(v0) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.n:(B)Z` @kind static;
  #L2d7dd2.  v0:= temp;
  #L2d7dd4.  return v0;
}
procedure `void` `c`(`byte` v0 , `char`[] v1 @kind object, `int` v2 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.c:(B[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7f0c.  call `i`(v0, v1, v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.i:(B[CI)V` @kind static;
  #L2d7f12.  return @kind void;
}
procedure `boolean` `d`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.d:(B)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7de8.  call temp:= `p`(v0) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.p:(B)Z` @kind static;
  #L2d7dee.  v0:= temp;
  #L2d7df0.  return v0;
}
procedure `void` `e`(`byte` v0 , `byte` v1 , `char`[] v2 @kind object, `int` v3 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.e:(BB[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7f24.  call `k`(v0, v1, v2, v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.k:(BB[CI)V` @kind static;
  #L2d7f2a.  return @kind void;
}
procedure `boolean` `f`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.f:(B)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7e04.  call temp:= `o`(v0) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.o:(B)Z` @kind static;
  #L2d7e0a.  v0:= temp;
  #L2d7e0c.  return v0;
}
procedure `void` `g`(`byte` v0 , `byte` v1 , `byte` v2 , `char`[] v3 @kind object, `int` v4 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.g:(BBB[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L2d7f3c.  call `j`(v0, v1, v2, v3, v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.j:(BBB[CI)V` @kind static;
  #L2d7f42.  return @kind void;
}
procedure `void` `h`(`byte` v2 , `byte` v3 , `byte` v4 , `byte` v5 , `char`[] v6 @kind object, `int` v7 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.h:(BBBB[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L2d7f54.  call temp:= `m`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @kind static;
  #L2d7f5a.  v0:= temp;
  #L2d7f5c.  if v0 != 0 then goto L2d7fd6;
  #L2d7f60.  v0:= v2 ^< 28;
  #L2d7f64.  v1:= v3 + 112;
  #L2d7f68.  v0:= v0 + v1 @kind int;
  #L2d7f6a.  v0:= v0 ^> 30;
  #L2d7f6e.  if v0 != 0 then goto L2d7fd6;
  #L2d7f72.  call temp:= `m`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @kind static;
  #L2d7f78.  v0:= temp;
  #L2d7f7a.  if v0 != 0 then goto L2d7fd6;
  #L2d7f7e.  call temp:= `m`(v5) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @kind static;
  #L2d7f84.  v0:= temp;
  #L2d7f86.  if v0 != 0 then goto L2d7fd6;
  #L2d7f8a.  v2:= v2 ^& 7;
  #L2d7f8e.  v2:= v2 ^< 18;
  #L2d7f92.  call temp:= `r`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @kind static;
  #L2d7f98.  v3:= temp;
  #L2d7f9a.  v3:= v3 ^< 12;
  #L2d7f9e.  v2:= v2 ^| v3 @kind int;
  #L2d7fa0.  call temp:= `r`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @kind static;
  #L2d7fa6.  v3:= temp;
  #L2d7fa8.  v3:= v3 ^< 6;
  #L2d7fac.  v2:= v2 ^| v3 @kind int;
  #L2d7fae.  call temp:= `r`(v5) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @kind static;
  #L2d7fb4.  v3:= temp;
  #L2d7fb6.  v2:= v2 ^| v3 @kind int;
  #L2d7fb8.  call temp:= `l`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.l:(I)C` @kind static;
  #L2d7fbe.  v3:= temp;
  #L2d7fc0.  v6[v7]:= v3 @kind char;
  #L2d7fc4.  v7:= v7 + 1;
  #L2d7fc8.  call temp:= `q`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.q:(I)C` @kind static;
  #L2d7fce.  v2:= temp;
  #L2d7fd0.  v6[v7]:= v2 @kind char;
  #L2d7fd4.  return @kind void;
  #L2d7fd6.  call temp:= `c`() @signature `Lcom/google/crypto/tink/shaded/protobuf/c0;.c:()Lcom/google/crypto/tink/shaded/protobuf/c0;` @kind static;
  #L2d7fdc.  v2:= temp @kind object;
  #L2d7fde.  throw v2;
}
procedure `void` `i`(`byte` v0 , `char`[] v1 @kind object, `int` v2 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.i:(B[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;

  #L2d7ff0.  v0:= (`char`) v0 @kind i2c;
  #L2d7ff2.  v1[v2]:= v0 @kind char;
  #L2d7ff6.  return @kind void;
}
procedure `void` `j`(`byte` v2 , `byte` v3 , `byte` v4 , `char`[] v5 @kind object, `int` v6 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.j:(BBB[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L2d8008.  call temp:= `m`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @kind static;
  #L2d800e.  v0:= temp;
  #L2d8010.  if v0 != 0 then goto L2d8064;
  #L2d8014.  v0:= -32I;
  #L2d8018.  v1:= -96I;
  #L2d801c.  if v2 != v0 then goto L2d8024;
  #L2d8020.  if v3 < v1 then goto L2d8064;
  #L2d8024.  v0:= -19I;
  #L2d8028.  if v2 != v0 then goto L2d8030;
  #L2d802c.  if v3 >= v1 then goto L2d8064;
  #L2d8030.  call temp:= `m`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @kind static;
  #L2d8036.  v0:= temp;
  #L2d8038.  if v0 != 0 then goto L2d8064;
  #L2d803c.  v2:= v2 ^& 15;
  #L2d8040.  v2:= v2 ^< 12;
  #L2d8044.  call temp:= `r`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @kind static;
  #L2d804a.  v3:= temp;
  #L2d804c.  v3:= v3 ^< 6;
  #L2d8050.  v2:= v2 ^| v3 @kind int;
  #L2d8052.  call temp:= `r`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @kind static;
  #L2d8058.  v3:= temp;
  #L2d805a.  v2:= v2 ^| v3 @kind int;
  #L2d805c.  v2:= (`char`) v2 @kind i2c;
  #L2d805e.  v5[v6]:= v2 @kind char;
  #L2d8062.  return @kind void;
  #L2d8064.  call temp:= `c`() @signature `Lcom/google/crypto/tink/shaded/protobuf/c0;.c:()Lcom/google/crypto/tink/shaded/protobuf/c0;` @kind static;
  #L2d806a.  v2:= temp @kind object;
  #L2d806c.  throw v2;
}
procedure `void` `k`(`byte` v1 , `byte` v2 , `char`[] v3 @kind object, `int` v4 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.k:(BB[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L2d8080.  v0:= -62I;
  #L2d8084.  if v1 < v0 then goto L2d80ae;
  #L2d8088.  call temp:= `m`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @kind static;
  #L2d808e.  v0:= temp;
  #L2d8090.  if v0 != 0 then goto L2d80ae;
  #L2d8094.  v1:= v1 ^& 31;
  #L2d8098.  v1:= v1 ^< 6;
  #L2d809c.  call temp:= `r`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @kind static;
  #L2d80a2.  v2:= temp;
  #L2d80a4.  v1:= v1 ^| v2 @kind int;
  #L2d80a6.  v1:= (`char`) v1 @kind i2c;
  #L2d80a8.  v3[v4]:= v1 @kind char;
  #L2d80ac.  return @kind void;
  #L2d80ae.  call temp:= `c`() @signature `Lcom/google/crypto/tink/shaded/protobuf/c0;.c:()Lcom/google/crypto/tink/shaded/protobuf/c0;` @kind static;
  #L2d80b4.  v1:= temp @kind object;
  #L2d80b6.  throw v1;
}
procedure `char` `l`(`int` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.l:(I)C` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L2d7e9c.  v1:= v1 ^>> 10;
  #L2d7ea0.  v0:= 55232I;
  #L2d7ea6.  v1:= v1 + v0 @kind int;
  #L2d7ea8.  v1:= (`char`) v1 @kind i2c;
  #L2d7eaa.  return v1;
}
procedure `boolean` `m`(`byte` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.m:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L2d7e20.  v0:= -65I;
  #L2d7e24.  if v1 <= v0 then goto L2d7e2c;
  #L2d7e28.  v1:= 1I;
  #L2d7e2a.  goto L2d7e2e;
  #L2d7e2c.  v1:= 0I;
  #L2d7e2e.  return v1;
}
procedure `boolean` `n`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.n:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;

  #L2d7e40.  if v0 < 0 then goto L2d7e48;
  #L2d7e44.  v0:= 1I;
  #L2d7e46.  goto L2d7e4a;
  #L2d7e48.  v0:= 0I;
  #L2d7e4a.  return v0;
}
procedure `boolean` `o`(`byte` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.o:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L2d7e5c.  v0:= -16I;
  #L2d7e60.  if v1 >= v0 then goto L2d7e68;
  #L2d7e64.  v1:= 1I;
  #L2d7e66.  goto L2d7e6a;
  #L2d7e68.  v1:= 0I;
  #L2d7e6a.  return v1;
}
procedure `boolean` `p`(`byte` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.p:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L2d7e7c.  v0:= -32I;
  #L2d7e80.  if v1 >= v0 then goto L2d7e88;
  #L2d7e84.  v1:= 1I;
  #L2d7e86.  goto L2d7e8a;
  #L2d7e88.  v1:= 0I;
  #L2d7e8a.  return v1;
}
procedure `char` `q`(`int` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.q:(I)C` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L2d7ebc.  v1:= v1 ^& 1023;
  #L2d7ec0.  v0:= 56320I;
  #L2d7ec6.  v1:= v1 + v0 @kind int;
  #L2d7ec8.  v1:= (`char`) v1 @kind i2c;
  #L2d7eca.  return v1;
}
procedure `int` `r`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/t1$a;.r:(B)I` @AccessFlag PRIVATE_STATIC {
    temp;

  #L2d7edc.  v0:= v0 ^& 63;
  #L2d7ee0.  return v0;
}

record `x5.b` @kind class @AccessFlag PUBLIC_FINAL extends `p5.a` @kind interface {
  `byte`[] `x5.b.a` @AccessFlag PRIVATE_FINAL;
  `byte`[] `x5.b.b` @AccessFlag PRIVATE_FINAL;
  `javax.crypto.spec.SecretKeySpec` `x5.b.c` @AccessFlag PRIVATE_FINAL;
  `int` `x5.b.d` @AccessFlag PRIVATE_FINAL;
}
global `java.lang.ThreadLocal` `@@x5.b.e` @AccessFlag PRIVATE_STATIC_FINAL;
global `java.lang.ThreadLocal` `@@x5.b.f` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lx5/b;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;

  #L4e1ef8.  v0:= new `x5.b$a`;
  #L4e1efc.  call `<init>`(v0) @signature `Lx5/b$a;.<init>:()V` @kind direct;
  #L4e1f02.  `@@x5.b.e` @type ^`java.lang.ThreadLocal` := v0 @kind object;
  #L4e1f06.  v0:= new `x5.b$b`;
  #L4e1f0a.  call `<init>`(v0) @signature `Lx5/b$b;.<init>:()V` @kind direct;
  #L4e1f10.  `@@x5.b.f` @type ^`java.lang.ThreadLocal` := v0 @kind object;
  #L4e1f14.  return @kind void;
}
procedure `void` `<init>`(`x5.b` v2 @kind this, `byte`[] v3 @kind object, `int` v4 ) @signature `Lx5/b;.<init>:([BI)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L4e1f28.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L4e1f2e.  v0:= 16I;
  #L4e1f32.  v1:= 12I;
  #L4e1f36.  if v4 == v1 then goto L4e1f50;
  #L4e1f3a.  if v4 != v0 then goto L4e1f40;
  #L4e1f3e.  goto L4e1f50;
  #L4e1f40.  v3:= new `java.lang.IllegalArgumentException`;
  #L4e1f44.  v4:= "IV size should be either 12 or 16 bytes" @kind object;
  #L4e1f48.  call `<init>`(v3, v4) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L4e1f4e.  throw v3;
  #L4e1f50.  v2.`x5.b.d` @type ^`int` := v4;
  #L4e1f54.  v4:= length @variable v3;
  #L4e1f56.  call `a`(v4) @signature `Lx5/w;.a:(I)V` @kind static;
  #L4e1f5c.  v4:= new `javax.crypto.spec.SecretKeySpec`;
  #L4e1f60.  v1:= "AES" @kind object;
  #L4e1f64.  call `<init>`(v4, v3, v1) @signature `Ljavax/crypto/spec/SecretKeySpec;.<init>:([BLjava/lang/String;)V` @kind direct;
  #L4e1f6a.  v2.`x5.b.c` @type ^`javax.crypto.spec.SecretKeySpec` := v4 @kind object;
  #L4e1f6e.  v3:= `@@x5.b.e` @type ^`java.lang.ThreadLocal` @kind object;
  #L4e1f72.  call temp:= `get`(v3) @signature `Ljava/lang/ThreadLocal;.get:()Ljava/lang/Object;` @kind virtual;
  #L4e1f78.  v3:= temp @kind object;
  #L4e1f7a.  v3:= (`javax.crypto.Cipher`) v3 @kind object;
  #L4e1f7e.  v1:= 1I;
  #L4e1f80.  call `init`(v3, v1, v4) @signature `Ljavax/crypto/Cipher;.init:(ILjava/security/Key;)V` @kind virtual;
  #L4e1f86.  v4:= new `byte`[v0];
  #L4e1f8a.  call temp:= `doFinal`(v3, v4) @signature `Ljavax/crypto/Cipher;.doFinal:([B)[B` @kind virtual;
  #L4e1f90.  v3:= temp @kind object;
  #L4e1f92.  call temp:= `c`(v3) @signature `Lx5/b;.c:([B)[B` @kind static;
  #L4e1f98.  v3:= temp @kind object;
  #L4e1f9a.  v2.`x5.b.a` @type ^`byte`[] := v3 @kind object;
  #L4e1f9e.  call temp:= `c`(v3) @signature `Lx5/b;.c:([B)[B` @kind static;
  #L4e1fa4.  v3:= temp @kind object;
  #L4e1fa6.  v2.`x5.b.b` @type ^`byte`[] := v3 @kind object;
  #L4e1faa.  return @kind void;
}
procedure `byte`[] `c`(`byte`[] v6 @kind object) @signature `Lx5/b;.c:([B)[B` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4e1d40.  v0:= 16I;
  #L4e1d44.  v0:= new `byte`[v0];
  #L4e1d48.  v1:= 0I;
  #L4e1d4a.  v2:= 0I;
  #L4e1d4c.  v3:= 15I;
  #L4e1d50.  if v2 >= v3 then goto L4e1d7c;
  #L4e1d54.  v3:= v6[v2] @kind byte;
  #L4e1d58.  v3:= v3 ^< 1;
  #L4e1d5c.  v4:= v2 + 1;
  #L4e1d60.  v5:= v6[v4] @kind byte;
  #L4e1d64.  v5:= v5 ^& 255;
  #L4e1d68.  v5:= v5 ^>> 7;
  #L4e1d6c.  v3:= v3 ^~ v5 @kind int;
  #L4e1d6e.  v3:= v3 ^& 255;
  #L4e1d72.  v3:= (`byte`) v3 @kind i2b;
  #L4e1d74.  v0[v2]:= v3 @kind byte;
  #L4e1d78.  v2:= v4;
  #L4e1d7a.  goto L4e1d4c;
  #L4e1d7c.  v2:= v6[v3] @kind byte;
  #L4e1d80.  v2:= v2 ^< 1;
  #L4e1d84.  v6:= v6[v1] @kind byte;
  #L4e1d88.  v6:= v6 ^& 128;
  #L4e1d8c.  if v6 != 0 then goto L4e1d92;
  #L4e1d90.  goto L4e1d96;
  #L4e1d92.  v1:= 135I;
  #L4e1d96.  v6:= v2 ^~ v1 @kind int;
  #L4e1d9a.  v6:= (`byte`) v6 @kind i2b;
  #L4e1d9c.  v0[v3]:= v6 @kind byte;
  #L4e1da0.  return v0 @kind object;
}
procedure `byte`[] `d`(`x5.b` v6 @kind this, `javax.crypto.Cipher` v7 @kind object, `int` v8 , `byte`[] v9 @kind object, `int` v10 , `int` v11 ) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4e1db4.  v0:= 16I;
  #L4e1db8.  v1:= new `byte`[v0];
  #L4e1dbc.  v2:= 15I;
  #L4e1dc0.  v8:= (`byte`) v8 @kind i2b;
  #L4e1dc2.  v1[v2]:= v8 @kind byte;
  #L4e1dc6.  if v11 != 0 then goto L4e1de0;
  #L4e1dca.  v8:= v6.`x5.b.a` @type ^`byte`[] @kind object;
  #L4e1dce.  call temp:= `f`(v1, v8) @signature `Lx5/b;.f:([B[B)[B` @kind static;
  #L4e1dd4.  v8:= temp @kind object;
  #L4e1dd6.  call temp:= `doFinal`(v7, v8) @signature `Ljavax/crypto/Cipher;.doFinal:([B)[B` @kind virtual;
  #L4e1ddc.  v7:= temp @kind object;
  #L4e1dde.  return v7 @kind object;
  #L4e1de0.  call temp:= `doFinal`(v7, v1) @signature `Ljavax/crypto/Cipher;.doFinal:([B)[B` @kind virtual;
  #L4e1de6.  v8:= temp @kind object;
  #L4e1de8.  v1:= 0I;
  #L4e1dea.  v2:= 0I;
  #L4e1dec.  v3:= v11 - v2 @kind int;
  #L4e1df0.  if v3 <= v0 then goto L4e1e24;
  #L4e1df4.  v3:= 0I;
  #L4e1df6.  if v3 >= v0 then goto L4e1e16;
  #L4e1dfa.  v4:= v8[v3] @kind byte;
  #L4e1dfe.  v5:= v10 + v2 @kind int;
  #L4e1e02.  v5:= v5 + v3 @kind int;
  #L4e1e04.  v5:= v9[v5] @kind byte;
  #L4e1e08.  v4:= v4 ^~ v5 @kind int;
  #L4e1e0a.  v4:= (`byte`) v4 @kind i2b;
  #L4e1e0c.  v8[v3]:= v4 @kind byte;
  #L4e1e10.  v3:= v3 + 1;
  #L4e1e14.  goto L4e1df6;
  #L4e1e16.  call temp:= `doFinal`(v7, v8) @signature `Ljavax/crypto/Cipher;.doFinal:([B)[B` @kind virtual;
  #L4e1e1c.  v8:= temp @kind object;
  #L4e1e1e.  v2:= v2 + 16;
  #L4e1e22.  goto L4e1dec;
  #L4e1e24.  v2:= v2 + v10 @kind int;
  #L4e1e26.  v10:= v10 + v11 @kind int;
  #L4e1e28.  call temp:= `copyOfRange`(v9, v2, v10) @signature `Ljava/util/Arrays;.copyOfRange:([BII)[B` @kind static;
  #L4e1e2e.  v9:= temp @kind object;
  #L4e1e30.  call temp:= `e`(v6, v9) @signature `Lx5/b;.e:([B)[B` @kind direct;
  #L4e1e36.  v9:= temp @kind object;
  #L4e1e38.  call temp:= `f`(v8, v9) @signature `Lx5/b;.f:([B[B)[B` @kind static;
  #L4e1e3e.  v8:= temp @kind object;
  #L4e1e40.  call temp:= `doFinal`(v7, v8) @signature `Ljavax/crypto/Cipher;.doFinal:([B)[B` @kind virtual;
  #L4e1e46.  v7:= temp @kind object;
  #L4e1e48.  return v7 @kind object;
}
procedure `byte`[] `e`(`x5.b` v4 @kind this, `byte`[] v5 @kind object) @signature `Lx5/b;.e:([B)[B` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4e1e5c.  v0:= length @variable v5;
  #L4e1e5e.  v1:= 16I;
  #L4e1e62.  if v0 != v1 then goto L4e1e74;
  #L4e1e66.  v0:= v4.`x5.b.a` @type ^`byte`[] @kind object;
  #L4e1e6a.  call temp:= `f`(v5, v0) @signature `Lx5/b;.f:([B[B)[B` @kind static;
  #L4e1e70.  v5:= temp @kind object;
  #L4e1e72.  return v5 @kind object;
  #L4e1e74.  v0:= v4.`x5.b.b` @type ^`byte`[] @kind object;
  #L4e1e78.  call temp:= `copyOf`(v0, v1) @signature `Ljava/util/Arrays;.copyOf:([BI)[B` @kind static;
  #L4e1e7e.  v0:= temp @kind object;
  #L4e1e80.  v1:= 0I;
  #L4e1e82.  v2:= length @variable v5;
  #L4e1e84.  if v1 >= v2 then goto L4e1e9e;
  #L4e1e88.  v2:= v0[v1] @kind byte;
  #L4e1e8c.  v3:= v5[v1] @kind byte;
  #L4e1e90.  v2:= v2 ^~ v3 @kind int;
  #L4e1e92.  v2:= (`byte`) v2 @kind i2b;
  #L4e1e94.  v0[v1]:= v2 @kind byte;
  #L4e1e98.  v1:= v1 + 1;
  #L4e1e9c.  goto L4e1e82;
  #L4e1e9e.  v1:= length @variable v5;
  #L4e1ea0.  v5:= length @variable v5;
  #L4e1ea2.  v5:= v0[v5] @kind byte;
  #L4e1ea6.  v5:= v5 ^~ 128;
  #L4e1eaa.  v5:= (`byte`) v5 @kind i2b;
  #L4e1eac.  v0[v1]:= v5 @kind byte;
  #L4e1eb0.  return v0 @kind object;
}
procedure `byte`[] `f`(`byte`[] v5 @kind object, `byte`[] v6 @kind object) @signature `Lx5/b;.f:([B[B)[B` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L4e1ec4.  v0:= length @variable v5;
  #L4e1ec6.  v1:= new `byte`[v0];
  #L4e1eca.  v2:= 0I;
  #L4e1ecc.  if v2 >= v0 then goto L4e1ee6;
  #L4e1ed0.  v3:= v5[v2] @kind byte;
  #L4e1ed4.  v4:= v6[v2] @kind byte;
  #L4e1ed8.  v3:= v3 ^~ v4 @kind int;
  #L4e1eda.  v3:= (`byte`) v3 @kind i2b;
  #L4e1edc.  v1[v2]:= v3 @kind byte;
  #L4e1ee0.  v2:= v2 + 1;
  #L4e1ee4.  goto L4e1ecc;
  #L4e1ee6.  return v1 @kind object;
}
procedure `byte`[] `a`(`x5.b` v15 @kind this, `byte`[] v16 @kind object, `byte`[] v17 @kind object) @signature `Lx5/b;.a:([B[B)[B` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;

  #L4e1c14.  v6:= v15 @kind object;
  #L4e1c16.  v7:= v16 @kind object;
  #L4e1c1a.  v0:= length @variable v7;
  #L4e1c1c.  v1:= v6.`x5.b.d` @type ^`int`;
  #L4e1c20.  v2:= 2147483647I;
  #L4e1c26.  v2:= v2 - v1 @kind int;
  #L4e1c28.  v8:= 16I;
  #L4e1c2c.  v2:= v2 - v8 @kind int;
  #L4e1c2e.  if v0 > v2 then goto L4e1d1e;
  #L4e1c32.  v0:= length @variable v7;
  #L4e1c34.  v0:= v0 + v1 @kind int;
  #L4e1c36.  v0:= v0 + v8 @kind int;
  #L4e1c38.  v9:= new `byte`[v0];
  #L4e1c3c.  call temp:= `c`(v1) @signature `Lx5/u;.c:(I)[B` @kind static;
  #L4e1c42.  v3:= temp @kind object;
  #L4e1c44.  v0:= v6.`x5.b.d` @type ^`int`;
  #L4e1c48.  v10:= 0I;
  #L4e1c4a.  call `arraycopy`(v3, v10, v9, v10, v0) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4e1c50.  v0:= `@@x5.b.e` @type ^`java.lang.ThreadLocal` @kind object;
  #L4e1c54.  call temp:= `get`(v0) @signature `Ljava/lang/ThreadLocal;.get:()Ljava/lang/Object;` @kind virtual;
  #L4e1c5a.  v0:= temp @kind object;
  #L4e1c5c.  v11:= v0 @kind object;
  #L4e1c5e.  v11:= (`javax.crypto.Cipher`) v11 @kind object;
  #L4e1c62.  v0:= v6.`x5.b.c` @type ^`javax.crypto.spec.SecretKeySpec` @kind object;
  #L4e1c66.  v12:= 1I;
  #L4e1c68.  call `init`(v11, v12, v0) @signature `Ljavax/crypto/Cipher;.init:(ILjava/security/Key;)V` @kind virtual;
  #L4e1c6e.  v2:= 0I;
  #L4e1c70.  v4:= 0I;
  #L4e1c72.  v5:= length @variable v3;
  #L4e1c74.  v0:= v15 @kind object;
  #L4e1c76.  v1:= v11 @kind object;
  #L4e1c78.  call temp:= `d`(v0, v1, v2, v3, v4, v5) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @kind direct;
  #L4e1c7e.  v13:= temp @kind object;
  #L4e1c80.  if v17 != 0 then goto L4e1c8c;
  #L4e1c84.  v0:= new `byte`[v10];
  #L4e1c88.  v3:= v0 @kind object;
  #L4e1c8a.  goto L4e1c90;
  #L4e1c8c.  v3:= v17 @kind object;
  #L4e1c90.  v2:= 1I;
  #L4e1c92.  v4:= 0I;
  #L4e1c94.  v5:= length @variable v3;
  #L4e1c96.  v0:= v15 @kind object;
  #L4e1c98.  v1:= v11 @kind object;
  #L4e1c9a.  call temp:= `d`(v0, v1, v2, v3, v4, v5) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @kind direct;
  #L4e1ca0.  v14:= temp @kind object;
  #L4e1ca2.  v0:= `@@x5.b.f` @type ^`java.lang.ThreadLocal` @kind object;
  #L4e1ca6.  call temp:= `get`(v0) @signature `Ljava/lang/ThreadLocal;.get:()Ljava/lang/Object;` @kind virtual;
  #L4e1cac.  v0:= temp @kind object;
  #L4e1cae.  v0:= (`javax.crypto.Cipher`) v0 @kind object;
  #L4e1cb2.  v1:= v6.`x5.b.c` @type ^`javax.crypto.spec.SecretKeySpec` @kind object;
  #L4e1cb6.  v2:= new `javax.crypto.spec.IvParameterSpec`;
  #L4e1cba.  call `<init>`(v2, v13) @signature `Ljavax/crypto/spec/IvParameterSpec;.<init>:([B)V` @kind direct;
  #L4e1cc0.  call `init`(v0, v12, v1, v2) @signature `Ljavax/crypto/Cipher;.init:(ILjava/security/Key;Ljava/security/spec/AlgorithmParameterSpec;)V` @kind virtual;
  #L4e1cc6.  v2:= 0I;
  #L4e1cc8.  v3:= length @variable v7;
  #L4e1cca.  v5:= v6.`x5.b.d` @type ^`int`;
  #L4e1cce.  v1:= v16 @kind object;
  #L4e1cd2.  v4:= v9 @kind object;
  #L4e1cd4.  call temp:= `doFinal`(v0, v1, v2, v3, v4, v5) @signature `Ljavax/crypto/Cipher;.doFinal:([BII[BI)I` @kind virtual;
  #L4e1cda.  v2:= 2I;
  #L4e1cdc.  v4:= v6.`x5.b.d` @type ^`int`;
  #L4e1ce0.  v5:= length @variable v7;
  #L4e1ce2.  v0:= v15 @kind object;
  #L4e1ce4.  v1:= v11 @kind object;
  #L4e1ce6.  v3:= v9 @kind object;
  #L4e1ce8.  call temp:= `d`(v0, v1, v2, v3, v4, v5) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @kind direct;
  #L4e1cee.  v0:= temp @kind object;
  #L4e1cf0.  v1:= length @variable v7;
  #L4e1cf2.  v2:= v6.`x5.b.d` @type ^`int`;
  #L4e1cf6.  v1:= v1 + v2 @kind int;
  #L4e1cf8.  if v10 >= v8 then goto L4e1d1c;
  #L4e1cfc.  v2:= v1 + v10 @kind int;
  #L4e1d00.  v3:= v14[v10] @kind byte;
  #L4e1d04.  v4:= v13[v10] @kind byte;
  #L4e1d08.  v3:= v3 ^~ v4 @kind int;
  #L4e1d0a.  v4:= v0[v10] @kind byte;
  #L4e1d0e.  v3:= v3 ^~ v4 @kind int;
  #L4e1d10.  v3:= (`byte`) v3 @kind i2b;
  #L4e1d12.  v9[v2]:= v3 @kind byte;
  #L4e1d16.  v10:= v10 + 1;
  #L4e1d1a.  goto L4e1cf8;
  #L4e1d1c.  return v9 @kind object;
  #L4e1d1e.  v0:= new `java.security.GeneralSecurityException`;
  #L4e1d22.  v1:= "plaintext too long" @kind object;
  #L4e1d26.  call `<init>`(v0, v1) @signature `Ljava/security/GeneralSecurityException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L4e1d2c.  throw v0;
}
procedure `byte`[] `b`(`x5.b` v13 @kind this, `byte`[] v14 @kind object, `byte`[] v15 @kind object) @signature `Lx5/b;.b:([B[B)[B` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;

  #L4e1b04.  v0:= length @variable v14;
  #L4e1b06.  v1:= v13.`x5.b.d` @type ^`int`;
  #L4e1b0a.  v0:= v0 - v1 @kind int;
  #L4e1b0c.  v1:= 16I;
  #L4e1b10.  v0:= v0 - v1 @kind int;
  #L4e1b12.  if v0 < 0 then goto L4e1bf2;
  #L4e1b16.  v2:= `@@x5.b.e` @type ^`java.lang.ThreadLocal` @kind object;
  #L4e1b1a.  call temp:= `get`(v2) @signature `Ljava/lang/ThreadLocal;.get:()Ljava/lang/Object;` @kind virtual;
  #L4e1b20.  v2:= temp @kind object;
  #L4e1b22.  v9:= v2 @kind object;
  #L4e1b24.  v9:= (`javax.crypto.Cipher`) v9 @kind object;
  #L4e1b28.  v2:= v13.`x5.b.c` @type ^`javax.crypto.spec.SecretKeySpec` @kind object;
  #L4e1b2c.  v10:= 1I;
  #L4e1b2e.  call `init`(v9, v10, v2) @signature `Ljavax/crypto/Cipher;.init:(ILjava/security/Key;)V` @kind virtual;
  #L4e1b34.  v5:= 0I;
  #L4e1b36.  v7:= 0I;
  #L4e1b38.  v8:= v13.`x5.b.d` @type ^`int`;
  #L4e1b3c.  v3:= v13 @kind object;
  #L4e1b3e.  v4:= v9 @kind object;
  #L4e1b40.  v6:= v14 @kind object;
  #L4e1b42.  call temp:= `d`(v3, v4, v5, v6, v7, v8) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @kind direct;
  #L4e1b48.  v11:= temp @kind object;
  #L4e1b4a.  v12:= 0I;
  #L4e1b4c.  if v15 != 0 then goto L4e1b54;
  #L4e1b50.  v15:= new `byte`[v12];
  #L4e1b54.  v6:= v15 @kind object;
  #L4e1b56.  v5:= 1I;
  #L4e1b58.  v7:= 0I;
  #L4e1b5a.  v8:= length @variable v6;
  #L4e1b5c.  v3:= v13 @kind object;
  #L4e1b5e.  v4:= v9 @kind object;
  #L4e1b60.  call temp:= `d`(v3, v4, v5, v6, v7, v8) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @kind direct;
  #L4e1b66.  v15:= temp @kind object;
  #L4e1b68.  v4:= 2I;
  #L4e1b6a.  v6:= v13.`x5.b.d` @type ^`int`;
  #L4e1b6e.  v2:= v13 @kind object;
  #L4e1b70.  v3:= v9 @kind object;
  #L4e1b72.  v5:= v14 @kind object;
  #L4e1b74.  v7:= v0;
  #L4e1b76.  call temp:= `d`(v2, v3, v4, v5, v6, v7) @signature `Lx5/b;.d:(Ljavax/crypto/Cipher;I[BII)[B` @kind direct;
  #L4e1b7c.  v2:= temp @kind object;
  #L4e1b7e.  v3:= length @variable v14;
  #L4e1b80.  v3:= v3 - v1 @kind int;
  #L4e1b82.  v4:= 0I;
  #L4e1b84.  if v12 >= v1 then goto L4e1bac;
  #L4e1b88.  v5:= v3 + v12 @kind int;
  #L4e1b8c.  v5:= v14[v5] @kind byte;
  #L4e1b90.  v6:= v15[v12] @kind byte;
  #L4e1b94.  v5:= v5 ^~ v6 @kind int;
  #L4e1b96.  v6:= v11[v12] @kind byte;
  #L4e1b9a.  v5:= v5 ^~ v6 @kind int;
  #L4e1b9c.  v6:= v2[v12] @kind byte;
  #L4e1ba0.  v5:= v5 ^~ v6 @kind int;
  #L4e1ba2.  v4:= v4 ^| v5 @kind int;
  #L4e1ba4.  v4:= (`byte`) v4 @kind i2b;
  #L4e1ba6.  v12:= v12 + 1;
  #L4e1baa.  goto L4e1b84;
  #L4e1bac.  if v4 != 0 then goto L4e1be2;
  #L4e1bb0.  v15:= `@@x5.b.f` @type ^`java.lang.ThreadLocal` @kind object;
  #L4e1bb4.  call temp:= `get`(v15) @signature `Ljava/lang/ThreadLocal;.get:()Ljava/lang/Object;` @kind virtual;
  #L4e1bba.  v15:= temp @kind object;
  #L4e1bbc.  v15:= (`javax.crypto.Cipher`) v15 @kind object;
  #L4e1bc0.  v1:= v13.`x5.b.c` @type ^`javax.crypto.spec.SecretKeySpec` @kind object;
  #L4e1bc4.  v2:= new `javax.crypto.spec.IvParameterSpec`;
  #L4e1bc8.  call `<init>`(v2, v11) @signature `Ljavax/crypto/spec/IvParameterSpec;.<init>:([B)V` @kind direct;
  #L4e1bce.  call `init`(v15, v10, v1, v2) @signature `Ljavax/crypto/Cipher;.init:(ILjava/security/Key;Ljava/security/spec/AlgorithmParameterSpec;)V` @kind virtual;
  #L4e1bd4.  v1:= v13.`x5.b.d` @type ^`int`;
  #L4e1bd8.  call temp:= `doFinal`(v15, v14, v1, v0) @signature `Ljavax/crypto/Cipher;.doFinal:([BII)[B` @kind virtual;
  #L4e1bde.  v14:= temp @kind object;
  #L4e1be0.  return v14 @kind object;
  #L4e1be2.  v14:= new `javax.crypto.AEADBadTagException`;
  #L4e1be6.  v15:= "tag mismatch" @kind object;
  #L4e1bea.  call `<init>`(v14, v15) @signature `Ljavax/crypto/AEADBadTagException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L4e1bf0.  throw v14;
  #L4e1bf2.  v14:= new `java.security.GeneralSecurityException`;
  #L4e1bf6.  v15:= "ciphertext too short" @kind object;
  #L4e1bfa.  call `<init>`(v14, v15) @signature `Ljava/security/GeneralSecurityException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L4e1c00.  throw v14;
}

record `cc.a` @kind class @AccessFlag PUBLIC_ABSTRACT extends `cc.c` @kind class, `cc.f` @kind interface {
}
procedure `void` `<init>`(`cc.a` v0 @kind this, `tb.l` v1 @kind object) @signature `Lcc/a;.<init>:(Ltb/l;)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L1fa68c.  call `<init>`(v0, v1) @signature `Lcc/c;.<init>:(Ltb/l;)V` @kind direct;
  #L1fa692.  return @kind void;
}
procedure `boolean` `n`(`cc.a` v0 @kind object, `cc.o` v1 @kind object) @signature `Lcc/a;.n:(Lcc/a;Lcc/o;)Z` @AccessFlag PUBLIC_STATIC_FINAL_SYNTHETIC {
    temp;

  #L1fa508.  call temp:= `p`(v0, v1) @signature `Lcc/a;.p:(Lcc/o;)Z` @kind direct;
  #L1fa50e.  v0:= temp;
  #L1fa510.  return v0;
}
procedure `void` `o`(`cc.a` v0 @kind object, `ac.k` v1 @kind object, `cc.o` v2 @kind object) @signature `Lcc/a;.o:(Lcc/a;Lac/k;Lcc/o;)V` @AccessFlag PUBLIC_STATIC_FINAL_SYNTHETIC {
    temp;

  #L1fa6a4.  call `w`(v0, v1, v2) @signature `Lcc/a;.w:(Lac/k;Lcc/o;)V` @kind direct;
  #L1fa6aa.  return @kind void;
}
procedure `boolean` `p`(`cc.a` v0 @kind this, `cc.o` v1 @kind object) @signature `Lcc/a;.p:(Lcc/o;)Z` @AccessFlag PRIVATE_FINAL {
    temp;

  #L1fa524.  call temp:= `q`(v0, v1) @signature `Lcc/a;.q:(Lcc/o;)Z` @kind virtual;
  #L1fa52a.  v1:= temp;
  #L1fa52c.  if v1 == 0 then goto L1fa536;
  #L1fa530.  call `u`(v0) @signature `Lcc/a;.u:()V` @kind virtual;
  #L1fa536.  return v1;
}
procedure `void` `w`(`cc.a` v1 @kind this, `ac.k` v2 @kind object, `cc.o` v3 @kind object) @signature `Lcc/a;.w:(Lac/k;Lcc/o;)V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;

  #L1fa6e4.  v0:= new `cc.a$c`;
  #L1fa6e8.  call `<init>`(v0, v1, v3) @signature `Lcc/a$c;.<init>:(Lcc/a;Lcc/o;)V` @kind direct;
  #L1fa6ee.  call `j`(v2, v0) @signature `Lac/k;.j:(Ltb/l;)V` @kind interface;
  #L1fa6f4.  return @kind void;
}
procedure `cc.g` `iterator`(`cc.a` v1 @kind this) @signature `Lcc/a;.iterator:()Lcc/g;` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;

  #L1fa5d0.  v0:= new `cc.a$a`;
  #L1fa5d4.  call `<init>`(v0, v1) @signature `Lcc/a$a;.<init>:(Lcc/a;)V` @kind direct;
  #L1fa5da.  return v0 @kind object;
}
procedure `cc.q` `l`(`cc.a` v2 @kind this) @signature `Lcc/a;.l:()Lcc/q;` @AccessFlag PROTECTED {
    temp;
    v0;
    v1;

  #L1fa5ec.  call temp:= `l`(v2) @signature `Lcc/c;.l:()Lcc/q;` @kind super;
  #L1fa5f2.  v0:= temp @kind object;
  #L1fa5f4.  if v0 == 0 then goto L1fa606;
  #L1fa5f8.  v1:= instanceof @variable v0 @type ^`cc.j` @kind boolean;
  #L1fa5fc.  if v1 != 0 then goto L1fa606;
  #L1fa600.  call `t`(v2) @signature `Lcc/a;.t:()V` @kind virtual;
  #L1fa606.  return v0 @kind object;
}
procedure `boolean` `q`(`cc.a` v6 @kind this, `cc.o` v7 @kind object) @signature `Lcc/a;.q:(Lcc/o;)Z` @AccessFlag PROTECTED {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L1fa548.  call temp:= `r`(v6) @signature `Lcc/a;.r:()Z` @kind virtual;
  #L1fa54e.  v0:= temp;
  #L1fa550.  v1:= 0I;
  #L1fa552.  v2:= 1I;
  #L1fa554.  if v0 == 0 then goto L1fa582;
  #L1fa558.  call temp:= `e`(v6) @signature `Lcc/c;.e:()Lkotlinx/coroutines/internal/p;` @kind virtual;
  #L1fa55e.  v0:= temp @kind object;
  #L1fa560.  call temp:= `q`(v0) @signature `Lkotlinx/coroutines/internal/r;.q:()Lkotlinx/coroutines/internal/r;` @kind virtual;
  #L1fa566.  v3:= temp @kind object;
  #L1fa568.  v4:= instanceof @variable v3 @type ^`cc.s` @kind boolean;
  #L1fa56c.  v4:= v4 ^~ v2 @kind int;
  #L1fa56e.  if v4 != 0 then goto L1fa574;
  #L1fa572.  goto L1fa5be;
  #L1fa574.  call temp:= `j`(v3, v7, v0) @signature `Lkotlinx/coroutines/internal/r;.j:(Lkotlinx/coroutines/internal/r;Lkotlinx/coroutines/internal/r;)Z` @kind virtual;
  #L1fa57a.  v3:= temp;
  #L1fa57c.  if v3 == 0 then goto L1fa560;
  #L1fa580.  goto L1fa5bc;
  #L1fa582.  call temp:= `e`(v6) @signature `Lcc/c;.e:()Lkotlinx/coroutines/internal/p;` @kind virtual;
  #L1fa588.  v0:= temp @kind object;
  #L1fa58a.  v3:= new `cc.a$d`;
  #L1fa58e.  call `<init>`(v3, v7, v6) @signature `Lcc/a$d;.<init>:(Lkotlinx/coroutines/internal/r;Lcc/a;)V` @kind direct;
  #L1fa594.  call temp:= `q`(v0) @signature `Lkotlinx/coroutines/internal/r;.q:()Lkotlinx/coroutines/internal/r;` @kind virtual;
  #L1fa59a.  v4:= temp @kind object;
  #L1fa59c.  v5:= instanceof @variable v4 @type ^`cc.s` @kind boolean;
  #L1fa5a0.  v5:= v5 ^~ v2 @kind int;
  #L1fa5a2.  if v5 != 0 then goto L1fa5a8;
  #L1fa5a6.  goto L1fa5be;
  #L1fa5a8.  call temp:= `x`(v4, v7, v0, v3) @signature `Lkotlinx/coroutines/internal/r;.x:(Lkotlinx/coroutines/internal/r;Lkotlinx/coroutines/internal/r;Lkotlinx/coroutines/internal/r$a;)I` @kind virtual;
  #L1fa5ae.  v4:= temp;
  #L1fa5b0.  if v4 == v2 then goto L1fa5bc;
  #L1fa5b4.  v5:= 2I;
  #L1fa5b6.  if v4 == v5 then goto L1fa5be;
  #L1fa5ba.  goto L1fa594;
  #L1fa5bc.  v1:= 1I;
  #L1fa5be.  return v1;
}
procedure `boolean` `r`() @signature `Lcc/a;.r:()Z` @AccessFlag PROTECTED_ABSTRACT {

  # return;
}
procedure `boolean` `s`() @signature `Lcc/a;.s:()Z` @AccessFlag PROTECTED_ABSTRACT {

  # return;
}
procedure `void` `t`(`cc.a` v0 @kind this) @signature `Lcc/a;.t:()V` @AccessFlag PROTECTED {
    temp;

  #L1fa6bc.  return @kind void;
}
procedure `void` `u`(`cc.a` v0 @kind this) @signature `Lcc/a;.u:()V` @AccessFlag PROTECTED {
    temp;

  #L1fa6d0.  return @kind void;
}
procedure `java.lang.Object` `v`(`cc.a` v3 @kind this) @signature `Lcc/a;.v:()Ljava/lang/Object;` @AccessFlag PROTECTED {
    temp;
    v0;
    v1;
    v2;

  #L1fa618.  call temp:= `m`(v3) @signature `Lcc/c;.m:()Lcc/s;` @kind virtual;
  #L1fa61e.  v0:= temp @kind object;
  #L1fa620.  if v0 != 0 then goto L1fa62a;
  #L1fa624.  v0:= `@@cc.b.d` @type ^`kotlinx.coroutines.internal.f0` @kind object;
  #L1fa628.  return v0 @kind object;
  #L1fa62a.  v1:= 0I;
  #L1fa62c.  call temp:= `A`(v0, v1) @signature `Lcc/s;.A:(Lkotlinx/coroutines/internal/r$b;)Lkotlinx/coroutines/internal/f0;` @kind virtual;
  #L1fa632.  v1:= temp @kind object;
  #L1fa634.  if v1 == 0 then goto L1fa674;
  #L1fa638.  call temp:= `a`() @signature `Lac/p0;.a:()Z` @kind static;
  #L1fa63e.  v2:= temp;
  #L1fa640.  if v2 == 0 then goto L1fa664;
  #L1fa644.  v2:= `@@ac.m.a` @type ^`kotlinx.coroutines.internal.f0` @kind object;
  #L1fa648.  if v1 != v2 then goto L1fa650;
  #L1fa64c.  v1:= 1I;
  #L1fa64e.  goto L1fa652;
  #L1fa650.  v1:= 0I;
  #L1fa652.  if v1 == 0 then goto L1fa658;
  #L1fa656.  goto L1fa664;
  #L1fa658.  v0:= new `java.lang.AssertionError`;
  #L1fa65c.  call `<init>`(v0) @signature `Ljava/lang/AssertionError;.<init>:()V` @kind direct;
  #L1fa662.  throw v0;
  #L1fa664.  call `y`(v0) @signature `Lcc/s;.y:()V` @kind virtual;
  #L1fa66a.  call temp:= `z`(v0) @signature `Lcc/s;.z:()Ljava/lang/Object;` @kind virtual;
  #L1fa670.  v0:= temp @kind object;
  #L1fa672.  return v0 @kind object;
  #L1fa674.  call `B`(v0) @signature `Lcc/s;.B:()V` @kind virtual;
  #L1fa67a.  goto L1fa618;
}

record `x2.m` @kind class @AccessFlag FINAL extends `r3.l` @kind interface {
  `r3.l` `x2.m.a` @AccessFlag PRIVATE_FINAL;
  `int` `x2.m.b` @AccessFlag PRIVATE_FINAL;
  `x2.m$a` `x2.m.c` @AccessFlag PRIVATE_FINAL;
  `byte`[] `x2.m.d` @AccessFlag PRIVATE_FINAL;
  `int` `x2.m.e` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`x2.m` v2 @kind this, `r3.l` v3 @kind object, `int` v4 , `x2.m$a` v5 @kind object) @signature `Lx2/m;.<init>:(Lr3/l;ILx2/m$a;)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L4dac64.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L4dac6a.  v0:= 1I;
  #L4dac6c.  if v4 <= 0 then goto L4dac74;
  #L4dac70.  v1:= 1I;
  #L4dac72.  goto L4dac76;
  #L4dac74.  v1:= 0I;
  #L4dac76.  call `a`(v1) @signature `Ls3/a;.a:(Z)V` @kind static;
  #L4dac7c.  v2.`x2.m.a` @type ^`r3.l` := v3 @kind object;
  #L4dac80.  v2.`x2.m.b` @type ^`int` := v4;
  #L4dac84.  v2.`x2.m.c` @type ^`x2.m$a` := v5 @kind object;
  #L4dac88.  v3:= new `byte`[v0];
  #L4dac8c.  v2.`x2.m.d` @type ^`byte`[] := v3 @kind object;
  #L4dac90.  v2.`x2.m.e` @type ^`int` := v4;
  #L4dac94.  return @kind void;
}
procedure `boolean` `r`(`x2.m` v8 @kind this) @signature `Lx2/m;.r:()Z` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L4dab34.  v0:= v8.`x2.m.a` @type ^`r3.l` @kind object;
  #L4dab38.  v1:= v8.`x2.m.d` @type ^`byte`[] @kind object;
  #L4dab3c.  v2:= 0I;
  #L4dab3e.  v3:= 1I;
  #L4dab40.  call temp:= `b`(v0, v1, v2, v3) @signature `Lr3/i;.b:([BII)I` @kind interface;
  #L4dab46.  v0:= temp;
  #L4dab48.  v1:= -1I;
  #L4dab4a.  if v0 != v1 then goto L4dab50;
  #L4dab4e.  return v2;
  #L4dab50.  v0:= v8.`x2.m.d` @type ^`byte`[] @kind object;
  #L4dab54.  v0:= v0[v2] @kind byte;
  #L4dab58.  v0:= v0 ^& 255;
  #L4dab5c.  v0:= v0 ^< 4;
  #L4dab60.  if v0 != 0 then goto L4dab66;
  #L4dab64.  return v3;
  #L4dab66.  v4:= new `byte`[v0];
  #L4dab6a.  v5:= v0;
  #L4dab6c.  v6:= 0I;
  #L4dab6e.  if v5 <= 0 then goto L4dab8a;
  #L4dab72.  v7:= v8.`x2.m.a` @type ^`r3.l` @kind object;
  #L4dab76.  call temp:= `b`(v7, v4, v6, v5) @signature `Lr3/i;.b:([BII)I` @kind interface;
  #L4dab7c.  v7:= temp;
  #L4dab7e.  if v7 != v1 then goto L4dab84;
  #L4dab82.  return v2;
  #L4dab84.  v6:= v6 + v7 @kind int;
  #L4dab86.  v5:= v5 - v7 @kind int;
  #L4dab88.  goto L4dab6e;
  #L4dab8a.  if v0 <= 0 then goto L4daba0;
  #L4dab8e.  v1:= v0 + -1;
  #L4dab92.  v1:= v4[v1] @kind byte;
  #L4dab96.  if v1 != 0 then goto L4daba0;
  #L4dab9a.  v0:= v0 + -1;
  #L4dab9e.  goto L4dab8a;
  #L4daba0.  if v0 <= 0 then goto L4dabb8;
  #L4daba4.  v1:= v8.`x2.m.c` @type ^`x2.m$a` @kind object;
  #L4daba8.  v2:= new `s3.z`;
  #L4dabac.  call `<init>`(v2, v4, v0) @signature `Ls3/z;.<init>:([BI)V` @kind direct;
  #L4dabb2.  call `c`(v1, v2) @signature `Lx2/m$a;.c:(Ls3/z;)V` @kind interface;
  #L4dabb8.  return v3;
}
procedure `int` `b`(`x2.m` v3 @kind this, `byte`[] v4 @kind object, `int` v5 , `int` v6 ) @signature `Lx2/m;.b:([BII)I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4dabcc.  v0:= v3.`x2.m.e` @type ^`int`;
  #L4dabd0.  v1:= -1I;
  #L4dabd2.  if v0 != 0 then goto L4dabee;
  #L4dabd6.  call temp:= `r`(v3) @signature `Lx2/m;.r:()Z` @kind direct;
  #L4dabdc.  v0:= temp;
  #L4dabde.  if v0 == 0 then goto L4dabec;
  #L4dabe2.  v0:= v3.`x2.m.b` @type ^`int`;
  #L4dabe6.  v3.`x2.m.e` @type ^`int` := v0;
  #L4dabea.  goto L4dabee;
  #L4dabec.  return v1;
  #L4dabee.  v0:= v3.`x2.m.a` @type ^`r3.l` @kind object;
  #L4dabf2.  v2:= v3.`x2.m.e` @type ^`int`;
  #L4dabf6.  call temp:= `min`(v2, v6) @signature `Ljava/lang/Math;.min:(II)I` @kind static;
  #L4dabfc.  v6:= temp;
  #L4dabfe.  call temp:= `b`(v0, v4, v5, v6) @signature `Lr3/i;.b:([BII)I` @kind interface;
  #L4dac04.  v4:= temp;
  #L4dac06.  if v4 == v1 then goto L4dac14;
  #L4dac0a.  v5:= v3.`x2.m.e` @type ^`int`;
  #L4dac0e.  v5:= v5 - v4 @kind int;
  #L4dac10.  v3.`x2.m.e` @type ^`int` := v5;
  #L4dac14.  return v4;
}
procedure `void` `c`(`x2.m` v1 @kind this, `r3.p0` v2 @kind object) @signature `Lx2/m;.c:(Lr3/p0;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4daca8.  call temp:= `e`(v2) @signature `Ls3/a;.e:(Ljava/lang/Object;)Ljava/lang/Object;` @kind static;
  #L4dacae.  v0:= v1.`x2.m.a` @type ^`r3.l` @kind object;
  #L4dacb2.  call `c`(v0, v2) @signature `Lr3/l;.c:(Lr3/p0;)V` @kind interface;
  #L4dacb8.  return @kind void;
}
procedure `void` `close`(`x2.m` v1 @kind this) @signature `Lx2/m;.close:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4daccc.  v0:= new `java.lang.UnsupportedOperationException`;
  #L4dacd0.  call `<init>`(v0) @signature `Ljava/lang/UnsupportedOperationException;.<init>:()V` @kind direct;
  #L4dacd6.  throw v0;
}
procedure `long` `e`(`x2.m` v0 @kind this, `r3.p` v1 @kind object) @signature `Lx2/m;.e:(Lr3/p;)J` @AccessFlag PUBLIC {
    temp;

  #L4dac48.  v1:= new `java.lang.UnsupportedOperationException`;
  #L4dac4c.  call `<init>`(v1) @signature `Ljava/lang/UnsupportedOperationException;.<init>:()V` @kind direct;
  #L4dac52.  throw v1;
}
procedure `java.util.Map` `h`(`x2.m` v1 @kind this) @signature `Lx2/m;.h:()Ljava/util/Map;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4dac28.  v0:= v1.`x2.m.a` @type ^`r3.l` @kind object;
  #L4dac2c.  call temp:= `h`(v0) @signature `Lr3/l;.h:()Ljava/util/Map;` @kind interface;
  #L4dac32.  v0:= temp @kind object;
  #L4dac34.  return v0 @kind object;
}
procedure `android.net.Uri` `l`(`x2.m` v1 @kind this) @signature `Lx2/m;.l:()Landroid/net/Uri;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4dab14.  v0:= v1.`x2.m.a` @type ^`r3.l` @kind object;
  #L4dab18.  call temp:= `l`(v0) @signature `Lr3/l;.l:()Landroid/net/Uri;` @kind interface;
  #L4dab1e.  v0:= temp @kind object;
  #L4dab20.  return v0 @kind object;
}

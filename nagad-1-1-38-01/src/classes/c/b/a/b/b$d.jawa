record `c.b.a.b.b$d` @kind class @AccessFlag  extends `java.util.Iterator` @kind interface, `c.b.a.b.b$f` @kind interface {
  `c.b.a.b.b$c` `c.b.a.b.b$d.f` @AccessFlag PRIVATE;
  `boolean` `c.b.a.b.b$d.g` @AccessFlag PRIVATE;
  `c.b.a.b.b` `c.b.a.b.b$d.h` @AccessFlag FINAL_SYNTHETIC;
}
procedure `void` `<init>`(`c.b.a.b.b$d` v0 @kind this, `c.b.a.b.b` v1 @kind object) @signature `Lc/b/a/b/b$d;.<init>:(Lc/b/a/b/b;)V` @AccessFlag CONSTRUCTOR {
    temp;

  #L1c12dc.  v0.`c.b.a.b.b$d.h` @type ^`c.b.a.b.b` := v1 @kind object;
  #L1c12e0.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L1c12e6.  v1:= 1I;
  #L1c12e8.  v0.`c.b.a.b.b$d.g` @type ^`boolean` := v1 @kind boolean;
  #L1c12ec.  return @kind void;
}
procedure `boolean` `hasNext`(`c.b.a.b.b$d` v3 @kind this) @signature `Lc/b/a/b/b$d;.hasNext:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L1c1234.  v0:= v3.`c.b.a.b.b$d.g` @type ^`boolean` @kind boolean;
  #L1c1238.  v1:= 1I;
  #L1c123a.  v2:= 0I;
  #L1c123c.  if v0 == 0 then goto L1c1252;
  #L1c1240.  v0:= v3.`c.b.a.b.b$d.h` @type ^`c.b.a.b.b` @kind object;
  #L1c1244.  v0:= v0.`c.b.a.b.b.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c1248.  if v0 == 0 then goto L1c124e;
  #L1c124c.  goto L1c1250;
  #L1c124e.  v1:= 0I;
  #L1c1250.  return v1;
  #L1c1252.  v0:= v3.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c1256.  if v0 == 0 then goto L1c1264;
  #L1c125a.  v0:= v0.`c.b.a.b.b$c.h` @type ^`c.b.a.b.b$c` @kind object;
  #L1c125e.  if v0 == 0 then goto L1c1264;
  #L1c1262.  goto L1c1266;
  #L1c1264.  v1:= 0I;
  #L1c1266.  return v1;
}
procedure `java.lang.Object` `next`(`c.b.a.b.b$d` v1 @kind this) @signature `Lc/b/a/b/b$d;.next:()Ljava/lang/Object;` @AccessFlag PUBLIC_SYNTHETIC {
    temp;
    v0;

  #L1c1278.  call temp:= `next`(v1) @signature `Lc/b/a/b/b$d;.next:()Ljava/util/Map$Entry;` @kind virtual;
  #L1c127e.  v0:= temp @kind object;
  #L1c1280.  return v0 @kind object;
}
procedure `java.util.Map$Entry` `next`(`c.b.a.b.b$d` v1 @kind this) @signature `Lc/b/a/b/b$d;.next:()Ljava/util/Map$Entry;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1c1294.  v0:= v1.`c.b.a.b.b$d.g` @type ^`boolean` @kind boolean;
  #L1c1298.  if v0 == 0 then goto L1c12b0;
  #L1c129c.  v0:= 0I;
  #L1c129e.  v1.`c.b.a.b.b$d.g` @type ^`boolean` := v0 @kind boolean;
  #L1c12a2.  v0:= v1.`c.b.a.b.b$d.h` @type ^`c.b.a.b.b` @kind object;
  #L1c12a6.  v0:= v0.`c.b.a.b.b.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c12aa.  v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` := v0 @kind object;
  #L1c12ae.  goto L1c12c4;
  #L1c12b0.  v0:= v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c12b4.  if v0 == 0 then goto L1c12be;
  #L1c12b8.  v0:= v0.`c.b.a.b.b$c.h` @type ^`c.b.a.b.b$c` @kind object;
  #L1c12bc.  goto L1c12c0;
  #L1c12be.  v0:= 0I;
  #L1c12c0.  v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` := v0 @kind object;
  #L1c12c4.  v0:= v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c12c8.  return v0 @kind object;
}
procedure `void` `supportRemove`(`c.b.a.b.b$d` v1 @kind this, `c.b.a.b.b$c` v2 @kind object) @signature `Lc/b/a/b/b$d;.supportRemove:(Lc/b/a/b/b$c;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1c1300.  v0:= v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c1304.  if v2 != v0 then goto L1c1322;
  #L1c1308.  v2:= v0.`c.b.a.b.b$c.i` @type ^`c.b.a.b.b$c` @kind object;
  #L1c130c.  v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` := v2 @kind object;
  #L1c1310.  v2:= v1.`c.b.a.b.b$d.f` @type ^`c.b.a.b.b$c` @kind object;
  #L1c1314.  if v2 != 0 then goto L1c131c;
  #L1c1318.  v2:= 1I;
  #L1c131a.  goto L1c131e;
  #L1c131c.  v2:= 0I;
  #L1c131e.  v1.`c.b.a.b.b$d.g` @type ^`boolean` := v2 @kind boolean;
  #L1c1322.  return @kind void;
}

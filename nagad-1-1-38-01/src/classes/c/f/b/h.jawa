record `c.f.b.h` @kind class @AccessFlag PUBLIC extends `c.f.b.b` @kind class {
  `int` `c.f.b.h.g` @AccessFlag PRIVATE;
  `c.f.b.i`[] `c.f.b.h.h` @AccessFlag PRIVATE;
  `c.f.b.i`[] `c.f.b.h.i` @AccessFlag PRIVATE;
  `int` `c.f.b.h.j` @AccessFlag PRIVATE;
  `c.f.b.h$b` `c.f.b.h.k` @AccessFlag ;
}
procedure `void` `<init>`(`c.f.b.h` v1 @kind this, `c.f.b.c` v2 @kind object) @signature `Lc/f/b/h;.<init>:(Lc/f/b/c;)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;

  #L1ca9c8.  call `<init>`(v1, v2) @signature `Lc/f/b/b;.<init>:(Lc/f/b/c;)V` @kind direct;
  #L1ca9ce.  v2:= 128I;
  #L1ca9d2.  v1.`c.f.b.h.g` @type ^`int` := v2;
  #L1ca9d6.  v2:= v1.`c.f.b.h.g` @type ^`int`;
  #L1ca9da.  v0:= new `c.f.b.i`[v2];
  #L1ca9de.  v1.`c.f.b.h.h` @type ^`c.f.b.i`[] := v0 @kind object;
  #L1ca9e2.  v2:= new `c.f.b.i`[v2];
  #L1ca9e6.  v1.`c.f.b.h.i` @type ^`c.f.b.i`[] := v2 @kind object;
  #L1ca9ea.  v2:= 0I;
  #L1ca9ec.  v1.`c.f.b.h.j` @type ^`int` := v2;
  #L1ca9f0.  v2:= new `c.f.b.h$b`;
  #L1ca9f4.  call `<init>`(v2, v1, v1) @signature `Lc/f/b/h$b;.<init>:(Lc/f/b/h;Lc/f/b/h;)V` @kind direct;
  #L1ca9fa.  v1.`c.f.b.h.k` @type ^`c.f.b.h$b` := v2 @kind object;
  #L1ca9fe.  return @kind void;
}
procedure `void` `a`(`c.f.b.h` v0 @kind object, `c.f.b.i` v1 @kind object) @signature `Lc/f/b/h;.a:(Lc/f/b/h;Lc/f/b/i;)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1caa10.  call `d`(v0, v1) @signature `Lc/f/b/h;.d:(Lc/f/b/i;)V` @kind direct;
  #L1caa16.  return @kind void;
}
procedure `void` `c`(`c.f.b.h` v5 @kind this, `c.f.b.i` v6 @kind object) @signature `Lc/f/b/h;.c:(Lc/f/b/i;)V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L1caa64.  v0:= v5.`c.f.b.h.j` @type ^`int`;
  #L1caa68.  v1:= 1I;
  #L1caa6a.  v0:= v0 + v1 @kind int;
  #L1caa6c.  v2:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1caa70.  v3:= length @variable v2;
  #L1caa72.  if v0 <= v3 then goto L1caaa6;
  #L1caa76.  v0:= length @variable v2;
  #L1caa78.  v0:= v0 * 2;
  #L1caa7c.  call temp:= `copyOf`(v2, v0) @signature `Ljava/util/Arrays;.copyOf:([Ljava/lang/Object;I)[Ljava/lang/Object;` @kind static;
  #L1caa82.  v0:= temp @kind object;
  #L1caa84.  v0:= (`c.f.b.i`[]) v0 @kind object;
  #L1caa88.  v5.`c.f.b.h.h` @type ^`c.f.b.i`[] := v0 @kind object;
  #L1caa8c.  v0:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1caa90.  v2:= length @variable v0;
  #L1caa92.  v2:= v2 * 2;
  #L1caa96.  call temp:= `copyOf`(v0, v2) @signature `Ljava/util/Arrays;.copyOf:([Ljava/lang/Object;I)[Ljava/lang/Object;` @kind static;
  #L1caa9c.  v0:= temp @kind object;
  #L1caa9e.  v0:= (`c.f.b.i`[]) v0 @kind object;
  #L1caaa2.  v5.`c.f.b.h.i` @type ^`c.f.b.i`[] := v0 @kind object;
  #L1caaa6.  v0:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1caaaa.  v2:= v5.`c.f.b.h.j` @type ^`int`;
  #L1caaae.  v0[v2]:= v6 @kind object;
  #L1caab2.  v2:= v2 + v1 @kind int;
  #L1caab4.  v5.`c.f.b.h.j` @type ^`int` := v2;
  #L1caab8.  v2:= v5.`c.f.b.h.j` @type ^`int`;
  #L1caabc.  if v2 <= v1 then goto L1cab26;
  #L1caac0.  v2:= v2 - v1 @kind int;
  #L1caac2.  v0:= v0[v2] @kind object;
  #L1caac6.  v0:= v0.`c.f.b.i.c` @type ^`int`;
  #L1caaca.  v2:= v6.`c.f.b.i.c` @type ^`int`;
  #L1caace.  if v0 <= v2 then goto L1cab26;
  #L1caad2.  v0:= 0I;
  #L1caad4.  v2:= 0I;
  #L1caad6.  v3:= v5.`c.f.b.h.j` @type ^`int`;
  #L1caada.  if v2 >= v3 then goto L1caaf4;
  #L1caade.  v3:= v5.`c.f.b.h.i` @type ^`c.f.b.i`[] @kind object;
  #L1caae2.  v4:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1caae6.  v4:= v4[v2] @kind object;
  #L1caaea.  v3[v2]:= v4 @kind object;
  #L1caaee.  v2:= v2 + 1;
  #L1caaf2.  goto L1caad6;
  #L1caaf4.  v2:= v5.`c.f.b.h.i` @type ^`c.f.b.i`[] @kind object;
  #L1caaf8.  v4:= new `c.f.b.h$a`;
  #L1caafc.  call `<init>`(v4, v5) @signature `Lc/f/b/h$a;.<init>:(Lc/f/b/h;)V` @kind direct;
  #L1cab02.  call `sort`(v2, v0, v3, v4) @signature `Ljava/util/Arrays;.sort:([Ljava/lang/Object;IILjava/util/Comparator;)V` @kind static;
  #L1cab08.  v2:= v5.`c.f.b.h.j` @type ^`int`;
  #L1cab0c.  if v0 >= v2 then goto L1cab26;
  #L1cab10.  v2:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1cab14.  v3:= v5.`c.f.b.h.i` @type ^`c.f.b.i`[] @kind object;
  #L1cab18.  v3:= v3[v0] @kind object;
  #L1cab1c.  v2[v0]:= v3 @kind object;
  #L1cab20.  v0:= v0 + 1;
  #L1cab24.  goto L1cab08;
  #L1cab26.  v6.`c.f.b.i.a` @type ^`boolean` := v1 @kind boolean;
  #L1cab2a.  call `addToRow`(v6, v5) @signature `Lc/f/b/i;.addToRow:(Lc/f/b/b;)V` @kind virtual;
  #L1cab30.  return @kind void;
}
procedure `void` `d`(`c.f.b.h` v5 @kind this, `c.f.b.i` v6 @kind object) @signature `Lc/f/b/h;.d:(Lc/f/b/i;)V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L1cab64.  v0:= 0I;
  #L1cab66.  v1:= 0I;
  #L1cab68.  v2:= v5.`c.f.b.h.j` @type ^`int`;
  #L1cab6c.  if v1 >= v2 then goto L1cabb0;
  #L1cab70.  v2:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1cab74.  v2:= v2[v1] @kind object;
  #L1cab78.  if v2 != v6 then goto L1cabaa;
  #L1cab7c.  v2:= v5.`c.f.b.h.j` @type ^`int`;
  #L1cab80.  v3:= v2 + -1;
  #L1cab84.  if v1 >= v3 then goto L1cab9c;
  #L1cab88.  v2:= v5.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1cab8c.  v3:= v1 + 1;
  #L1cab90.  v4:= v2[v3] @kind object;
  #L1cab94.  v2[v1]:= v4 @kind object;
  #L1cab98.  v1:= v3;
  #L1cab9a.  goto L1cab7c;
  #L1cab9c.  v2:= v2 + -1;
  #L1caba0.  v5.`c.f.b.h.j` @type ^`int` := v2;
  #L1caba4.  v6.`c.f.b.i.a` @type ^`boolean` := v0 @kind boolean;
  #L1caba8.  return @kind void;
  #L1cabaa.  v1:= v1 + 1;
  #L1cabae.  goto L1cab68;
  #L1cabb0.  return @kind void;
}
procedure `void` `addError`(`c.f.b.h` v3 @kind this, `c.f.b.i` v4 @kind object) @signature `Lc/f/b/h;.addError:(Lc/f/b/i;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L1caa28.  v0:= v3.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1caa2c.  call `init`(v0, v4) @signature `Lc/f/b/h$b;.init:(Lc/f/b/i;)V` @kind virtual;
  #L1caa32.  v0:= v3.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1caa36.  call `reset`(v0) @signature `Lc/f/b/h$b;.reset:()V` @kind virtual;
  #L1caa3c.  v0:= v4.`c.f.b.i.i` @type ^`float`[] @kind object;
  #L1caa40.  v1:= v4.`c.f.b.i.e` @type ^`int`;
  #L1caa44.  v2:= 1.0F;
  #L1caa48.  v0[v1]:= v2;
  #L1caa4c.  call `c`(v3, v4) @signature `Lc/f/b/h;.c:(Lc/f/b/i;)V` @kind direct;
  #L1caa52.  return @kind void;
}
procedure `void` `clear`(`c.f.b.h` v1 @kind this) @signature `Lc/f/b/h;.clear:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1cab44.  v0:= 0I;
  #L1cab46.  v1.`c.f.b.h.j` @type ^`int` := v0;
  #L1cab4a.  v0:= 0I;
  #L1cab4c.  v1.`c.f.b.b.b` @type ^`float` := v0;
  #L1cab50.  return @kind void;
}
procedure `c.f.b.i` `getPivotCandidate`(`c.f.b.h` v4 @kind this, `c.f.b.d` v5 @kind object, `boolean`[] v6 @kind object) @signature `Lc/f/b/h;.getPivotCandidate:(Lc/f/b/d;[Z)Lc/f/b/i;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1ca884.  v5:= -1I;
  #L1ca886.  v0:= 0I;
  #L1ca888.  v1:= -1I;
  #L1ca88a.  v2:= v4.`c.f.b.h.j` @type ^`int`;
  #L1ca88e.  if v0 >= v2 then goto L1ca8e8;
  #L1ca892.  v2:= v4.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1ca896.  v2:= v2[v0] @kind object;
  #L1ca89a.  v3:= v2.`c.f.b.i.c` @type ^`int`;
  #L1ca89e.  v3:= v6[v3] @kind boolean;
  #L1ca8a2.  if v3 == 0 then goto L1ca8a8;
  #L1ca8a6.  goto L1ca8e2;
  #L1ca8a8.  v3:= v4.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1ca8ac.  call `init`(v3, v2) @signature `Lc/f/b/h$b;.init:(Lc/f/b/i;)V` @kind virtual;
  #L1ca8b2.  if v1 != v5 then goto L1ca8c8;
  #L1ca8b6.  v2:= v4.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1ca8ba.  call temp:= `isNegative`(v2) @signature `Lc/f/b/h$b;.isNegative:()Z` @kind virtual;
  #L1ca8c0.  v2:= temp;
  #L1ca8c2.  if v2 == 0 then goto L1ca8e2;
  #L1ca8c6.  goto L1ca8e0;
  #L1ca8c8.  v2:= v4.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1ca8cc.  v3:= v4.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1ca8d0.  v3:= v3[v1] @kind object;
  #L1ca8d4.  call temp:= `isSmallerThan`(v2, v3) @signature `Lc/f/b/h$b;.isSmallerThan:(Lc/f/b/i;)Z` @kind virtual;
  #L1ca8da.  v2:= temp;
  #L1ca8dc.  if v2 == 0 then goto L1ca8e2;
  #L1ca8e0.  v1:= v0;
  #L1ca8e2.  v0:= v0 + 1;
  #L1ca8e6.  goto L1ca88a;
  #L1ca8e8.  if v1 != v5 then goto L1ca8f0;
  #L1ca8ec.  v5:= 0I;
  #L1ca8ee.  return v5 @kind object;
  #L1ca8f0.  v5:= v4.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1ca8f4.  v5:= v5[v1] @kind object;
  #L1ca8f8.  return v5 @kind object;
}
procedure `boolean` `isEmpty`(`c.f.b.h` v1 @kind this) @signature `Lc/f/b/h;.isEmpty:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L1ca90c.  v0:= v1.`c.f.b.h.j` @type ^`int`;
  #L1ca910.  if v0 != 0 then goto L1ca918;
  #L1ca914.  v0:= 1I;
  #L1ca916.  goto L1ca91a;
  #L1ca918.  v0:= 0I;
  #L1ca91a.  return v0;
}
procedure `java.lang.String` `toString`(`c.f.b.h` v4 @kind this) @signature `Lc/f/b/h;.toString:()Ljava/lang/String;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1ca92c.  v0:= new `java.lang.StringBuilder`;
  #L1ca930.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1ca936.  v1:= "" @kind object;
  #L1ca93a.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca940.  v1:= " goal -> (" @kind object;
  #L1ca944.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca94a.  v1:= v4.`c.f.b.b.b` @type ^`float`;
  #L1ca94e.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(F)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca954.  v1:= ") : " @kind object;
  #L1ca958.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca95e.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1ca964.  v0:= temp @kind object;
  #L1ca966.  v1:= 0I;
  #L1ca968.  v2:= v4.`c.f.b.h.j` @type ^`int`;
  #L1ca96c.  if v1 >= v2 then goto L1ca9b4;
  #L1ca970.  v2:= v4.`c.f.b.h.h` @type ^`c.f.b.i`[] @kind object;
  #L1ca974.  v2:= v2[v1] @kind object;
  #L1ca978.  v3:= v4.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1ca97c.  call `init`(v3, v2) @signature `Lc/f/b/h$b;.init:(Lc/f/b/i;)V` @kind virtual;
  #L1ca982.  v2:= new `java.lang.StringBuilder`;
  #L1ca986.  call `<init>`(v2) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L1ca98c.  call temp:= `append`(v2, v0) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca992.  v0:= v4.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1ca996.  call temp:= `append`(v2, v0) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca99c.  v0:= " " @kind object;
  #L1ca9a0.  call temp:= `append`(v2, v0) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L1ca9a6.  call temp:= `toString`(v2) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L1ca9ac.  v0:= temp @kind object;
  #L1ca9ae.  v1:= v1 + 1;
  #L1ca9b2.  goto L1ca968;
  #L1ca9b4.  return v0 @kind object;
}
procedure `void` `updateFromRow`(`c.f.b.h` v5 @kind this, `c.f.b.d` v6 @kind object, `c.f.b.b` v7 @kind object, `boolean` v8 ) @signature `Lc/f/b/h;.updateFromRow:(Lc/f/b/d;Lc/f/b/b;Z)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L1cabc4.  v6:= v7.`c.f.b.b.a` @type ^`c.f.b.i` @kind object;
  #L1cabc8.  if v6 != 0 then goto L1cabce;
  #L1cabcc.  return @kind void;
  #L1cabce.  v8:= v7.`c.f.b.b.e` @type ^`c.f.b.b$a` @kind object;
  #L1cabd2.  call temp:= `getCurrentSize`(v8) @signature `Lc/f/b/b$a;.getCurrentSize:()I` @kind interface;
  #L1cabd8.  v0:= temp;
  #L1cabda.  v1:= 0I;
  #L1cabdc.  if v1 >= v0 then goto L1cac28;
  #L1cabe0.  call temp:= `getVariable`(v8, v1) @signature `Lc/f/b/b$a;.getVariable:(I)Lc/f/b/i;` @kind interface;
  #L1cabe6.  v2:= temp @kind object;
  #L1cabe8.  call temp:= `getVariableValue`(v8, v1) @signature `Lc/f/b/b$a;.getVariableValue:(I)F` @kind interface;
  #L1cabee.  v3:= temp;
  #L1cabf0.  v4:= v5.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1cabf4.  call `init`(v4, v2) @signature `Lc/f/b/h$b;.init:(Lc/f/b/i;)V` @kind virtual;
  #L1cabfa.  v4:= v5.`c.f.b.h.k` @type ^`c.f.b.h$b` @kind object;
  #L1cabfe.  call temp:= `addToGoal`(v4, v6, v3) @signature `Lc/f/b/h$b;.addToGoal:(Lc/f/b/i;F)Z` @kind virtual;
  #L1cac04.  v4:= temp;
  #L1cac06.  if v4 == 0 then goto L1cac10;
  #L1cac0a.  call `c`(v5, v2) @signature `Lc/f/b/h;.c:(Lc/f/b/i;)V` @kind direct;
  #L1cac10.  v2:= v5.`c.f.b.b.b` @type ^`float`;
  #L1cac14.  v4:= v7.`c.f.b.b.b` @type ^`float`;
  #L1cac18.  v4:= v4 * v3 @kind float;
  #L1cac1c.  v2:= v2 + v4 @kind float;
  #L1cac1e.  v5.`c.f.b.b.b` @type ^`float` := v2;
  #L1cac22.  v1:= v1 + 1;
  #L1cac26.  goto L1cabdc;
  #L1cac28.  call `d`(v5, v6) @signature `Lc/f/b/h;.d:(Lc/f/b/i;)V` @kind direct;
  #L1cac2e.  return @kind void;
}

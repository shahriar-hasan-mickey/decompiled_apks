record `e.c.a.a.c` @kind interface @AccessFlag PUBLIC_ABSTRACT_INTERFACE {
}
procedure `e.c.a.a.c` `append`(`e.c.a.a.c` v0 @kind object) @signature `Le/c/a/a/c;.append:(Le/c/a/a/c;)Le/c/a/a/c;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `e.c.a.a.c` `appendByte`(`byte` v0 ) @signature `Le/c/a/a/c;.appendByte:(B)Le/c/a/a/c;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `e.c.a.a.c` `bitWiseAnd`(`e.c.a.a.c` v0 @kind object) @signature `Le/c/a/a/c;.bitWiseAnd:(Le/c/a/a/c;)Le/c/a/a/c;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `clear`() @signature `Le/c/a/a/c;.clear:()V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `e.c.a.a.c` `clone`() @signature `Le/c/a/a/c;.clone:()Le/c/a/a/c;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `copyBytes`(`e.c.a.a.c` v0 @kind object, `int` v1 , `int` v2 , `int` v3 ) @signature `Le/c/a/a/c;.copyBytes:(Le/c/a/a/c;III)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `e.c.a.a.c` `copyOfRange`(`int` v0 , `int` v1 ) @signature `Le/c/a/a/c;.copyOfRange:(II)Le/c/a/a/c;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `e.c.a.a.c` `fill`(`byte` v0 ) @signature `Le/c/a/a/c;.fill:(B)Le/c/a/a/c;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `byte` `getByte`(`int` v0 ) @signature `Le/c/a/a/c;.getByte:(I)B` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `byte`[] `getBytes`() @signature `Le/c/a/a/c;.getBytes:()[B` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `java.lang.String` `getHexString`() @signature `Le/c/a/a/c;.getHexString:()Ljava/lang/String;` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `int` `getLength`() @signature `Le/c/a/a/c;.getLength:()I` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `boolean` `isEqual`(`e.c.a.a.c` v0 @kind object) @signature `Le/c/a/a/c;.isEqual:(Le/c/a/a/c;)Z` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `setByte`(`int` v0 , `byte` v1 ) @signature `Le/c/a/a/c;.setByte:(IB)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}

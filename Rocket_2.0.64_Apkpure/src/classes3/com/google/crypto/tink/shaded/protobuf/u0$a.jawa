record `com.google.crypto.tink.shaded.protobuf.u0$a` @kind class @AccessFlag  {
}
procedure `void` `a`(`byte` v0 , `byte` v1 , `byte` v2 , `byte` v3 , `char`[] v4 @kind object, `int` v5 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.a:(BBBB[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7bf0.  call `h`(v0, v1, v2, v3, v4, v5) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.h:(BBBB[CI)V` @kind static;
  #L1d7bf6.  return @kind void;
}
procedure `boolean` `b`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.b:(B)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7ac8.  call temp:= `n`(v0) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.n:(B)Z` @kind static;
  #L1d7ace.  v0:= temp;
  #L1d7ad0.  return v0;
}
procedure `void` `c`(`byte` v0 , `char`[] v1 @kind object, `int` v2 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.c:(B[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7c08.  call `i`(v0, v1, v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.i:(B[CI)V` @kind static;
  #L1d7c0e.  return @kind void;
}
procedure `boolean` `d`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.d:(B)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7ae4.  call temp:= `p`(v0) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.p:(B)Z` @kind static;
  #L1d7aea.  v0:= temp;
  #L1d7aec.  return v0;
}
procedure `void` `e`(`byte` v0 , `byte` v1 , `char`[] v2 @kind object, `int` v3 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.e:(BB[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7c20.  call `k`(v0, v1, v2, v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.k:(BB[CI)V` @kind static;
  #L1d7c26.  return @kind void;
}
procedure `boolean` `f`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.f:(B)Z` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7b00.  call temp:= `o`(v0) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.o:(B)Z` @kind static;
  #L1d7b06.  v0:= temp;
  #L1d7b08.  return v0;
}
procedure `void` `g`(`byte` v0 , `byte` v1 , `byte` v2 , `char`[] v3 @kind object, `int` v4 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.g:(BBB[CI)V` @AccessFlag STATIC_SYNTHETIC {
    temp;

  #L1d7c38.  call `j`(v0, v1, v2, v3, v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.j:(BBB[CI)V` @kind static;
  #L1d7c3e.  return @kind void;
}
procedure `void` `h`(`byte` v2 , `byte` v3 , `byte` v4 , `byte` v5 , `char`[] v6 @kind object, `int` v7 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.h:(BBBB[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L1d7c50.  call temp:= `m`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @kind static;
  #L1d7c56.  v0:= temp;
  #L1d7c58.  if v0 != 0 then goto L1d7cd2;
  #L1d7c5c.  v0:= v2 ^< 28;
  #L1d7c60.  v1:= v3 + 112;
  #L1d7c64.  v0:= v0 + v1 @kind int;
  #L1d7c66.  v0:= v0 ^> 30;
  #L1d7c6a.  if v0 != 0 then goto L1d7cd2;
  #L1d7c6e.  call temp:= `m`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @kind static;
  #L1d7c74.  v0:= temp;
  #L1d7c76.  if v0 != 0 then goto L1d7cd2;
  #L1d7c7a.  call temp:= `m`(v5) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @kind static;
  #L1d7c80.  v0:= temp;
  #L1d7c82.  if v0 != 0 then goto L1d7cd2;
  #L1d7c86.  v2:= v2 ^& 7;
  #L1d7c8a.  v2:= v2 ^< 18;
  #L1d7c8e.  call temp:= `r`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @kind static;
  #L1d7c94.  v3:= temp;
  #L1d7c96.  v3:= v3 ^< 12;
  #L1d7c9a.  v2:= v2 ^| v3 @kind int;
  #L1d7c9c.  call temp:= `r`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @kind static;
  #L1d7ca2.  v3:= temp;
  #L1d7ca4.  v3:= v3 ^< 6;
  #L1d7ca8.  v2:= v2 ^| v3 @kind int;
  #L1d7caa.  call temp:= `r`(v5) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @kind static;
  #L1d7cb0.  v3:= temp;
  #L1d7cb2.  v2:= v2 ^| v3 @kind int;
  #L1d7cb4.  call temp:= `l`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.l:(I)C` @kind static;
  #L1d7cba.  v3:= temp;
  #L1d7cbc.  v6[v7]:= v3 @kind char;
  #L1d7cc0.  v7:= v7 + 1;
  #L1d7cc4.  call temp:= `q`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.q:(I)C` @kind static;
  #L1d7cca.  v2:= temp;
  #L1d7ccc.  v6[v7]:= v2 @kind char;
  #L1d7cd0.  return @kind void;
  #L1d7cd2.  call temp:= `c`() @signature `Lcom/google/crypto/tink/shaded/protobuf/InvalidProtocolBufferException;.c:()Lcom/google/crypto/tink/shaded/protobuf/InvalidProtocolBufferException;` @kind static;
  #L1d7cd8.  v2:= temp @kind object;
  #L1d7cda.  throw v2;
}
procedure `void` `i`(`byte` v0 , `char`[] v1 @kind object, `int` v2 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.i:(B[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;

  #L1d7cec.  v0:= (`char`) v0 @kind i2c;
  #L1d7cee.  v1[v2]:= v0 @kind char;
  #L1d7cf2.  return @kind void;
}
procedure `void` `j`(`byte` v2 , `byte` v3 , `byte` v4 , `char`[] v5 @kind object, `int` v6 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.j:(BBB[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;

  #L1d7d04.  call temp:= `m`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @kind static;
  #L1d7d0a.  v0:= temp;
  #L1d7d0c.  if v0 != 0 then goto L1d7d60;
  #L1d7d10.  v0:= -32I;
  #L1d7d14.  v1:= -96I;
  #L1d7d18.  if v2 != v0 then goto L1d7d20;
  #L1d7d1c.  if v3 < v1 then goto L1d7d60;
  #L1d7d20.  v0:= -19I;
  #L1d7d24.  if v2 != v0 then goto L1d7d2c;
  #L1d7d28.  if v3 >= v1 then goto L1d7d60;
  #L1d7d2c.  call temp:= `m`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @kind static;
  #L1d7d32.  v0:= temp;
  #L1d7d34.  if v0 != 0 then goto L1d7d60;
  #L1d7d38.  v2:= v2 ^& 15;
  #L1d7d3c.  v2:= v2 ^< 12;
  #L1d7d40.  call temp:= `r`(v3) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @kind static;
  #L1d7d46.  v3:= temp;
  #L1d7d48.  v3:= v3 ^< 6;
  #L1d7d4c.  v2:= v2 ^| v3 @kind int;
  #L1d7d4e.  call temp:= `r`(v4) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @kind static;
  #L1d7d54.  v3:= temp;
  #L1d7d56.  v2:= v2 ^| v3 @kind int;
  #L1d7d58.  v2:= (`char`) v2 @kind i2c;
  #L1d7d5a.  v5[v6]:= v2 @kind char;
  #L1d7d5e.  return @kind void;
  #L1d7d60.  call temp:= `c`() @signature `Lcom/google/crypto/tink/shaded/protobuf/InvalidProtocolBufferException;.c:()Lcom/google/crypto/tink/shaded/protobuf/InvalidProtocolBufferException;` @kind static;
  #L1d7d66.  v2:= temp @kind object;
  #L1d7d68.  throw v2;
}
procedure `void` `k`(`byte` v1 , `byte` v2 , `char`[] v3 @kind object, `int` v4 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.k:(BB[CI)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1d7d7c.  v0:= -62I;
  #L1d7d80.  if v1 < v0 then goto L1d7daa;
  #L1d7d84.  call temp:= `m`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @kind static;
  #L1d7d8a.  v0:= temp;
  #L1d7d8c.  if v0 != 0 then goto L1d7daa;
  #L1d7d90.  v1:= v1 ^& 31;
  #L1d7d94.  v1:= v1 ^< 6;
  #L1d7d98.  call temp:= `r`(v2) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @kind static;
  #L1d7d9e.  v2:= temp;
  #L1d7da0.  v1:= v1 ^| v2 @kind int;
  #L1d7da2.  v1:= (`char`) v1 @kind i2c;
  #L1d7da4.  v3[v4]:= v1 @kind char;
  #L1d7da8.  return @kind void;
  #L1d7daa.  call temp:= `c`() @signature `Lcom/google/crypto/tink/shaded/protobuf/InvalidProtocolBufferException;.c:()Lcom/google/crypto/tink/shaded/protobuf/InvalidProtocolBufferException;` @kind static;
  #L1d7db0.  v1:= temp @kind object;
  #L1d7db2.  throw v1;
}
procedure `char` `l`(`int` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.l:(I)C` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1d7b98.  v1:= v1 ^>> 10;
  #L1d7b9c.  v0:= 55232I;
  #L1d7ba2.  v1:= v1 + v0 @kind int;
  #L1d7ba4.  v1:= (`char`) v1 @kind i2c;
  #L1d7ba6.  return v1;
}
procedure `boolean` `m`(`byte` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.m:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1d7b1c.  v0:= -65I;
  #L1d7b20.  if v1 <= v0 then goto L1d7b28;
  #L1d7b24.  v1:= 1I;
  #L1d7b26.  goto L1d7b2a;
  #L1d7b28.  v1:= 0I;
  #L1d7b2a.  return v1;
}
procedure `boolean` `n`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.n:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;

  #L1d7b3c.  if v0 < 0 then goto L1d7b44;
  #L1d7b40.  v0:= 1I;
  #L1d7b42.  goto L1d7b46;
  #L1d7b44.  v0:= 0I;
  #L1d7b46.  return v0;
}
procedure `boolean` `o`(`byte` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.o:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1d7b58.  v0:= -16I;
  #L1d7b5c.  if v1 >= v0 then goto L1d7b64;
  #L1d7b60.  v1:= 1I;
  #L1d7b62.  goto L1d7b66;
  #L1d7b64.  v1:= 0I;
  #L1d7b66.  return v1;
}
procedure `boolean` `p`(`byte` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.p:(B)Z` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1d7b78.  v0:= -32I;
  #L1d7b7c.  if v1 >= v0 then goto L1d7b84;
  #L1d7b80.  v1:= 1I;
  #L1d7b82.  goto L1d7b86;
  #L1d7b84.  v1:= 0I;
  #L1d7b86.  return v1;
}
procedure `char` `q`(`int` v1 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.q:(I)C` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1d7bb8.  v1:= v1 ^& 1023;
  #L1d7bbc.  v0:= 56320I;
  #L1d7bc2.  v1:= v1 + v0 @kind int;
  #L1d7bc4.  v1:= (`char`) v1 @kind i2c;
  #L1d7bc6.  return v1;
}
procedure `int` `r`(`byte` v0 ) @signature `Lcom/google/crypto/tink/shaded/protobuf/u0$a;.r:(B)I` @AccessFlag PRIVATE_STATIC {
    temp;

  #L1d7bd8.  v0:= v0 ^& 63;
  #L1d7bdc.  return v0;
}

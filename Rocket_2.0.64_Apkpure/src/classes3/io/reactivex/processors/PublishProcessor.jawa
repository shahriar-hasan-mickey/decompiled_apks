record `io.reactivex.processors.PublishProcessor` @kind class @AccessFlag PUBLIC_FINAL extends `io.reactivex.processors.FlowableProcessor` @kind class {
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.processors.PublishProcessor.b` @AccessFlag FINAL;
  `java.lang.Throwable` `io.reactivex.processors.PublishProcessor.c` @AccessFlag ;
}
global `io.reactivex.processors.PublishProcessor$a`[] `@@io.reactivex.processors.PublishProcessor.d` @AccessFlag STATIC_FINAL;
global `io.reactivex.processors.PublishProcessor$a`[] `@@io.reactivex.processors.PublishProcessor.e` @AccessFlag STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/processors/PublishProcessor;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L460c2c.  v0:= 0I;
  #L460c2e.  v1:= new `io.reactivex.processors.PublishProcessor$a`[v0];
  #L460c32.  `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] := v1 @kind object;
  #L460c36.  v0:= new `io.reactivex.processors.PublishProcessor$a`[v0];
  #L460c3a.  `@@io.reactivex.processors.PublishProcessor.e` @type ^`io.reactivex.processors.PublishProcessor$a`[] := v0 @kind object;
  #L460c3e.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.processors.PublishProcessor` v2 @kind this) @signature `Lio/reactivex/processors/PublishProcessor;.<init>:()V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L460c50.  call `<init>`(v2) @signature `Lio/reactivex/processors/FlowableProcessor;.<init>:()V` @kind direct;
  #L460c56.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L460c5a.  v1:= `@@io.reactivex.processors.PublishProcessor.e` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460c5e.  call `<init>`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L460c64.  v2.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L460c68.  return @kind void;
}
procedure `io.reactivex.processors.PublishProcessor` `create`() @signature `Lio/reactivex/processors/PublishProcessor;.create:()Lio/reactivex/processors/PublishProcessor;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L460be0.  v0:= new `io.reactivex.processors.PublishProcessor`;
  #L460be4.  call `<init>`(v0) @signature `Lio/reactivex/processors/PublishProcessor;.<init>:()V` @kind direct;
  #L460bea.  return v0 @kind object;
}
procedure `boolean` `e`(`io.reactivex.processors.PublishProcessor` v4 @kind this, `io.reactivex.processors.PublishProcessor$a` v5 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.e:(Lio/reactivex/processors/PublishProcessor$a;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L460a7c.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460a80.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460a86.  v0:= temp @kind object;
  #L460a88.  v0:= (`io.reactivex.processors.PublishProcessor$a`[]) v0 @kind object;
  #L460a8c.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460a90.  v2:= 0I;
  #L460a92.  if v0 != v1 then goto L460a98;
  #L460a96.  return v2;
  #L460a98.  v1:= length @variable v0;
  #L460a9a.  v3:= v1 + 1;
  #L460a9e.  v3:= new `io.reactivex.processors.PublishProcessor$a`[v3];
  #L460aa2.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L460aa8.  v3[v1]:= v5 @kind object;
  #L460aac.  v1:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460ab0.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L460ab6.  v0:= temp;
  #L460ab8.  if v0 == 0 then goto L460a7c;
  #L460abc.  v5:= 1I;
  #L460abe.  return v5;
}
procedure `void` `f`(`io.reactivex.processors.PublishProcessor` v6 @kind this, `io.reactivex.processors.PublishProcessor$a` v7 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.f:(Lio/reactivex/processors/PublishProcessor$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L460de4.  v0:= v6.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460de8.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460dee.  v0:= temp @kind object;
  #L460df0.  v0:= (`io.reactivex.processors.PublishProcessor$a`[]) v0 @kind object;
  #L460df4.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460df8.  if v0 == v1 then goto L460e64;
  #L460dfc.  v1:= `@@io.reactivex.processors.PublishProcessor.e` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460e00.  if v0 != v1 then goto L460e06;
  #L460e04.  goto L460e64;
  #L460e06.  v1:= length @variable v0;
  #L460e08.  v2:= -1I;
  #L460e0a.  v3:= 0I;
  #L460e0c.  v4:= 0I;
  #L460e0e.  if v4 >= v1 then goto L460e24;
  #L460e12.  v5:= v0[v4] @kind object;
  #L460e16.  if v5 != v7 then goto L460e1e;
  #L460e1a.  v2:= v4;
  #L460e1c.  goto L460e24;
  #L460e1e.  v4:= v4 + 1;
  #L460e22.  goto L460e0e;
  #L460e24.  if v2 >= 0 then goto L460e2a;
  #L460e28.  return @kind void;
  #L460e2a.  v4:= 1I;
  #L460e2c.  if v1 != v4 then goto L460e36;
  #L460e30.  v1:= `@@io.reactivex.processors.PublishProcessor.e` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460e34.  goto L460e54;
  #L460e36.  v5:= v1 + -1;
  #L460e3a.  v5:= new `io.reactivex.processors.PublishProcessor$a`[v5];
  #L460e3e.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L460e44.  v3:= v2 + 1;
  #L460e48.  v1:= v1 - v2 @kind int;
  #L460e4a.  v1:= v1 - v4 @kind int;
  #L460e4c.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L460e52.  v1:= v5 @kind object;
  #L460e54.  v2:= v6.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460e58.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L460e5e.  v0:= temp;
  #L460e60.  if v0 == 0 then goto L460de4;
  #L460e64.  return @kind void;
}
procedure `java.lang.Throwable` `getThrowable`(`io.reactivex.processors.PublishProcessor` v2 @kind this) @signature `Lio/reactivex/processors/PublishProcessor;.getThrowable:()Ljava/lang/Throwable;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L460bfc.  v0:= v2.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460c00.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460c06.  v0:= temp @kind object;
  #L460c08.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460c0c.  if v0 != v1 then goto L460c16;
  #L460c10.  v0:= v2.`io.reactivex.processors.PublishProcessor.c` @type ^`java.lang.Throwable` @kind object;
  #L460c14.  return v0 @kind object;
  #L460c16.  v0:= 0I;
  #L460c18.  return v0 @kind object;
}
procedure `boolean` `hasComplete`(`io.reactivex.processors.PublishProcessor` v2 @kind this) @signature `Lio/reactivex/processors/PublishProcessor;.hasComplete:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L460ad0.  v0:= v2.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460ad4.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460ada.  v0:= temp @kind object;
  #L460adc.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460ae0.  if v0 != v1 then goto L460af0;
  #L460ae4.  v0:= v2.`io.reactivex.processors.PublishProcessor.c` @type ^`java.lang.Throwable` @kind object;
  #L460ae8.  if v0 != 0 then goto L460af0;
  #L460aec.  v0:= 1I;
  #L460aee.  goto L460af2;
  #L460af0.  v0:= 0I;
  #L460af2.  return v0;
}
procedure `boolean` `hasSubscribers`(`io.reactivex.processors.PublishProcessor` v1 @kind this) @signature `Lio/reactivex/processors/PublishProcessor;.hasSubscribers:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L460b04.  v0:= v1.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460b08.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460b0e.  v0:= temp @kind object;
  #L460b10.  v0:= (`io.reactivex.processors.PublishProcessor$a`[]) v0 @kind object;
  #L460b14.  v0:= length @variable v0;
  #L460b16.  if v0 == 0 then goto L460b1e;
  #L460b1a.  v0:= 1I;
  #L460b1c.  goto L460b20;
  #L460b1e.  v0:= 0I;
  #L460b20.  return v0;
}
procedure `boolean` `hasThrowable`(`io.reactivex.processors.PublishProcessor` v2 @kind this) @signature `Lio/reactivex/processors/PublishProcessor;.hasThrowable:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L460b34.  v0:= v2.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460b38.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460b3e.  v0:= temp @kind object;
  #L460b40.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460b44.  if v0 != v1 then goto L460b54;
  #L460b48.  v0:= v2.`io.reactivex.processors.PublishProcessor.c` @type ^`java.lang.Throwable` @kind object;
  #L460b4c.  if v0 == 0 then goto L460b54;
  #L460b50.  v0:= 1I;
  #L460b52.  goto L460b56;
  #L460b54.  v0:= 0I;
  #L460b56.  return v0;
}
procedure `boolean` `offer`(`io.reactivex.processors.PublishProcessor` v6 @kind this, `java.lang.Object` v7 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.offer:(Ljava/lang/Object;)Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L460b68.  v0:= 1I;
  #L460b6a.  if v7 != 0 then goto L460b84;
  #L460b6e.  v7:= new `java.lang.NullPointerException`;
  #L460b72.  v1:= "onNext called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L460b76.  call `<init>`(v7, v1) @signature `Ljava/lang/NullPointerException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L460b7c.  call `onError`(v6, v7) @signature `Lio/reactivex/processors/PublishProcessor;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L460b82.  return v0;
  #L460b84.  v1:= v6.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460b88.  call temp:= `get`(v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460b8e.  v1:= temp @kind object;
  #L460b90.  v1:= (`io.reactivex.processors.PublishProcessor$a`[]) v1 @kind object;
  #L460b94.  v2:= length @variable v1;
  #L460b96.  v3:= 0I;
  #L460b98.  v4:= 0I;
  #L460b9a.  if v4 >= v2 then goto L460bb6;
  #L460b9e.  v5:= v1[v4] @kind object;
  #L460ba2.  call temp:= `b`(v5) @signature `Lio/reactivex/processors/PublishProcessor$a;.b:()Z` @kind virtual;
  #L460ba8.  v5:= temp;
  #L460baa.  if v5 == 0 then goto L460bb0;
  #L460bae.  return v3;
  #L460bb0.  v4:= v4 + 1;
  #L460bb4.  goto L460b9a;
  #L460bb6.  v2:= length @variable v1;
  #L460bb8.  if v3 >= v2 then goto L460bcc;
  #L460bbc.  v4:= v1[v3] @kind object;
  #L460bc0.  call `e`(v4, v7) @signature `Lio/reactivex/processors/PublishProcessor$a;.e:(Ljava/lang/Object;)V` @kind virtual;
  #L460bc6.  v3:= v3 + 1;
  #L460bca.  goto L460bb8;
  #L460bcc.  return v0;
}
procedure `void` `onComplete`(`io.reactivex.processors.PublishProcessor` v4 @kind this) @signature `Lio/reactivex/processors/PublishProcessor;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L460c7c.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460c80.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460c86.  v0:= temp @kind object;
  #L460c88.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460c8c.  if v0 != v1 then goto L460c92;
  #L460c90.  return @kind void;
  #L460c92.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460c96.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L460c9c.  v0:= temp @kind object;
  #L460c9e.  v0:= (`io.reactivex.processors.PublishProcessor$a`[]) v0 @kind object;
  #L460ca2.  v1:= length @variable v0;
  #L460ca4.  v2:= 0I;
  #L460ca6.  if v2 >= v1 then goto L460cba;
  #L460caa.  v3:= v0[v2] @kind object;
  #L460cae.  call `c`(v3) @signature `Lio/reactivex/processors/PublishProcessor$a;.c:()V` @kind virtual;
  #L460cb4.  v2:= v2 + 1;
  #L460cb8.  goto L460ca6;
  #L460cba.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.processors.PublishProcessor` v4 @kind this, `java.lang.Throwable` v5 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L460ccc.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460cd0.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460cd6.  v0:= temp @kind object;
  #L460cd8.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460cdc.  if v0 != v1 then goto L460ce8;
  #L460ce0.  call `onError`(v5) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L460ce6.  return @kind void;
  #L460ce8.  if v5 != 0 then goto L460cfa;
  #L460cec.  v5:= new `java.lang.NullPointerException`;
  #L460cf0.  v0:= "onError called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L460cf4.  call `<init>`(v5, v0) @signature `Ljava/lang/NullPointerException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L460cfa.  v4.`io.reactivex.processors.PublishProcessor.c` @type ^`java.lang.Throwable` := v5 @kind object;
  #L460cfe.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460d02.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L460d08.  v0:= temp @kind object;
  #L460d0a.  v0:= (`io.reactivex.processors.PublishProcessor$a`[]) v0 @kind object;
  #L460d0e.  v1:= length @variable v0;
  #L460d10.  v2:= 0I;
  #L460d12.  if v2 >= v1 then goto L460d26;
  #L460d16.  v3:= v0[v2] @kind object;
  #L460d1a.  call `d`(v3, v5) @signature `Lio/reactivex/processors/PublishProcessor$a;.d:(Ljava/lang/Throwable;)V` @kind virtual;
  #L460d20.  v2:= v2 + 1;
  #L460d24.  goto L460d12;
  #L460d26.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.processors.PublishProcessor` v4 @kind this, `java.lang.Object` v5 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L460d38.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460d3c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460d42.  v0:= temp @kind object;
  #L460d44.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460d48.  if v0 != v1 then goto L460d4e;
  #L460d4c.  return @kind void;
  #L460d4e.  if v5 != 0 then goto L460d68;
  #L460d52.  v5:= new `java.lang.NullPointerException`;
  #L460d56.  v0:= "onNext called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L460d5a.  call `<init>`(v5, v0) @signature `Ljava/lang/NullPointerException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L460d60.  call `onError`(v4, v5) @signature `Lio/reactivex/processors/PublishProcessor;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L460d66.  return @kind void;
  #L460d68.  v0:= v4.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460d6c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460d72.  v0:= temp @kind object;
  #L460d74.  v0:= (`io.reactivex.processors.PublishProcessor$a`[]) v0 @kind object;
  #L460d78.  v1:= length @variable v0;
  #L460d7a.  v2:= 0I;
  #L460d7c.  if v2 >= v1 then goto L460d90;
  #L460d80.  v3:= v0[v2] @kind object;
  #L460d84.  call `e`(v3, v5) @signature `Lio/reactivex/processors/PublishProcessor$a;.e:(Ljava/lang/Object;)V` @kind virtual;
  #L460d8a.  v2:= v2 + 1;
  #L460d8e.  goto L460d7c;
  #L460d90.  return @kind void;
}
procedure `void` `onSubscribe`(`io.reactivex.processors.PublishProcessor` v2 @kind this, `org.reactivestreams.Subscription` v3 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L460da4.  v0:= v2.`io.reactivex.processors.PublishProcessor.b` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L460da8.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L460dae.  v0:= temp @kind object;
  #L460db0.  v1:= `@@io.reactivex.processors.PublishProcessor.d` @type ^`io.reactivex.processors.PublishProcessor$a`[] @kind object;
  #L460db4.  if v0 != v1 then goto L460dc0;
  #L460db8.  call `cancel`(v3) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L460dbe.  return @kind void;
  #L460dc0.  v0:= 9223372036854775807L;
  #L460dca.  call `request`(v3, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L460dd0.  return @kind void;
}
procedure `void` `subscribeActual`(`io.reactivex.processors.PublishProcessor` v2 @kind this, `org.reactivestreams.Subscriber` v3 @kind object) @signature `Lio/reactivex/processors/PublishProcessor;.subscribeActual:(Lorg/reactivestreams/Subscriber;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L460e78.  v0:= new `io.reactivex.processors.PublishProcessor$a`;
  #L460e7c.  call `<init>`(v0, v3, v2) @signature `Lio/reactivex/processors/PublishProcessor$a;.<init>:(Lorg/reactivestreams/Subscriber;Lio/reactivex/processors/PublishProcessor;)V` @kind direct;
  #L460e82.  call `onSubscribe`(v3, v0) @signature `Lorg/reactivestreams/Subscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @kind interface;
  #L460e88.  call temp:= `e`(v2, v0) @signature `Lio/reactivex/processors/PublishProcessor;.e:(Lio/reactivex/processors/PublishProcessor$a;)Z` @kind virtual;
  #L460e8e.  v1:= temp;
  #L460e90.  if v1 == 0 then goto L460ea8;
  #L460e94.  call temp:= `a`(v0) @signature `Lio/reactivex/processors/PublishProcessor$a;.a:()Z` @kind virtual;
  #L460e9a.  v3:= temp;
  #L460e9c.  if v3 == 0 then goto L460ebe;
  #L460ea0.  call `f`(v2, v0) @signature `Lio/reactivex/processors/PublishProcessor;.f:(Lio/reactivex/processors/PublishProcessor$a;)V` @kind virtual;
  #L460ea6.  goto L460ebe;
  #L460ea8.  v0:= v2.`io.reactivex.processors.PublishProcessor.c` @type ^`java.lang.Throwable` @kind object;
  #L460eac.  if v0 == 0 then goto L460eb8;
  #L460eb0.  call `onError`(v3, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L460eb6.  goto L460ebe;
  #L460eb8.  call `onComplete`(v3) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L460ebe.  return @kind void;
}

record `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.FlowableSubscriber` @kind interface, `org.reactivestreams.Subscription` @kind interface {
  `org.reactivestreams.Subscriber` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.b` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @AccessFlag FINAL;
  `io.reactivex.disposables.CompositeDisposable` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicInteger` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @AccessFlag FINAL;
  `io.reactivex.functions.Function` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.h` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @AccessFlag FINAL;
  `org.reactivestreams.Subscription` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @AccessFlag ;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.k` @AccessFlag VOLATILE;
}
global `long` `@@io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v0 @kind this, `org.reactivestreams.Subscriber` v1 @kind object, `io.reactivex.functions.Function` v2 @kind object, `boolean` v3 , `int` v4 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.<init>:(Lorg/reactivestreams/Subscriber;Lio/reactivex/functions/Function;ZI)V` @AccessFlag CONSTRUCTOR {
    temp;

  #L414704.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L41470a.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` := v1 @kind object;
  #L41470e.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.h` @type ^`io.reactivex.functions.Function` := v2 @kind object;
  #L414712.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.b` @type ^`boolean` := v3 @kind boolean;
  #L414716.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int` := v4;
  #L41471a.  v1:= new `java.util.concurrent.atomic.AtomicLong`;
  #L41471e.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L414724.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @type ^`java.util.concurrent.atomic.AtomicLong` := v1 @kind object;
  #L414728.  v1:= new `io.reactivex.disposables.CompositeDisposable`;
  #L41472c.  call `<init>`(v1) @signature `Lio/reactivex/disposables/CompositeDisposable;.<init>:()V` @kind direct;
  #L414732.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` := v1 @kind object;
  #L414736.  v1:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L41473a.  call `<init>`(v1) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L414740.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` := v1 @kind object;
  #L414744.  v1:= new `java.util.concurrent.atomic.AtomicInteger`;
  #L414748.  v2:= 1I;
  #L41474a.  call `<init>`(v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:(I)V` @kind direct;
  #L414750.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` := v1 @kind object;
  #L414754.  v1:= new `java.util.concurrent.atomic.AtomicReference`;
  #L414758.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L41475e.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` := v1 @kind object;
  #L414762.  return @kind void;
}
procedure `void` `a`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.a:()V` @AccessFlag  {
    temp;
    v0;

  #L4147a0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4147a4.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4147aa.  v0:= temp @kind object;
  #L4147ac.  v0:= (`io.reactivex.internal.queue.SpscLinkedArrayQueue`) v0 @kind object;
  #L4147b0.  if v0 == 0 then goto L4147ba;
  #L4147b4.  call `clear`(v0) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.clear:()V` @kind virtual;
  #L4147ba.  return @kind void;
}
procedure `void` `b`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.b:()V` @AccessFlag  {
    temp;
    v0;

  #L4147cc.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L4147d2.  v0:= temp;
  #L4147d4.  if v0 != 0 then goto L4147de;
  #L4147d8.  call `c`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.c:()V` @kind virtual;
  #L4147de.  return @kind void;
}
procedure `void` `c`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v17 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.c:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;

  #L4147f0.  v0:= v17 @kind object;
  #L4147f4.  v1:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L4147f8.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L4147fc.  v3:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L414800.  v4:= 1I;
  #L414802.  v5:= 1I;
  #L414804.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L414808.  call temp:= `get`(v6) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L41480e.  v6:= temp @kind wide;
  #L414810.  v8:= 0L;
  #L414814.  v10:= v8 @kind wide;
  #L414816.  v12:= 0I;
  #L414818.  v13:= lcmp(v10, v6);
  #L41481c.  if v13 == 0 then goto L4148de;
  #L414820.  v14:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.k` @type ^`boolean` @kind boolean;
  #L414824.  if v14 == 0 then goto L414830;
  #L414828.  call `a`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.a:()V` @kind virtual;
  #L41482e.  return @kind void;
  #L414830.  v14:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.b` @type ^`boolean` @kind boolean;
  #L414834.  if v14 != 0 then goto L414866;
  #L414838.  v14:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L41483c.  call temp:= `get`(v14) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L414842.  v14:= temp @kind object;
  #L414844.  v14:= (`java.lang.Throwable`) v14 @kind object;
  #L414848.  if v14 == 0 then goto L414866;
  #L41484c.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414850.  call temp:= `terminate`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L414856.  v2:= temp @kind object;
  #L414858.  call `a`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.a:()V` @kind virtual;
  #L41485e.  call `onError`(v1, v2) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L414864.  return @kind void;
  #L414866.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L41486c.  v14:= temp;
  #L41486e.  if v14 != 0 then goto L414876;
  #L414872.  v14:= 1I;
  #L414874.  goto L414878;
  #L414876.  v14:= 0I;
  #L414878.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L41487e.  v15:= temp @kind object;
  #L414880.  v15:= (`io.reactivex.internal.queue.SpscLinkedArrayQueue`) v15 @kind object;
  #L414884.  if v15 == 0 then goto L414892;
  #L414888.  call temp:= `poll`(v15) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.poll:()Ljava/lang/Object;` @kind virtual;
  #L41488e.  v15:= temp @kind object;
  #L414890.  goto L414894;
  #L414892.  v15:= 0I;
  #L414894.  if v15 != 0 then goto L41489e;
  #L414898.  v16:= 1I;
  #L41489c.  goto L4148a2;
  #L41489e.  v16:= 0I;
  #L4148a2.  if v14 == 0 then goto L4148ca;
  #L4148a6.  if v16 == 0 then goto L4148ca;
  #L4148aa.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L4148ae.  call temp:= `terminate`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L4148b4.  v2:= temp @kind object;
  #L4148b6.  if v2 == 0 then goto L4148c2;
  #L4148ba.  call `onError`(v1, v2) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L4148c0.  goto L4148c8;
  #L4148c2.  call `onComplete`(v1) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L4148c8.  return @kind void;
  #L4148ca.  if v16 == 0 then goto L4148d0;
  #L4148ce.  goto L4148de;
  #L4148d0.  call `onNext`(v1, v15) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L4148d6.  v12:= 1L;
  #L4148da.  v10:= v10 + v12 @kind long;
  #L4148dc.  goto L414816;
  #L4148de.  if v13 != 0 then goto L414980;
  #L4148e2.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.k` @type ^`boolean` @kind boolean;
  #L4148e6.  if v6 == 0 then goto L4148f2;
  #L4148ea.  call `a`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.a:()V` @kind virtual;
  #L4148f0.  return @kind void;
  #L4148f2.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.b` @type ^`boolean` @kind boolean;
  #L4148f6.  if v6 != 0 then goto L414928;
  #L4148fa.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L4148fe.  call temp:= `get`(v6) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L414904.  v6:= temp @kind object;
  #L414906.  v6:= (`java.lang.Throwable`) v6 @kind object;
  #L41490a.  if v6 == 0 then goto L414928;
  #L41490e.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414912.  call temp:= `terminate`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L414918.  v2:= temp @kind object;
  #L41491a.  call `a`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.a:()V` @kind virtual;
  #L414920.  call `onError`(v1, v2) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L414926.  return @kind void;
  #L414928.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L41492e.  v6:= temp;
  #L414930.  if v6 != 0 then goto L414938;
  #L414934.  v6:= 1I;
  #L414936.  goto L41493a;
  #L414938.  v6:= 0I;
  #L41493a.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L414940.  v7:= temp @kind object;
  #L414942.  v7:= (`io.reactivex.internal.queue.SpscLinkedArrayQueue`) v7 @kind object;
  #L414946.  if v7 == 0 then goto L414956;
  #L41494a.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.isEmpty:()Z` @kind virtual;
  #L414950.  v7:= temp;
  #L414952.  if v7 == 0 then goto L414958;
  #L414956.  v12:= 1I;
  #L414958.  if v6 == 0 then goto L414980;
  #L41495c.  if v12 == 0 then goto L414980;
  #L414960.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414964.  call temp:= `terminate`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L41496a.  v2:= temp @kind object;
  #L41496c.  if v2 == 0 then goto L414978;
  #L414970.  call `onError`(v1, v2) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L414976.  goto L41497e;
  #L414978.  call `onComplete`(v1) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L41497e.  return @kind void;
  #L414980.  v6:= lcmp(v10, v8);
  #L414984.  if v6 == 0 then goto L4149aa;
  #L414988.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L41498c.  call temp:= `produced`(v6, v10) @signature `Lio/reactivex/internal/util/BackpressureHelper;.produced:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L414992.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int`;
  #L414996.  v7:= 2147483647I;
  #L41499c.  if v6 == v7 then goto L4149aa;
  #L4149a0.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L4149a4.  call `request`(v6, v10) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L4149aa.  v5:= -v5 @kind int;
  #L4149ac.  call temp:= `addAndGet`(v0, v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L4149b2.  v5:= temp;
  #L4149b4.  if v5 != 0 then goto L414804;
  #L4149b8.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L414774.  v0:= 1I;
  #L414776.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.k` @type ^`boolean` := v0 @kind boolean;
  #L41477a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L41477e.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L414784.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L414788.  call `dispose`(v0) @signature `Lio/reactivex/disposables/CompositeDisposable;.dispose:()V` @kind virtual;
  #L41478e.  return @kind void;
}
procedure `io.reactivex.internal.queue.SpscLinkedArrayQueue` `d`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v3 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.d:()Lio/reactivex/internal/queue/SpscLinkedArrayQueue;` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L4146b8.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4146bc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4146c2.  v0:= temp @kind object;
  #L4146c4.  v0:= (`io.reactivex.internal.queue.SpscLinkedArrayQueue`) v0 @kind object;
  #L4146c8.  if v0 == 0 then goto L4146ce;
  #L4146cc.  return v0 @kind object;
  #L4146ce.  v0:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L4146d2.  call temp:= `bufferSize`() @signature `Lio/reactivex/Flowable;.bufferSize:()I` @kind static;
  #L4146d8.  v1:= temp;
  #L4146da.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L4146e0.  v1:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4146e4.  v2:= 0I;
  #L4146e6.  call temp:= `compareAndSet`(v1, v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L4146ec.  v1:= temp;
  #L4146ee.  if v1 == 0 then goto L4146b8;
  #L4146f2.  return v0 @kind object;
}
procedure `void` `e`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v5 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a$a` v6 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.e:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a$a;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L4149cc.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L4149d0.  call temp:= `delete`(v0, v6) @signature `Lio/reactivex/disposables/CompositeDisposable;.delete:(Lio/reactivex/disposables/Disposable;)Z` @kind virtual;
  #L4149d6.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L4149dc.  v6:= temp;
  #L4149de.  v0:= 1L;
  #L4149e2.  v2:= 2147483647I;
  #L4149e8.  if v6 != 0 then goto L414a82;
  #L4149ec.  v6:= 0I;
  #L4149ee.  v3:= 1I;
  #L4149f0.  call temp:= `compareAndSet`(v5, v6, v3) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L4149f6.  v4:= temp;
  #L4149f8.  if v4 == 0 then goto L414a82;
  #L4149fc.  v4:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414a00.  call temp:= `decrementAndGet`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414a06.  v4:= temp;
  #L414a08.  if v4 != 0 then goto L414a0e;
  #L414a0c.  v6:= 1I;
  #L414a0e.  v3:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L414a12.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L414a18.  v3:= temp @kind object;
  #L414a1a.  v3:= (`io.reactivex.internal.queue.SpscLinkedArrayQueue`) v3 @kind object;
  #L414a1e.  if v6 == 0 then goto L414a5a;
  #L414a22.  if v3 == 0 then goto L414a32;
  #L414a26.  call temp:= `isEmpty`(v3) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.isEmpty:()Z` @kind virtual;
  #L414a2c.  v6:= temp;
  #L414a2e.  if v6 == 0 then goto L414a5a;
  #L414a32.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414a36.  call temp:= `terminate`(v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L414a3c.  v6:= temp @kind object;
  #L414a3e.  if v6 == 0 then goto L414a4e;
  #L414a42.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L414a46.  call `onError`(v0, v6) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L414a4c.  goto L414a58;
  #L414a4e.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L414a52.  call `onComplete`(v6) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L414a58.  return @kind void;
  #L414a5a.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int`;
  #L414a5e.  if v6 == v2 then goto L414a6c;
  #L414a62.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414a66.  call `request`(v6, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L414a6c.  call temp:= `decrementAndGet`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414a72.  v6:= temp;
  #L414a74.  if v6 != 0 then goto L414a7a;
  #L414a78.  return @kind void;
  #L414a7a.  call `c`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.c:()V` @kind virtual;
  #L414a80.  goto L414aa4;
  #L414a82.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414a86.  call temp:= `decrementAndGet`(v6) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414a8c.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int`;
  #L414a90.  if v6 == v2 then goto L414a9e;
  #L414a94.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414a98.  call `request`(v6, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L414a9e.  call `b`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.b:()V` @kind virtual;
  #L414aa4.  return @kind void;
}
procedure `void` `f`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a$a` v3 @kind object, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.f:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a$a;Ljava/lang/Throwable;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L414ab8.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L414abc.  call temp:= `delete`(v0, v3) @signature `Lio/reactivex/disposables/CompositeDisposable;.delete:(Lio/reactivex/disposables/Disposable;)Z` @kind virtual;
  #L414ac2.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414ac6.  call temp:= `addThrowable`(v3, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L414acc.  v3:= temp;
  #L414ace.  if v3 == 0 then goto L414b1e;
  #L414ad2.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.b` @type ^`boolean` @kind boolean;
  #L414ad6.  if v3 != 0 then goto L414af0;
  #L414ada.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414ade.  call `cancel`(v3) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L414ae4.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L414ae8.  call `dispose`(v3) @signature `Lio/reactivex/disposables/CompositeDisposable;.dispose:()V` @kind virtual;
  #L414aee.  goto L414b0c;
  #L414af0.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int`;
  #L414af4.  v4:= 2147483647I;
  #L414afa.  if v3 == v4 then goto L414b0c;
  #L414afe.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414b02.  v0:= 1L;
  #L414b06.  call `request`(v3, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L414b0c.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414b10.  call temp:= `decrementAndGet`(v3) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414b16.  call `b`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.b:()V` @kind virtual;
  #L414b1c.  goto L414b24;
  #L414b1e.  call `onError`(v4) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L414b24.  return @kind void;
}
procedure `void` `g`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v5 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a$a` v6 @kind object, `java.lang.Object` v7 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.g:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a$a;Ljava/lang/Object;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L414b38.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L414b3c.  call temp:= `delete`(v0, v6) @signature `Lio/reactivex/disposables/CompositeDisposable;.delete:(Lio/reactivex/disposables/Disposable;)Z` @kind virtual;
  #L414b42.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L414b48.  v6:= temp;
  #L414b4a.  if v6 != 0 then goto L414c2c;
  #L414b4e.  v6:= 0I;
  #L414b50.  v0:= 1I;
  #L414b52.  call temp:= `compareAndSet`(v5, v6, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L414b58.  v1:= temp;
  #L414b5a.  if v1 == 0 then goto L414c2c;
  #L414b5e.  v1:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414b62.  call temp:= `decrementAndGet`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414b68.  v1:= temp;
  #L414b6a.  if v1 != 0 then goto L414b70;
  #L414b6e.  v6:= 1I;
  #L414b70.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L414b74.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L414b7a.  v0:= temp @kind wide;
  #L414b7c.  v2:= 0L;
  #L414b80.  v4:= lcmp(v0, v2);
  #L414b84.  if v4 == 0 then goto L414c06;
  #L414b88.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L414b8c.  call `onNext`(v0, v7) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L414b92.  v7:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.i` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L414b96.  call temp:= `get`(v7) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L414b9c.  v7:= temp @kind object;
  #L414b9e.  v7:= (`io.reactivex.internal.queue.SpscLinkedArrayQueue`) v7 @kind object;
  #L414ba2.  if v6 == 0 then goto L414bde;
  #L414ba6.  if v7 == 0 then goto L414bb6;
  #L414baa.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.isEmpty:()Z` @kind virtual;
  #L414bb0.  v6:= temp;
  #L414bb2.  if v6 == 0 then goto L414bde;
  #L414bb6.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414bba.  call temp:= `terminate`(v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L414bc0.  v6:= temp @kind object;
  #L414bc2.  if v6 == 0 then goto L414bd2;
  #L414bc6.  v7:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L414bca.  call `onError`(v7, v6) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L414bd0.  goto L414bdc;
  #L414bd2.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L414bd6.  call `onComplete`(v6) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L414bdc.  return @kind void;
  #L414bde.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L414be2.  v0:= 1L;
  #L414be6.  call temp:= `produced`(v6, v0) @signature `Lio/reactivex/internal/util/BackpressureHelper;.produced:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L414bec.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int`;
  #L414bf0.  v7:= 2147483647I;
  #L414bf6.  if v6 == v7 then goto L414c18;
  #L414bfa.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414bfe.  call `request`(v6, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L414c04.  goto L414c18;
  #L414c06.  call temp:= `d`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.d:()Lio/reactivex/internal/queue/SpscLinkedArrayQueue;` @kind virtual;
  #L414c0c.  v6:= temp @kind object;
  #L414c0e.  @monitorenter v6
  #L414c10.  call temp:= `offer`(v6, v7) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L414c16.  @monitorexit v6
  #L414c18.  call temp:= `decrementAndGet`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414c1e.  v6:= temp;
  #L414c20.  if v6 != 0 then goto L414c56;
  #L414c24.  return @kind void;
  #L414c26.  v7:= Exception @type ^`java.lang.Throwable` @kind object;
  #L414c28.  @monitorexit v6
  #L414c2a.  throw v7;
  #L414c2c.  call temp:= `d`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.d:()Lio/reactivex/internal/queue/SpscLinkedArrayQueue;` @kind virtual;
  #L414c32.  v6:= temp @kind object;
  #L414c34.  @monitorenter v6
  #L414c36.  call temp:= `offer`(v6, v7) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L414c3c.  @monitorexit v6
  #L414c3e.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414c42.  call temp:= `decrementAndGet`(v6) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414c48.  call temp:= `getAndIncrement`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L414c4e.  v6:= temp;
  #L414c50.  if v6 == 0 then goto L414c56;
  #L414c54.  return @kind void;
  #L414c56.  call `c`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.c:()V` @kind virtual;
  #L414c5c.  return @kind void;
  #L414c5e.  v7:= Exception @type ^`java.lang.Throwable` @kind object;
  #L414c60.  @monitorexit v6
  #L414c62.  throw v7;
  catch `java.lang.Throwable` @[L414c10..L414c18] goto L414c26;
  catch `java.lang.Throwable` @[L414c28..L414c2a] goto L414c26;
  catch `java.lang.Throwable` @[L414c36..L414c3e] goto L414c5e;
  catch `java.lang.Throwable` @[L414c60..L414c62] goto L414c5e;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L414c9c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414ca0.  call temp:= `decrementAndGet`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414ca6.  call `b`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.b:()V` @kind virtual;
  #L414cac.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L414cc0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414cc4.  call temp:= `decrementAndGet`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L414cca.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.g` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L414cce.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L414cd4.  v0:= temp;
  #L414cd6.  if v0 == 0 then goto L414cf4;
  #L414cda.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.b` @type ^`boolean` @kind boolean;
  #L414cde.  if v2 != 0 then goto L414cec;
  #L414ce2.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L414ce6.  call `dispose`(v2) @signature `Lio/reactivex/disposables/CompositeDisposable;.dispose:()V` @kind virtual;
  #L414cec.  call `b`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.b:()V` @kind virtual;
  #L414cf2.  goto L414cfa;
  #L414cf4.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L414cfa.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v2 @kind this, `java.lang.Object` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L414d0c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.h` @type ^`io.reactivex.functions.Function` @kind object;
  #L414d10.  call temp:= `apply`(v0, v3) @signature `Lio/reactivex/functions/Function;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L414d16.  v3:= temp @kind object;
  #L414d18.  v0:= "The mapper returned a null MaybeSource" @kind object;
  #L414d1c.  call temp:= `requireNonNull`(v3, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L414d22.  v3:= temp @kind object;
  #L414d24.  v3:= (`io.reactivex.MaybeSource`) v3 @kind object;
  #L414d28.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.f` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L414d2c.  call temp:= `getAndIncrement`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L414d32.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a$a`;
  #L414d36.  call `<init>`(v0, v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a$a;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;)V` @kind direct;
  #L414d3c.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.e` @type ^`io.reactivex.disposables.CompositeDisposable` @kind object;
  #L414d40.  call temp:= `add`(v1, v0) @signature `Lio/reactivex/disposables/CompositeDisposable;.add:(Lio/reactivex/disposables/Disposable;)Z` @kind virtual;
  #L414d46.  v1:= temp;
  #L414d48.  if v1 == 0 then goto L414d52;
  #L414d4c.  call `subscribe`(v3, v0) @signature `Lio/reactivex/MaybeSource;.subscribe:(Lio/reactivex/MaybeObserver;)V` @kind interface;
  #L414d52.  return @kind void;
  #L414d54.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L414d56.  call `throwIfFatal`(v3) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L414d5c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414d60.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L414d66.  call `onError`(v2, v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L414d6c.  return @kind void;
  catch `java.lang.Throwable` @[L414d0c..L414d28] goto L414d54;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v2 @kind this, `org.reactivestreams.Subscription` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L414d8c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` @kind object;
  #L414d90.  call temp:= `validate`(v0, v3) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(Lorg/reactivestreams/Subscription;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L414d96.  v0:= temp;
  #L414d98.  if v0 == 0 then goto L414dd2;
  #L414d9c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.j` @type ^`org.reactivestreams.Subscription` := v3 @kind object;
  #L414da0.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.a` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L414da4.  call `onSubscribe`(v0, v2) @signature `Lorg/reactivestreams/Subscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @kind interface;
  #L414daa.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.c` @type ^`int`;
  #L414dae.  v1:= 2147483647I;
  #L414db4.  if v0 != v1 then goto L414dca;
  #L414db8.  v0:= 9223372036854775807L;
  #L414dc2.  call `request`(v3, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L414dc8.  goto L414dd2;
  #L414dca.  v0:= (`long`) v0 @kind i2l;
  #L414dcc.  call `request`(v3, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L414dd2.  return @kind void;
}
procedure `void` `request`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a` v1 @kind this, `long` v2 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.request:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L414de4.  call temp:= `validate`(v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(J)Z` @kind static;
  #L414dea.  v0:= temp;
  #L414dec.  if v0 == 0 then goto L414e00;
  #L414df0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$a.d` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L414df4.  call temp:= `add`(v0, v2) @signature `Lio/reactivex/internal/util/BackpressureHelper;.add:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L414dfa.  call `b`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$a;.b:()V` @kind virtual;
  #L414e00.  return @kind void;
}

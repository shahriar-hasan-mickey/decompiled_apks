record `okio.Buffer$UnsafeCursor` @kind class @AccessFlag PUBLIC_FINAL extends `java.io.Closeable` @kind interface {
  `okio.Segment` `okio.Buffer$UnsafeCursor.a` @AccessFlag PRIVATE;
  `okio.Buffer` `okio.Buffer$UnsafeCursor.buffer` @AccessFlag PUBLIC;
  `byte`[] `okio.Buffer$UnsafeCursor.data` @AccessFlag PUBLIC;
  `int` `okio.Buffer$UnsafeCursor.end` @AccessFlag PUBLIC;
  `long` `okio.Buffer$UnsafeCursor.offset` @AccessFlag PUBLIC;
  `boolean` `okio.Buffer$UnsafeCursor.readWrite` @AccessFlag PUBLIC;
  `int` `okio.Buffer$UnsafeCursor.start` @AccessFlag PUBLIC;
}
procedure `void` `<init>`(`okio.Buffer$UnsafeCursor` v2 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L160c88.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L160c8e.  v0:= -1L;
  #L160c92.  v2.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L160c96.  v0:= -1I;
  #L160c98.  v2.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L160c9c.  v2.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L160ca0.  return @kind void;
}
procedure `void` `close`(`okio.Buffer$UnsafeCursor` v3 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.close:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L160cb4.  v0:= v3.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L160cb8.  if v0 == 0 then goto L160cc0;
  #L160cbc.  v0:= 1I;
  #L160cbe.  goto L160cc2;
  #L160cc0.  v0:= 0I;
  #L160cc2.  if v0 == 0 then goto L160ce8;
  #L160cc6.  v0:= 0I;
  #L160cc8.  v3.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` := v0 @kind object;
  #L160ccc.  v3.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` := v0 @kind object;
  #L160cd0.  v1:= -1L;
  #L160cd4.  v3.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v1 @kind wide;
  #L160cd8.  v3.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L160cdc.  v0:= -1I;
  #L160cde.  v3.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L160ce2.  v3.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L160ce6.  return @kind void;
  #L160ce8.  v0:= new `java.lang.IllegalStateException`;
  #L160cec.  v1:= "not attached to a buffer" @kind object;
  #L160cf0.  call temp:= `toString`(v1) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160cf6.  v1:= temp @kind object;
  #L160cf8.  call `<init>`(v0, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160cfe.  throw v0;
}
procedure `long` `expandBuffer`(`okio.Buffer$UnsafeCursor` v9 @kind this, `int` v10 ) @signature `Lokio/Buffer$UnsafeCursor;.expandBuffer:(I)J` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L1609d4.  v0:= 1I;
  #L1609d6.  v1:= 0I;
  #L1609d8.  if v10 <= 0 then goto L1609e0;
  #L1609dc.  v2:= 1I;
  #L1609de.  goto L1609e2;
  #L1609e0.  v2:= 0I;
  #L1609e2.  if v2 == 0 then goto L160ab2;
  #L1609e6.  v2:= 8192I;
  #L1609ea.  if v10 > v2 then goto L1609f0;
  #L1609ee.  goto L1609f2;
  #L1609f0.  v0:= 0I;
  #L1609f2.  if v0 == 0 then goto L160a7c;
  #L1609f6.  v0:= v9.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1609fa.  if v0 == 0 then goto L160a64;
  #L1609fe.  v1:= v9.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L160a02.  if v1 == 0 then goto L160a4c;
  #L160a06.  call temp:= `size`(v0) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L160a0c.  v3:= temp @kind wide;
  #L160a0e.  call temp:= `writableSegment$okio`(v0, v10) @signature `Lokio/Buffer;.writableSegment$okio:(I)Lokio/Segment;` @kind virtual;
  #L160a14.  v10:= temp @kind object;
  #L160a16.  v1:= v10.`okio.Segment.limit` @type ^`int`;
  #L160a1a.  v1:= v1 - 8192;
  #L160a1e.  v10.`okio.Segment.limit` @type ^`int` := v2;
  #L160a22.  v5:= (`long`) v1 @kind i2l;
  #L160a24.  v7:= v3 + v5 @kind long;
  #L160a28.  call `setSize$okio`(v0, v7) @signature `Lokio/Buffer;.setSize$okio:(J)V` @kind virtual;
  #L160a2e.  v9.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` := v10 @kind object;
  #L160a32.  v9.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v3 @kind wide;
  #L160a36.  v10:= v10.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L160a3a.  v9.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v10 @kind object;
  #L160a3e.  v10:= v1 - 8192;
  #L160a42.  v9.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v10;
  #L160a46.  v9.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v2;
  #L160a4a.  return v5 @kind wide;
  #L160a4c.  v10:= new `java.lang.IllegalStateException`;
  #L160a50.  v0:= "expandBuffer() only permitted for read/write buffers" @kind object;
  #L160a54.  call temp:= `toString`(v0) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160a5a.  v0:= temp @kind object;
  #L160a5c.  call `<init>`(v10, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160a62.  throw v10;
  #L160a64.  v10:= new `java.lang.IllegalStateException`;
  #L160a68.  v0:= "not attached to a buffer" @kind object;
  #L160a6c.  call temp:= `toString`(v0) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160a72.  v0:= temp @kind object;
  #L160a74.  call `<init>`(v10, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160a7a.  throw v10;
  #L160a7c.  v0:= new `java.lang.StringBuilder`;
  #L160a80.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L160a86.  v1:= "minByteCount > Segment.SIZE: " @kind object;
  #L160a8a.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L160a90.  call temp:= `append`(v0, v10) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L160a96.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L160a9c.  v10:= temp @kind object;
  #L160a9e.  v0:= new `java.lang.IllegalArgumentException`;
  #L160aa2.  call temp:= `toString`(v10) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160aa8.  v10:= temp @kind object;
  #L160aaa.  call `<init>`(v0, v10) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160ab0.  throw v0;
  #L160ab2.  v0:= new `java.lang.StringBuilder`;
  #L160ab6.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L160abc.  v1:= "minByteCount <= 0: " @kind object;
  #L160ac0.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L160ac6.  call temp:= `append`(v0, v10) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L160acc.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L160ad2.  v10:= temp @kind object;
  #L160ad4.  v0:= new `java.lang.IllegalArgumentException`;
  #L160ad8.  call temp:= `toString`(v10) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160ade.  v10:= temp @kind object;
  #L160ae0.  call `<init>`(v0, v10) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160ae6.  throw v0;
}
procedure `int` `next`(`okio.Buffer$UnsafeCursor` v5 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.next:()I` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L160750.  v0:= v5.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L160754.  v2:= v5.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L160758.  call `checkNotNull`(v2) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L16075e.  call temp:= `size`(v2) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L160764.  v2:= temp @kind wide;
  #L160766.  v4:= lcmp(v0, v2);
  #L16076a.  if v4 == 0 then goto L160772;
  #L16076e.  v0:= 1I;
  #L160770.  goto L160774;
  #L160772.  v0:= 0I;
  #L160774.  if v0 == 0 then goto L1607a6;
  #L160778.  v0:= v5.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L16077c.  v2:= -1L;
  #L160780.  v4:= lcmp(v0, v2);
  #L160784.  if v4 != 0 then goto L16078e;
  #L160788.  v0:= 0L;
  #L16078c.  goto L16079c;
  #L16078e.  v2:= v5.`okio.Buffer$UnsafeCursor.end` @type ^`int`;
  #L160792.  v3:= v5.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L160796.  v2:= v2 - v3 @kind int;
  #L160798.  v2:= (`long`) v2 @kind i2l;
  #L16079a.  v0:= v0 + v2 @kind long;
  #L16079c.  call temp:= `seek`(v5, v0) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @kind virtual;
  #L1607a2.  v0:= temp;
  #L1607a4.  return v0;
  #L1607a6.  v0:= new `java.lang.IllegalStateException`;
  #L1607aa.  v1:= "no more bytes" @kind object;
  #L1607ae.  call temp:= `toString`(v1) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L1607b4.  v1:= temp @kind object;
  #L1607b6.  call `<init>`(v0, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1607bc.  throw v0;
}
procedure `long` `resizeBuffer`(`okio.Buffer$UnsafeCursor` v16 @kind this, `long` v17 ) @signature `Lokio/Buffer$UnsafeCursor;.resizeBuffer:(J)J` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;

  #L160af8.  v0:= v16 @kind object;
  #L160afc.  v1:= v17 @kind wide;
  #L160b00.  v3:= v0.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L160b04.  if v3 == 0 then goto L160c5e;
  #L160b08.  v4:= v0.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L160b0c.  if v4 == 0 then goto L160c46;
  #L160b10.  call temp:= `size`(v3) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L160b16.  v4:= temp @kind wide;
  #L160b18.  v7:= 1I;
  #L160b1a.  v8:= 0L;
  #L160b1e.  v10:= lcmp(v1, v4);
  #L160b22.  if v10 > 0 then goto L160bdc;
  #L160b26.  v10:= lcmp(v1, v8);
  #L160b2a.  if v10 < 0 then goto L160b32;
  #L160b2e.  v6:= 1I;
  #L160b30.  goto L160b34;
  #L160b32.  v6:= 0I;
  #L160b34.  if v6 == 0 then goto L160ba6;
  #L160b38.  v6:= v4 - v1 @kind long;
  #L160b3c.  v10:= lcmp(v6, v8);
  #L160b40.  if v10 <= 0 then goto L160b8c;
  #L160b44.  v10:= v3.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L160b48.  call `checkNotNull`(v10) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L160b4e.  v10:= v10.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L160b52.  call `checkNotNull`(v10) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L160b58.  v11:= v10.`okio.Segment.limit` @type ^`int`;
  #L160b5c.  v12:= v10.`okio.Segment.pos` @type ^`int`;
  #L160b60.  v12:= v11 - v12 @kind int;
  #L160b64.  v12:= (`long`) v12 @kind i2l;
  #L160b66.  v14:= lcmp(v12, v6);
  #L160b6a.  if v14 > 0 then goto L160b84;
  #L160b6e.  call temp:= `pop`(v10) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L160b74.  v11:= temp @kind object;
  #L160b76.  v3.`okio.Buffer.head` @type ^`okio.Segment` := v11 @kind object;
  #L160b7a.  call `recycle`(v10) @signature `Lokio/SegmentPool;.recycle:(Lokio/Segment;)V` @kind static;
  #L160b80.  v6:= v6 - v12 @kind long;
  #L160b82.  goto L160b3c;
  #L160b84.  v7:= (`int`) v6 @kind l2i;
  #L160b86.  v11:= v11 - v7 @kind int;
  #L160b88.  v10.`okio.Segment.limit` @type ^`int` := v11;
  #L160b8c.  v6:= 0I;
  #L160b8e.  v0.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` := v6 @kind object;
  #L160b92.  v0.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v1 @kind wide;
  #L160b96.  v0.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v6 @kind object;
  #L160b9a.  v6:= -1I;
  #L160b9c.  v0.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v6;
  #L160ba0.  v0.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v6;
  #L160ba4.  goto L160c3e;
  #L160ba6.  v3:= new `java.lang.StringBuilder`;
  #L160baa.  call `<init>`(v3) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L160bb0.  v4:= "newSize < 0: " @kind object;
  #L160bb4.  call temp:= `append`(v3, v4) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L160bba.  call temp:= `append`(v3, v1) @signature `Ljava/lang/StringBuilder;.append:(J)Ljava/lang/StringBuilder;` @kind virtual;
  #L160bc0.  call temp:= `toString`(v3) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L160bc6.  v1:= temp @kind object;
  #L160bc8.  v2:= new `java.lang.IllegalArgumentException`;
  #L160bcc.  call temp:= `toString`(v1) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160bd2.  v1:= temp @kind object;
  #L160bd4.  call `<init>`(v2, v1) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160bda.  throw v2;
  #L160bdc.  if v10 <= 0 then goto L160c3e;
  #L160be0.  v10:= v1 - v4 @kind long;
  #L160be4.  v12:= 1I;
  #L160be6.  v13:= lcmp(v10, v8);
  #L160bea.  if v13 <= 0 then goto L160c3e;
  #L160bee.  call temp:= `writableSegment$okio`(v3, v7) @signature `Lokio/Buffer;.writableSegment$okio:(I)Lokio/Segment;` @kind virtual;
  #L160bf4.  v13:= temp @kind object;
  #L160bf6.  v14:= v13.`okio.Segment.limit` @type ^`int`;
  #L160bfa.  v14:= v14 - 8192;
  #L160bfe.  v14:= (`long`) v14 @kind i2l;
  #L160c00.  call temp:= `min`(v10, v14) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L160c06.  v14:= temp @kind wide;
  #L160c08.  v15:= (`int`) v14 @kind l2i;
  #L160c0a.  v14:= v13.`okio.Segment.limit` @type ^`int`;
  #L160c0e.  v14:= v14 + v15 @kind int;
  #L160c10.  v13.`okio.Segment.limit` @type ^`int` := v14;
  #L160c14.  v6:= (`long`) v15 @kind i2l;
  #L160c16.  v10:= v10 - v6 @kind long;
  #L160c18.  if v12 == 0 then goto L160c3a;
  #L160c1c.  v0.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` := v13 @kind object;
  #L160c20.  v0.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v4 @kind wide;
  #L160c24.  v6:= v13.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L160c28.  v0.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v6 @kind object;
  #L160c2c.  v6:= v14 - v15 @kind int;
  #L160c30.  v0.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v6;
  #L160c34.  v0.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v14;
  #L160c38.  v12:= 0I;
  #L160c3a.  v7:= 1I;
  #L160c3c.  goto L160be6;
  #L160c3e.  call `setSize$okio`(v3, v1) @signature `Lokio/Buffer;.setSize$okio:(J)V` @kind virtual;
  #L160c44.  return v4 @kind wide;
  #L160c46.  v1:= new `java.lang.IllegalStateException`;
  #L160c4a.  v2:= "resizeBuffer() only permitted for read/write buffers" @kind object;
  #L160c4e.  call temp:= `toString`(v2) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160c54.  v2:= temp @kind object;
  #L160c56.  call `<init>`(v1, v2) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160c5c.  throw v1;
  #L160c5e.  v1:= new `java.lang.IllegalStateException`;
  #L160c62.  v2:= "not attached to a buffer" @kind object;
  #L160c66.  call temp:= `toString`(v2) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L160c6c.  v2:= temp @kind object;
  #L160c6e.  call `<init>`(v1, v2) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L160c74.  throw v1;
}
procedure `int` `seek`(`okio.Buffer$UnsafeCursor` v12 @kind this, `long` v13 ) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;

  #L1607d0.  v0:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L1607d4.  if v0 == 0 then goto L1609ac;
  #L1607d8.  v1:= -1I;
  #L1607da.  v2:= (`long`) v1 @kind i2l;
  #L1607dc.  v4:= lcmp(v13, v2);
  #L1607e0.  if v4 < 0 then goto L160954;
  #L1607e4.  call temp:= `size`(v0) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L1607ea.  v2:= temp @kind wide;
  #L1607ec.  v4:= lcmp(v13, v2);
  #L1607f0.  if v4 > 0 then goto L160954;
  #L1607f4.  v2:= -1L;
  #L1607f8.  v4:= lcmp(v13, v2);
  #L1607fc.  if v4 == 0 then goto L16093c;
  #L160800.  call temp:= `size`(v0) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L160806.  v2:= temp @kind wide;
  #L160808.  v4:= lcmp(v13, v2);
  #L16080c.  if v4 != 0 then goto L160814;
  #L160810.  goto L16093c;
  #L160814.  v1:= 0L;
  #L160818.  call temp:= `size`(v0) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L16081e.  v3:= temp @kind wide;
  #L160820.  v5:= v0.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L160824.  v6:= v12.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` @kind object;
  #L160828.  if v6 == 0 then goto L160862;
  #L16082c.  v7:= v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L160830.  v9:= v12.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L160834.  call `checkNotNull`(v6) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L16083a.  v6:= v6.`okio.Segment.pos` @type ^`int`;
  #L16083e.  v9:= v9 - v6 @kind int;
  #L160840.  v9:= (`long`) v9 @kind i2l;
  #L160842.  v7:= v7 - v9 @kind long;
  #L160844.  v6:= lcmp(v7, v13);
  #L160848.  if v6 <= 0 then goto L160858;
  #L16084c.  v3:= v12.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` @kind object;
  #L160850.  v6:= v5 @kind object;
  #L160852.  v5:= v3 @kind object;
  #L160854.  v3:= v7 @kind wide;
  #L160856.  goto L160864;
  #L160858.  v1:= v12.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` @kind object;
  #L16085c.  v6:= v1 @kind object;
  #L16085e.  v1:= v7 @kind wide;
  #L160860.  goto L160864;
  #L160862.  v6:= v5 @kind object;
  #L160864.  v7:= v3 - v13 @kind long;
  #L160868.  v9:= v13 - v1 @kind long;
  #L16086c.  v11:= lcmp(v7, v9);
  #L160870.  if v11 <= 0 then goto L16089e;
  #L160874.  call `checkNotNull`(v6) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L16087a.  v3:= v6.`okio.Segment.limit` @type ^`int`;
  #L16087e.  v4:= v6.`okio.Segment.pos` @type ^`int`;
  #L160882.  v5:= v3 - v4 @kind int;
  #L160886.  v7:= (`long`) v5 @kind i2l;
  #L160888.  v7:= v7 + v1 @kind long;
  #L16088a.  v5:= lcmp(v13, v7);
  #L16088e.  if v5 < 0 then goto L1608ca;
  #L160892.  v3:= v3 - v4 @kind int;
  #L160894.  v3:= (`long`) v3 @kind i2l;
  #L160896.  v1:= v1 + v3 @kind long;
  #L160898.  v6:= v6.`okio.Segment.next` @type ^`okio.Segment` @kind object;
  #L16089c.  goto L160874;
  #L16089e.  v1:= lcmp(v3, v13);
  #L1608a2.  if v1 <= 0 then goto L1608c6;
  #L1608a6.  call `checkNotNull`(v5) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L1608ac.  v5:= v5.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L1608b0.  call `checkNotNull`(v5) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L1608b6.  v1:= v5.`okio.Segment.limit` @type ^`int`;
  #L1608ba.  v2:= v5.`okio.Segment.pos` @type ^`int`;
  #L1608be.  v1:= v1 - v2 @kind int;
  #L1608c0.  v1:= (`long`) v1 @kind i2l;
  #L1608c2.  v3:= v3 - v1 @kind long;
  #L1608c4.  goto L16089e;
  #L1608c6.  v1:= v3 @kind wide;
  #L1608c8.  v6:= v5 @kind object;
  #L1608ca.  v3:= v12.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L1608ce.  if v3 == 0 then goto L16090c;
  #L1608d2.  call `checkNotNull`(v6) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L1608d8.  v3:= v6.`okio.Segment.shared` @type ^`boolean` @kind boolean;
  #L1608dc.  if v3 == 0 then goto L16090c;
  #L1608e0.  call temp:= `unsharedCopy`(v6) @signature `Lokio/Segment;.unsharedCopy:()Lokio/Segment;` @kind virtual;
  #L1608e6.  v3:= temp @kind object;
  #L1608e8.  v4:= v0.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L1608ec.  if v4 != v6 then goto L1608f4;
  #L1608f0.  v0.`okio.Buffer.head` @type ^`okio.Segment` := v3 @kind object;
  #L1608f4.  call temp:= `push`(v6, v3) @signature `Lokio/Segment;.push:(Lokio/Segment;)Lokio/Segment;` @kind virtual;
  #L1608fa.  v6:= temp @kind object;
  #L1608fc.  v0:= v6.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L160900.  call `checkNotNull`(v0) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L160906.  call temp:= `pop`(v0) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L16090c.  v12.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` := v6 @kind object;
  #L160910.  v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v13 @kind wide;
  #L160914.  call `checkNotNull`(v6) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L16091a.  v0:= v6.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L16091e.  v12.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L160922.  v0:= v6.`okio.Segment.pos` @type ^`int`;
  #L160926.  v13:= v13 - v1 @kind long;
  #L160928.  v14:= (`int`) v13 @kind l2i;
  #L16092a.  v0:= v0 + v14 @kind int;
  #L16092c.  v12.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L160930.  v13:= v6.`okio.Segment.limit` @type ^`int`;
  #L160934.  v12.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v13;
  #L160938.  v13:= v13 - v0 @kind int;
  #L16093a.  return v13;
  #L16093c.  v0:= 0I;
  #L16093e.  v12.`okio.Buffer$UnsafeCursor.a` @type ^`okio.Segment` := v0 @kind object;
  #L160942.  v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v13 @kind wide;
  #L160946.  v12.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L16094a.  v12.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v1;
  #L16094e.  v12.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v1;
  #L160952.  return v1;
  #L160954.  v1:= new `java.lang.ArrayIndexOutOfBoundsException`;
  #L160958.  v2:= `@@kotlin.jvm.internal.StringCompanionObject.INSTANCE` @type ^`kotlin.jvm.internal.StringCompanionObject` @kind object;
  #L16095c.  v2:= 2I;
  #L16095e.  v3:= new `java.lang.Object`[v2];
  #L160962.  v4:= 0I;
  #L160964.  call temp:= `valueOf`(v13) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L16096a.  v13:= temp @kind object;
  #L16096c.  v3[v4]:= v13 @kind object;
  #L160970.  v13:= 1I;
  #L160972.  call temp:= `size`(v0) @signature `Lokio/Buffer;.size:()J` @kind virtual;
  #L160978.  v4:= temp @kind wide;
  #L16097a.  call temp:= `valueOf`(v4) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L160980.  v14:= temp @kind object;
  #L160982.  v3[v13]:= v14 @kind object;
  #L160986.  call temp:= `copyOf`(v3, v2) @signature `Ljava/util/Arrays;.copyOf:([Ljava/lang/Object;I)[Ljava/lang/Object;` @kind static;
  #L16098c.  v13:= temp @kind object;
  #L16098e.  v14:= "offset=%s > size=%s" @kind object;
  #L160992.  call temp:= `format`(v14, v13) @signature `Ljava/lang/String;.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;` @kind static;
  #L160998.  v13:= temp @kind object;
  #L16099a.  v14:= "java.lang.String.format(format, *args)" @kind object;
  #L16099e.  call `checkNotNullExpressionValue`(v13, v14) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNullExpressionValue:(Ljava/lang/Object;Ljava/lang/String;)V` @kind static;
  #L1609a4.  call `<init>`(v1, v13) @signature `Ljava/lang/ArrayIndexOutOfBoundsException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1609aa.  throw v1;
  #L1609ac.  v13:= new `java.lang.IllegalStateException`;
  #L1609b0.  v14:= "not attached to a buffer" @kind object;
  #L1609b4.  call temp:= `toString`(v14) @signature `Ljava/lang/Object;.toString:()Ljava/lang/String;` @kind virtual;
  #L1609ba.  v14:= temp @kind object;
  #L1609bc.  call `<init>`(v13, v14) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1609c2.  throw v13;
}

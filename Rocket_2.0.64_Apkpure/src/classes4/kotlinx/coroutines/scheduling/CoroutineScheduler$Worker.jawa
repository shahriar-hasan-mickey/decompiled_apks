record `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` @kind class @AccessFlag PUBLIC_FINAL extends `java.lang.Thread` @kind class {
  `long` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.a` @AccessFlag PRIVATE;
  `long` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.b` @AccessFlag PRIVATE;
  `int` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.c` @AccessFlag PRIVATE;
  `kotlinx.coroutines.scheduling.CoroutineScheduler` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @AccessFlag FINAL_SYNTHETIC;
  `int` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.indexInArray` @AccessFlag PRIVATE_VOLATILE;
  `kotlinx.coroutines.scheduling.WorkQueue` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @AccessFlag PUBLIC_FINAL;
  `boolean` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.mayHaveLocalTasks` @AccessFlag PUBLIC;
  `java.lang.Object` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.nextParkedWorker` @AccessFlag PRIVATE_VOLATILE;
  `kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @AccessFlag PUBLIC;
  `int` `kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.workerCtl` @AccessFlag VOLATILE_SYNTHETIC;
}
global `java.util.concurrent.atomic.AtomicIntegerFieldUpdater` `@@kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.e` @AccessFlag STATIC_FINAL_SYNTHETIC;
procedure `void` `<clinit>`() @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L123eb4.  v0:= constclass @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` @kind object;
  #L123eb8.  v1:= "workerCtl" @kind object;
  #L123ebc.  call temp:= `newUpdater`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater;.newUpdater:(Ljava/lang/Class;Ljava/lang/String;)Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater;` @kind static;
  #L123ec2.  v0:= temp @kind object;
  #L123ec4.  `@@kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.e` @type ^`java.util.concurrent.atomic.AtomicIntegerFieldUpdater` := v0 @kind object;
  #L123ec8.  return @kind void;
}
procedure `void` `<init>`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v0 @kind this, `kotlinx.coroutines.scheduling.CoroutineScheduler` v1 @kind object) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.<init>:(Lkotlinx/coroutines/scheduling/CoroutineScheduler;)V` @AccessFlag PRIVATE_CONSTRUCTOR {
    temp;

  #L123edc.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` := v1 @kind object;
  #L123ee0.  call `<init>`(v0) @signature `Ljava/lang/Thread;.<init>:()V` @kind direct;
  #L123ee6.  v1:= 1I;
  #L123ee8.  call `setDaemon`(v0, v1) @signature `Ljava/lang/Thread;.setDaemon:(Z)V` @kind virtual;
  #L123eee.  v1:= new `kotlinx.coroutines.scheduling.WorkQueue`;
  #L123ef2.  call `<init>`(v1) @signature `Lkotlinx/coroutines/scheduling/WorkQueue;.<init>:()V` @kind direct;
  #L123ef8.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` := v1 @kind object;
  #L123efc.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.DORMANT` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123f00.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` := v1 @kind object;
  #L123f04.  v1:= 0I;
  #L123f06.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.workerCtl` @type ^`int` := v1;
  #L123f0a.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler.NOT_IN_STACK` @type ^`kotlinx.coroutines.internal.Symbol` @kind object;
  #L123f0e.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.nextParkedWorker` @type ^`java.lang.Object` := v1 @kind object;
  #L123f12.  v1:= `@@kotlin.random.Random.Default` @type ^`kotlin.random.Random$Default` @kind object;
  #L123f16.  call temp:= `nextInt`(v1) @signature `Lkotlin/random/Random$Default;.nextInt:()I` @kind virtual;
  #L123f1c.  v1:= temp;
  #L123f1e.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.c` @type ^`int` := v1;
  #L123f22.  return @kind void;
}
procedure `void` `<init>`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v0 @kind this, `kotlinx.coroutines.scheduling.CoroutineScheduler` v1 @kind object, `int` v2 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.<init>:(Lkotlinx/coroutines/scheduling/CoroutineScheduler;I)V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L123f34.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` := v1 @kind object;
  #L123f38.  call `<init>`(v0, v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.<init>:(Lkotlinx/coroutines/scheduling/CoroutineScheduler;)V` @kind direct;
  #L123f3e.  call `setIndexInArray`(v0, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.setIndexInArray:(I)V` @kind virtual;
  #L123f44.  return @kind void;
}
procedure `void` `a`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v3 @kind this, `int` v4 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.a:(I)V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;

  #L123f58.  if v4 != 0 then goto L123f5e;
  #L123f5c.  return @kind void;
  #L123f5e.  v4:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123f62.  v0:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler.b` @type ^`java.util.concurrent.atomic.AtomicLongFieldUpdater` @kind object;
  #L123f66.  v1:= -2097152L;
  #L123f6c.  call temp:= `addAndGet`(v0, v4, v1) @signature `Ljava/util/concurrent/atomic/AtomicLongFieldUpdater;.addAndGet:(Ljava/lang/Object;J)J` @kind virtual;
  #L123f72.  v4:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123f76.  v0:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.TERMINATED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123f7a.  if v4 == v0 then goto L123f86;
  #L123f7e.  v4:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.DORMANT` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123f82.  v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` := v4 @kind object;
  #L123f86.  return @kind void;
}
procedure `kotlinx.coroutines.scheduling.CoroutineScheduler` `access$getThis$0$p`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v0 @kind object) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.access$getThis$0$p:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;)Lkotlinx/coroutines/scheduling/CoroutineScheduler;` @AccessFlag PUBLIC_STATIC_FINAL_SYNTHETIC {
    temp;

  #L123c30.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123c34.  return v0 @kind object;
}
procedure `void` `b`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v0 @kind this, `int` v1 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.b:(I)V` @AccessFlag PRIVATE_FINAL {
    temp;

  #L123f98.  if v1 != 0 then goto L123f9e;
  #L123f9c.  return @kind void;
  #L123f9e.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.BLOCKING` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123fa2.  call temp:= `tryReleaseCpu`(v0, v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.tryReleaseCpu:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$WorkerState;)Z` @kind virtual;
  #L123fa8.  v1:= temp;
  #L123faa.  if v1 == 0 then goto L123fb8;
  #L123fae.  v1:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123fb2.  call `signalCpuWork`(v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.signalCpuWork:()V` @kind virtual;
  #L123fb8.  return @kind void;
}
procedure `void` `c`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v2 @kind this, `kotlinx.coroutines.scheduling.Task` v3 @kind object) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.c:(Lkotlinx/coroutines/scheduling/Task;)V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;

  #L123fcc.  v0:= v3.`kotlinx.coroutines.scheduling.Task.taskContext` @type ^`kotlinx.coroutines.scheduling.TaskContext` @kind object;
  #L123fd0.  call temp:= `getTaskMode`(v0) @signature `Lkotlinx/coroutines/scheduling/TaskContext;.getTaskMode:()I` @kind interface;
  #L123fd6.  v0:= temp;
  #L123fd8.  call `e`(v2, v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.e:(I)V` @kind direct;
  #L123fde.  call `b`(v2, v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.b:(I)V` @kind direct;
  #L123fe4.  v1:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123fe8.  call `runSafely`(v1, v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.runSafely:(Lkotlinx/coroutines/scheduling/Task;)V` @kind virtual;
  #L123fee.  call `a`(v2, v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.a:(I)V` @kind direct;
  #L123ff4.  return @kind void;
}
procedure `kotlinx.coroutines.scheduling.Task` `d`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v2 @kind this, `boolean` v3 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.d:(Z)Lkotlinx/coroutines/scheduling/Task;` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;

  #L123c64.  v0:= 0I;
  #L123c66.  if v3 == 0 then goto L123cc2;
  #L123c6a.  v3:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123c6e.  v3:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler.corePoolSize` @type ^`int`;
  #L123c72.  v3:= v3 * 2;
  #L123c76.  call temp:= `nextInt`(v2, v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.nextInt:(I)I` @kind virtual;
  #L123c7c.  v3:= temp;
  #L123c7e.  if v3 != 0 then goto L123c86;
  #L123c82.  v3:= 1I;
  #L123c84.  goto L123c88;
  #L123c86.  v3:= 0I;
  #L123c88.  if v3 == 0 then goto L123c9c;
  #L123c8c.  call temp:= `h`(v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.h:()Lkotlinx/coroutines/scheduling/Task;` @kind direct;
  #L123c92.  v1:= temp @kind object;
  #L123c94.  if v1 != 0 then goto L123c9a;
  #L123c98.  goto L123c9c;
  #L123c9a.  return v1 @kind object;
  #L123c9c.  v1:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123ca0.  call temp:= `poll`(v1) @signature `Lkotlinx/coroutines/scheduling/WorkQueue;.poll:()Lkotlinx/coroutines/scheduling/Task;` @kind virtual;
  #L123ca6.  v1:= temp @kind object;
  #L123ca8.  if v1 != 0 then goto L123cc0;
  #L123cac.  if v3 != 0 then goto L123cce;
  #L123cb0.  call temp:= `h`(v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.h:()Lkotlinx/coroutines/scheduling/Task;` @kind direct;
  #L123cb6.  v3:= temp @kind object;
  #L123cb8.  if v3 != 0 then goto L123cbe;
  #L123cbc.  goto L123cce;
  #L123cbe.  return v3 @kind object;
  #L123cc0.  return v1 @kind object;
  #L123cc2.  call temp:= `h`(v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.h:()Lkotlinx/coroutines/scheduling/Task;` @kind direct;
  #L123cc8.  v3:= temp @kind object;
  #L123cca.  if v3 != 0 then goto L123cd6;
  #L123cce.  call temp:= `l`(v2, v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.l:(Z)Lkotlinx/coroutines/scheduling/Task;` @kind direct;
  #L123cd4.  v3:= temp @kind object;
  #L123cd6.  return v3 @kind object;
}
procedure `void` `e`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v2 @kind this, `int` v3 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.e:(I)V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;

  #L124008.  v0:= 0L;
  #L12400c.  v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.a` @type ^`long` := v0 @kind wide;
  #L124010.  v3:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124014.  v0:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.PARKING` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124018.  if v3 != v0 then goto L124024;
  #L12401c.  v3:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.BLOCKING` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124020.  v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` := v3 @kind object;
  #L124024.  return @kind void;
}
procedure `boolean` `f`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v2 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.f:()Z` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;

  #L123ad0.  v0:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.nextParkedWorker` @type ^`java.lang.Object` @kind object;
  #L123ad4.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler.NOT_IN_STACK` @type ^`kotlinx.coroutines.internal.Symbol` @kind object;
  #L123ad8.  if v0 == v1 then goto L123ae0;
  #L123adc.  v0:= 1I;
  #L123ade.  goto L123ae2;
  #L123ae0.  v0:= 0I;
  #L123ae2.  return v0;
}
procedure `void` `g`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v6 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.g:()V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L124038.  v0:= v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.a` @type ^`long` @kind wide;
  #L12403c.  v2:= 0L;
  #L124040.  v4:= lcmp(v0, v2);
  #L124044.  if v4 != 0 then goto L12405e;
  #L124048.  call temp:= `nanoTime`() @signature `Ljava/lang/System;.nanoTime:()J` @kind static;
  #L12404e.  v0:= temp @kind wide;
  #L124050.  v4:= v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L124054.  v4:= v4.`kotlinx.coroutines.scheduling.CoroutineScheduler.idleWorkerKeepAliveNs` @type ^`long` @kind wide;
  #L124058.  v0:= v0 + v4 @kind long;
  #L12405a.  v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.a` @type ^`long` := v0 @kind wide;
  #L12405e.  v0:= v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L124062.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.idleWorkerKeepAliveNs` @type ^`long` @kind wide;
  #L124066.  call `parkNanos`(v0) @signature `Ljava/util/concurrent/locks/LockSupport;.parkNanos:(J)V` @kind static;
  #L12406c.  call temp:= `nanoTime`() @signature `Ljava/lang/System;.nanoTime:()J` @kind static;
  #L124072.  v0:= temp @kind wide;
  #L124074.  v4:= v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.a` @type ^`long` @kind wide;
  #L124078.  v0:= v0 - v4 @kind long;
  #L12407a.  v4:= lcmp(v0, v2);
  #L12407e.  if v4 < 0 then goto L12408c;
  #L124082.  v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.a` @type ^`long` := v2 @kind wide;
  #L124086.  call `m`(v6) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.m:()V` @kind direct;
  #L12408c.  return @kind void;
}
procedure `kotlinx.coroutines.scheduling.Task` `h`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v1 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.h:()Lkotlinx/coroutines/scheduling/Task;` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;

  #L123d5c.  v0:= 2I;
  #L123d5e.  call temp:= `nextInt`(v1, v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.nextInt:(I)I` @kind virtual;
  #L123d64.  v0:= temp;
  #L123d66.  if v0 != 0 then goto L123d98;
  #L123d6a.  v0:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123d6e.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.globalCpuQueue` @type ^`kotlinx.coroutines.scheduling.GlobalQueue` @kind object;
  #L123d72.  call temp:= `removeFirstOrNull`(v0) @signature `Lkotlinx/coroutines/internal/LockFreeTaskQueue;.removeFirstOrNull:()Ljava/lang/Object;` @kind virtual;
  #L123d78.  v0:= temp @kind object;
  #L123d7a.  v0:= (`kotlinx.coroutines.scheduling.Task`) v0 @kind object;
  #L123d7e.  if v0 != 0 then goto L123d96;
  #L123d82.  v0:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123d86.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.globalBlockingQueue` @type ^`kotlinx.coroutines.scheduling.GlobalQueue` @kind object;
  #L123d8a.  call temp:= `removeFirstOrNull`(v0) @signature `Lkotlinx/coroutines/internal/LockFreeTaskQueue;.removeFirstOrNull:()Ljava/lang/Object;` @kind virtual;
  #L123d90.  v0:= temp @kind object;
  #L123d92.  v0:= (`kotlinx.coroutines.scheduling.Task`) v0 @kind object;
  #L123d96.  return v0 @kind object;
  #L123d98.  v0:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123d9c.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.globalBlockingQueue` @type ^`kotlinx.coroutines.scheduling.GlobalQueue` @kind object;
  #L123da0.  call temp:= `removeFirstOrNull`(v0) @signature `Lkotlinx/coroutines/internal/LockFreeTaskQueue;.removeFirstOrNull:()Ljava/lang/Object;` @kind virtual;
  #L123da6.  v0:= temp @kind object;
  #L123da8.  v0:= (`kotlinx.coroutines.scheduling.Task`) v0 @kind object;
  #L123dac.  if v0 != 0 then goto L123dc4;
  #L123db0.  v0:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123db4.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.globalCpuQueue` @type ^`kotlinx.coroutines.scheduling.GlobalQueue` @kind object;
  #L123db8.  call temp:= `removeFirstOrNull`(v0) @signature `Lkotlinx/coroutines/internal/LockFreeTaskQueue;.removeFirstOrNull:()Ljava/lang/Object;` @kind virtual;
  #L123dbe.  v0:= temp @kind object;
  #L123dc0.  v0:= (`kotlinx.coroutines.scheduling.Task`) v0 @kind object;
  #L123dc4.  return v0 @kind object;
}
procedure `void` `i`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v7 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.i:()V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L1240b8.  v0:= 0I;
  #L1240ba.  v1:= 0I;
  #L1240bc.  v2:= v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L1240c0.  call temp:= `isTerminated`(v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.isTerminated:()Z` @kind virtual;
  #L1240c6.  v2:= temp;
  #L1240c8.  if v2 != 0 then goto L124138;
  #L1240cc.  v2:= v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L1240d0.  v3:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.TERMINATED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L1240d4.  if v2 == v3 then goto L124138;
  #L1240d8.  v2:= v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.mayHaveLocalTasks` @type ^`boolean` @kind boolean;
  #L1240dc.  call temp:= `findTask`(v7, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.findTask:(Z)Lkotlinx/coroutines/scheduling/Task;` @kind virtual;
  #L1240e2.  v2:= temp @kind object;
  #L1240e4.  v3:= 0L;
  #L1240e8.  if v2 == 0 then goto L1240f8;
  #L1240ec.  v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.b` @type ^`long` := v3 @kind wide;
  #L1240f0.  call `c`(v7, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.c:(Lkotlinx/coroutines/scheduling/Task;)V` @kind direct;
  #L1240f6.  goto L1240ba;
  #L1240f8.  v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.mayHaveLocalTasks` @type ^`boolean` := v0 @kind boolean;
  #L1240fc.  v5:= v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.b` @type ^`long` @kind wide;
  #L124100.  v2:= lcmp(v5, v3);
  #L124104.  if v2 == 0 then goto L124130;
  #L124108.  if v1 != 0 then goto L124110;
  #L12410c.  v1:= 1I;
  #L12410e.  goto L1240bc;
  #L124110.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.PARKING` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124114.  call temp:= `tryReleaseCpu`(v7, v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.tryReleaseCpu:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$WorkerState;)Z` @kind virtual;
  #L12411a.  call temp:= `interrupted`() @signature `Ljava/lang/Thread;.interrupted:()Z` @kind static;
  #L124120.  v1:= v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.b` @type ^`long` @kind wide;
  #L124124.  call `parkNanos`(v1) @signature `Ljava/util/concurrent/locks/LockSupport;.parkNanos:(J)V` @kind static;
  #L12412a.  v7.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.b` @type ^`long` := v3 @kind wide;
  #L12412e.  goto L1240ba;
  #L124130.  call `k`(v7) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.k:()V` @kind direct;
  #L124136.  goto L1240bc;
  #L124138.  v0:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.TERMINATED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L12413c.  call temp:= `tryReleaseCpu`(v7, v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.tryReleaseCpu:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$WorkerState;)Z` @kind virtual;
  #L124142.  return @kind void;
}
procedure `boolean` `j`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v10 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.j:()Z` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L123af4.  v0:= v10.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123af8.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.CPU_ACQUIRED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123afc.  v2:= 0I;
  #L123afe.  v3:= 1I;
  #L123b00.  if v0 != v1 then goto L123b08;
  #L123b04.  v2:= 1I;
  #L123b06.  goto L123b5c;
  #L123b08.  v0:= v10.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123b0c.  v6:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.controlState` @type ^`long` @kind wide;
  #L123b10.  v4:= 9223367638808264704L;
  #L123b1a.  v4:= v4 ^& v6 @kind long;
  #L123b1c.  v1:= 42I;
  #L123b20.  v4:= v4 ^> v1 @kind long;
  #L123b22.  v1:= (`int`) v4 @kind l2i;
  #L123b24.  if v1 != 0 then goto L123b2c;
  #L123b28.  v0:= 0I;
  #L123b2a.  goto L123b4e;
  #L123b2c.  v4:= 4398046511104L;
  #L123b36.  v8:= v6 - v4 @kind long;
  #L123b3a.  v4:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler.b` @type ^`java.util.concurrent.atomic.AtomicLongFieldUpdater` @kind object;
  #L123b3e.  v5:= v0 @kind object;
  #L123b40.  call temp:= `compareAndSet`(v4, v5, v6, v8) @signature `Ljava/util/concurrent/atomic/AtomicLongFieldUpdater;.compareAndSet:(Ljava/lang/Object;JJ)Z` @kind virtual;
  #L123b46.  v1:= temp;
  #L123b48.  if v1 == 0 then goto L123b0c;
  #L123b4c.  v0:= 1I;
  #L123b4e.  if v0 == 0 then goto L123b5c;
  #L123b52.  v0:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.CPU_ACQUIRED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123b56.  v10.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` := v0 @kind object;
  #L123b5a.  goto L123b04;
  #L123b5c.  return v2;
}
procedure `void` `k`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v3 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.k:()V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;

  #L1241cc.  call temp:= `f`(v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.f:()Z` @kind direct;
  #L1241d2.  v0:= temp;
  #L1241d4.  if v0 != 0 then goto L1241e4;
  #L1241d8.  v0:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L1241dc.  call temp:= `parkedWorkersStackPush`(v0, v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.parkedWorkersStackPush:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;)Z` @kind virtual;
  #L1241e2.  return @kind void;
  #L1241e4.  v0:= -1I;
  #L1241e6.  v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.workerCtl` @type ^`int` := v0;
  #L1241ea.  call temp:= `f`(v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.f:()Z` @kind direct;
  #L1241f0.  v1:= temp;
  #L1241f2.  if v1 == 0 then goto L124234;
  #L1241f6.  v1:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.workerCtl` @type ^`int`;
  #L1241fa.  if v1 != v0 then goto L124234;
  #L1241fe.  v1:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L124202.  call temp:= `isTerminated`(v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.isTerminated:()Z` @kind virtual;
  #L124208.  v1:= temp;
  #L12420a.  if v1 != 0 then goto L124234;
  #L12420e.  v1:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124212.  v2:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.TERMINATED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124216.  if v1 != v2 then goto L12421c;
  #L12421a.  goto L124234;
  #L12421c.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.PARKING` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124220.  call temp:= `tryReleaseCpu`(v3, v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.tryReleaseCpu:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$WorkerState;)Z` @kind virtual;
  #L124226.  call temp:= `interrupted`() @signature `Ljava/lang/Thread;.interrupted:()Z` @kind static;
  #L12422c.  call `g`(v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.g:()V` @kind direct;
  #L124232.  goto L1241ea;
  #L124234.  return @kind void;
}
procedure `kotlinx.coroutines.scheduling.Task` `l`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v17 @kind this, `boolean` v18 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.l:(Z)Lkotlinx/coroutines/scheduling/Task;` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;

  #L123dd8.  v0:= v17 @kind object;
  #L123ddc.  v1:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123de0.  v1:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler.controlState` @type ^`long` @kind wide;
  #L123de4.  v3:= 2097151L;
  #L123dea.  v1:= v1 ^& v3 @kind long;
  #L123dec.  v2:= (`int`) v1 @kind l2i;
  #L123dee.  v1:= 2I;
  #L123df0.  v3:= 0I;
  #L123df2.  if v2 >= v1 then goto L123df8;
  #L123df6.  return v3 @kind object;
  #L123df8.  call temp:= `nextInt`(v0, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.nextInt:(I)I` @kind virtual;
  #L123dfe.  v1:= temp;
  #L123e00.  v4:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123e04.  v5:= 0I;
  #L123e06.  v6:= 9223372036854775807L;
  #L123e10.  v8:= v6 @kind wide;
  #L123e12.  v10:= 0L;
  #L123e16.  if v5 >= v2 then goto L123e92;
  #L123e1a.  v5:= v5 + 1;
  #L123e1e.  v12:= 1I;
  #L123e20.  v1:= v1 + v12 @kind int;
  #L123e22.  if v1 <= v2 then goto L123e28;
  #L123e26.  v1:= 1I;
  #L123e28.  v12:= v4.`kotlinx.coroutines.scheduling.CoroutineScheduler.workers` @type ^`kotlinx.coroutines.internal.ResizableAtomicArray` @kind object;
  #L123e2c.  call temp:= `get`(v12, v1) @signature `Lkotlinx/coroutines/internal/ResizableAtomicArray;.get:(I)Ljava/lang/Object;` @kind virtual;
  #L123e32.  v12:= temp @kind object;
  #L123e34.  v12:= (`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker`) v12 @kind object;
  #L123e38.  if v12 == 0 then goto L123e12;
  #L123e3c.  if v12 == v0 then goto L123e12;
  #L123e40.  if v18 == 0 then goto L123e56;
  #L123e44.  v13:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123e48.  v12:= v12.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123e4c.  call temp:= `tryStealBlockingFrom`(v13, v12) @signature `Lkotlinx/coroutines/scheduling/WorkQueue;.tryStealBlockingFrom:(Lkotlinx/coroutines/scheduling/WorkQueue;)J` @kind virtual;
  #L123e52.  v12:= temp @kind wide;
  #L123e54.  goto L123e66;
  #L123e56.  v13:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123e5a.  v12:= v12.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123e5e.  call temp:= `tryStealFrom`(v13, v12) @signature `Lkotlinx/coroutines/scheduling/WorkQueue;.tryStealFrom:(Lkotlinx/coroutines/scheduling/WorkQueue;)J` @kind virtual;
  #L123e64.  v12:= temp @kind wide;
  #L123e66.  v14:= -1L;
  #L123e6a.  v16:= lcmp(v12, v14);
  #L123e6e.  if v16 != 0 then goto L123e80;
  #L123e72.  v1:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123e76.  call temp:= `poll`(v1) @signature `Lkotlinx/coroutines/scheduling/WorkQueue;.poll:()Lkotlinx/coroutines/scheduling/Task;` @kind virtual;
  #L123e7c.  v1:= temp @kind object;
  #L123e7e.  return v1 @kind object;
  #L123e80.  v14:= lcmp(v12, v10);
  #L123e84.  if v14 <= 0 then goto L123e12;
  #L123e88.  call temp:= `min`(v8, v12) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L123e8e.  v8:= temp @kind wide;
  #L123e90.  goto L123e12;
  #L123e92.  v1:= lcmp(v8, v6);
  #L123e96.  if v1 == 0 then goto L123e9c;
  #L123e9a.  goto L123e9e;
  #L123e9c.  v8:= v10 @kind wide;
  #L123e9e.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.b` @type ^`long` := v8 @kind wide;
  #L123ea2.  return v3 @kind object;
}
procedure `void` `m`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v8 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.m:()V` @AccessFlag PRIVATE_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L124248.  v0:= v8.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L12424c.  v1:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.workers` @type ^`kotlinx.coroutines.internal.ResizableAtomicArray` @kind object;
  #L124250.  @monitorenter v1
  #L124252.  call temp:= `isTerminated`(v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.isTerminated:()Z` @kind virtual;
  #L124258.  v2:= temp;
  #L12425a.  if v2 == 0 then goto L124262;
  #L12425e.  @monitorexit v1
  #L124260.  return @kind void;
  #L124262.  v2:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.controlState` @type ^`long` @kind wide;
  #L124266.  v4:= 2097151L;
  #L12426c.  v2:= v2 ^& v4 @kind long;
  #L12426e.  v3:= (`int`) v2 @kind l2i;
  #L124270.  v2:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.corePoolSize` @type ^`int`;
  #L124274.  if v3 > v2 then goto L12427c;
  #L124278.  @monitorexit v1
  #L12427a.  return @kind void;
  #L12427c.  v2:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.e` @type ^`java.util.concurrent.atomic.AtomicIntegerFieldUpdater` @kind object;
  #L124280.  v3:= -1I;
  #L124282.  v6:= 1I;
  #L124284.  call temp:= `compareAndSet`(v2, v8, v3, v6) @signature `Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater;.compareAndSet:(Ljava/lang/Object;II)Z` @kind virtual;
  #L12428a.  v2:= temp;
  #L12428c.  if v2 != 0 then goto L124294;
  #L124290.  @monitorexit v1
  #L124292.  return @kind void;
  #L124294.  call temp:= `getIndexInArray`(v8) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.getIndexInArray:()I` @kind virtual;
  #L12429a.  v2:= temp;
  #L12429c.  v3:= 0I;
  #L12429e.  call `setIndexInArray`(v8, v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.setIndexInArray:(I)V` @kind virtual;
  #L1242a4.  call `parkedWorkersStackTopUpdate`(v0, v8, v2, v3) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.parkedWorkersStackTopUpdate:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;II)V` @kind virtual;
  #L1242aa.  v3:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler.b` @type ^`java.util.concurrent.atomic.AtomicLongFieldUpdater` @kind object;
  #L1242ae.  call temp:= `getAndDecrement`(v3, v0) @signature `Ljava/util/concurrent/atomic/AtomicLongFieldUpdater;.getAndDecrement:(Ljava/lang/Object;)J` @kind virtual;
  #L1242b4.  v6:= temp @kind wide;
  #L1242b6.  v3:= v6 ^& v4 @kind long;
  #L1242ba.  v4:= (`int`) v3 @kind l2i;
  #L1242bc.  if v4 == v2 then goto L1242ec;
  #L1242c0.  v3:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.workers` @type ^`kotlinx.coroutines.internal.ResizableAtomicArray` @kind object;
  #L1242c4.  call temp:= `get`(v3, v4) @signature `Lkotlinx/coroutines/internal/ResizableAtomicArray;.get:(I)Ljava/lang/Object;` @kind virtual;
  #L1242ca.  v3:= temp @kind object;
  #L1242cc.  call `checkNotNull`(v3) @signature `Lkotlin/jvm/internal/Intrinsics;.checkNotNull:(Ljava/lang/Object;)V` @kind static;
  #L1242d2.  v3:= (`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker`) v3 @kind object;
  #L1242d6.  v5:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.workers` @type ^`kotlinx.coroutines.internal.ResizableAtomicArray` @kind object;
  #L1242da.  call `setSynchronized`(v5, v2, v3) @signature `Lkotlinx/coroutines/internal/ResizableAtomicArray;.setSynchronized:(ILjava/lang/Object;)V` @kind virtual;
  #L1242e0.  call `setIndexInArray`(v3, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.setIndexInArray:(I)V` @kind virtual;
  #L1242e6.  call `parkedWorkersStackTopUpdate`(v0, v3, v4, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler;.parkedWorkersStackTopUpdate:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;II)V` @kind virtual;
  #L1242ec.  v0:= v0.`kotlinx.coroutines.scheduling.CoroutineScheduler.workers` @type ^`kotlinx.coroutines.internal.ResizableAtomicArray` @kind object;
  #L1242f0.  v2:= 0I;
  #L1242f2.  call `setSynchronized`(v0, v4, v2) @signature `Lkotlinx/coroutines/internal/ResizableAtomicArray;.setSynchronized:(ILjava/lang/Object;)V` @kind virtual;
  #L1242f8.  v0:= `@@kotlin.Unit.INSTANCE` @type ^`kotlin.Unit` @kind object;
  #L1242fc.  @monitorexit v1
  #L1242fe.  v0:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.TERMINATED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L124302.  v8.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` := v0 @kind object;
  #L124306.  return @kind void;
  #L124308.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L12430a.  @monitorexit v1
  #L12430c.  throw v0;
  catch `java.lang.Throwable` @[L124252..L12425a] goto L124308;
  catch `java.lang.Throwable` @[L124262..L124274] goto L124308;
  catch `java.lang.Throwable` @[L12427c..L12428c] goto L124308;
  catch `java.lang.Throwable` @[L124294..L1242fc] goto L124308;
}
procedure `kotlinx.coroutines.scheduling.Task` `findTask`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v1 @kind this, `boolean` v2 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.findTask:(Z)Lkotlinx/coroutines/scheduling/Task;` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;

  #L123ce8.  call temp:= `j`(v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.j:()Z` @kind direct;
  #L123cee.  v0:= temp;
  #L123cf0.  if v0 == 0 then goto L123cfe;
  #L123cf4.  call temp:= `d`(v1, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.d:(Z)Lkotlinx/coroutines/scheduling/Task;` @kind direct;
  #L123cfa.  v2:= temp @kind object;
  #L123cfc.  return v2 @kind object;
  #L123cfe.  if v2 == 0 then goto L123d28;
  #L123d02.  v2:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.localQueue` @type ^`kotlinx.coroutines.scheduling.WorkQueue` @kind object;
  #L123d06.  call temp:= `poll`(v2) @signature `Lkotlinx/coroutines/scheduling/WorkQueue;.poll:()Lkotlinx/coroutines/scheduling/Task;` @kind virtual;
  #L123d0c.  v2:= temp @kind object;
  #L123d0e.  if v2 != 0 then goto L123d3c;
  #L123d12.  v2:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123d16.  v2:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler.globalBlockingQueue` @type ^`kotlinx.coroutines.scheduling.GlobalQueue` @kind object;
  #L123d1a.  call temp:= `removeFirstOrNull`(v2) @signature `Lkotlinx/coroutines/internal/LockFreeTaskQueue;.removeFirstOrNull:()Ljava/lang/Object;` @kind virtual;
  #L123d20.  v2:= temp @kind object;
  #L123d22.  v2:= (`kotlinx.coroutines.scheduling.Task`) v2 @kind object;
  #L123d26.  goto L123d3c;
  #L123d28.  v2:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123d2c.  v2:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler.globalBlockingQueue` @type ^`kotlinx.coroutines.scheduling.GlobalQueue` @kind object;
  #L123d30.  call temp:= `removeFirstOrNull`(v2) @signature `Lkotlinx/coroutines/internal/LockFreeTaskQueue;.removeFirstOrNull:()Ljava/lang/Object;` @kind virtual;
  #L123d36.  v2:= temp @kind object;
  #L123d38.  v2:= (`kotlinx.coroutines.scheduling.Task`) v2 @kind object;
  #L123d3c.  if v2 != 0 then goto L123d4a;
  #L123d40.  v2:= 1I;
  #L123d42.  call temp:= `l`(v1, v2) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.l:(Z)Lkotlinx/coroutines/scheduling/Task;` @kind direct;
  #L123d48.  v2:= temp @kind object;
  #L123d4a.  return v2 @kind object;
}
procedure `int` `getIndexInArray`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v1 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.getIndexInArray:()I` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;

  #L123bb8.  v0:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.indexInArray` @type ^`int`;
  #L123bbc.  return v0;
}
procedure `java.lang.Object` `getNextParkedWorker`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v1 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.getNextParkedWorker:()Ljava/lang/Object;` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;

  #L123c18.  v0:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.nextParkedWorker` @type ^`java.lang.Object` @kind object;
  #L123c1c.  return v0 @kind object;
}
procedure `kotlinx.coroutines.scheduling.CoroutineScheduler` `getScheduler`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v1 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.getScheduler:()Lkotlinx/coroutines/scheduling/CoroutineScheduler;` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;

  #L123c48.  call temp:= `access$getThis$0$p`(v1) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.access$getThis$0$p:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;)Lkotlinx/coroutines/scheduling/CoroutineScheduler;` @kind static;
  #L123c4e.  v0:= temp @kind object;
  #L123c50.  return v0 @kind object;
}
procedure `int` `nextInt`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v3 @kind this, `int` v4 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.nextInt:(I)I` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;

  #L123bd0.  v0:= v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.c` @type ^`int`;
  #L123bd4.  v1:= v0 ^< 13;
  #L123bd8.  v0:= v0 ^~ v1 @kind int;
  #L123bda.  v1:= v0 ^> 17;
  #L123bde.  v0:= v0 ^~ v1 @kind int;
  #L123be0.  v1:= v0 ^< 5;
  #L123be4.  v0:= v0 ^~ v1 @kind int;
  #L123be6.  v3.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.c` @type ^`int` := v0;
  #L123bea.  v1:= v4 + -1;
  #L123bee.  v2:= v1 ^& v4 @kind int;
  #L123bf2.  if v2 != 0 then goto L123bfc;
  #L123bf6.  v4:= v0 ^& v1 @kind int;
  #L123bfa.  return v4;
  #L123bfc.  v1:= 2147483647I;
  #L123c02.  v0:= v0 ^& v1 @kind int;
  #L123c04.  v0:= v0 %% v4 @kind int;
  #L123c06.  return v0;
}
procedure `void` `run`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v0 @kind this) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.run:()V` @AccessFlag PUBLIC {
    temp;

  #L1240a0.  call `i`(v0) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.i:()V` @kind direct;
  #L1240a6.  return @kind void;
}
procedure `void` `setIndexInArray`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v2 @kind this, `int` v3 ) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.setIndexInArray:(I)V` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;

  #L124154.  v0:= new `java.lang.StringBuilder`;
  #L124158.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L12415e.  v1:= v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L124162.  v1:= v1.`kotlinx.coroutines.scheduling.CoroutineScheduler.schedulerName` @type ^`java.lang.String` @kind object;
  #L124166.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L12416c.  v1:= "-worker-" @kind object;
  #L124170.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L124176.  if v3 != 0 then goto L124180;
  #L12417a.  v1:= "TERMINATED" @kind object;
  #L12417e.  goto L124188;
  #L124180.  call temp:= `valueOf`(v3) @signature `Ljava/lang/String;.valueOf:(I)Ljava/lang/String;` @kind static;
  #L124186.  v1:= temp @kind object;
  #L124188.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L12418e.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L124194.  v0:= temp @kind object;
  #L124196.  call `setName`(v2, v0) @signature `Ljava/lang/Thread;.setName:(Ljava/lang/String;)V` @kind virtual;
  #L12419c.  v2.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.indexInArray` @type ^`int` := v3;
  #L1241a0.  return @kind void;
}
procedure `void` `setNextParkedWorker`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v0 @kind this, `java.lang.Object` v1 @kind object) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.setNextParkedWorker:(Ljava/lang/Object;)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1241b4.  v0.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.nextParkedWorker` @type ^`java.lang.Object` := v1 @kind object;
  #L1241b8.  return @kind void;
}
procedure `boolean` `tryReleaseCpu`(`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker` v6 @kind this, `kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` v7 @kind object) @signature `Lkotlinx/coroutines/scheduling/CoroutineScheduler$Worker;.tryReleaseCpu:(Lkotlinx/coroutines/scheduling/CoroutineScheduler$WorkerState;)Z` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L123b70.  v0:= v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123b74.  v1:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState.CPU_ACQUIRED` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` @kind object;
  #L123b78.  if v0 != v1 then goto L123b80;
  #L123b7c.  v1:= 1I;
  #L123b7e.  goto L123b82;
  #L123b80.  v1:= 0I;
  #L123b82.  if v1 == 0 then goto L123b9e;
  #L123b86.  v2:= v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.d` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler` @kind object;
  #L123b8a.  v3:= `@@kotlinx.coroutines.scheduling.CoroutineScheduler.b` @type ^`java.util.concurrent.atomic.AtomicLongFieldUpdater` @kind object;
  #L123b8e.  v4:= 4398046511104L;
  #L123b98.  call temp:= `addAndGet`(v3, v2, v4) @signature `Ljava/util/concurrent/atomic/AtomicLongFieldUpdater;.addAndGet:(Ljava/lang/Object;J)J` @kind virtual;
  #L123b9e.  if v0 == v7 then goto L123ba6;
  #L123ba2.  v6.`kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.state` @type ^`kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState` := v7 @kind object;
  #L123ba6.  return v1;
}

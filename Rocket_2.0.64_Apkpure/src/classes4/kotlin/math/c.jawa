record `kotlin.math.c` @kind class @AccessFlag  extends `kotlin.math.b` @kind class {
}
procedure `void` `<init>`(`kotlin.math.c` v0 @kind this) @signature `Lkotlin/math/c;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;

  #L0ca01c.  call `<init>`(v0) @signature `Lkotlin/math/b;.<init>:()V` @kind direct;
  #L0ca022.  return @kind void;
}
procedure `double` `acosh`(`double` v7 ) @signature `Lkotlin/math/c;.acosh:(D)D` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L0c9b94.  v0:= 1.0D;
  #L0c9b98.  v2:= dcmpg(v7, v0);
  #L0c9b9c.  if v2 >= 0 then goto L0c9ba6;
  #L0c9ba0.  v7:= NaND;
  #L0c9ba4.  goto L0c9c26;
  #L0c9ba6.  v0:= `@@kotlin.math.a.f` @type ^`double` @kind wide;
  #L0c9baa.  v2:= dcmpl(v7, v0);
  #L0c9bae.  if v2 <= 0 then goto L0c9bc2;
  #L0c9bb2.  call temp:= `log`(v7) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9bb8.  v7:= temp @kind wide;
  #L0c9bba.  v0:= `@@kotlin.math.a.b` @type ^`double` @kind wide;
  #L0c9bbe.  v7:= v7 + v0 @kind double;
  #L0c9bc0.  goto L0c9c26;
  #L0c9bc2.  v0:= 1I;
  #L0c9bc4.  v0:= (`double`) v0 @kind i2d;
  #L0c9bc6.  v2:= v7 - v0 @kind double;
  #L0c9bca.  v4:= `@@kotlin.math.a.e` @type ^`double` @kind wide;
  #L0c9bce.  v6:= dcmpl(v2, v4);
  #L0c9bd2.  if v6 < 0 then goto L0c9bf0;
  #L0c9bd6.  v2:= v7 * v7 @kind double;
  #L0c9bda.  v2:= v2 - v0 @kind double;
  #L0c9bdc.  call temp:= `sqrt`(v2) @signature `Ljava/lang/Math;.sqrt:(D)D` @kind static;
  #L0c9be2.  v0:= temp @kind wide;
  #L0c9be4.  v7:= v7 + v0 @kind double;
  #L0c9be6.  call temp:= `log`(v7) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9bec.  v7:= temp @kind wide;
  #L0c9bee.  goto L0c9c26;
  #L0c9bf0.  call temp:= `sqrt`(v2) @signature `Ljava/lang/Math;.sqrt:(D)D` @kind static;
  #L0c9bf6.  v7:= temp @kind wide;
  #L0c9bf8.  v0:= `@@kotlin.math.a.d` @type ^`double` @kind wide;
  #L0c9bfc.  v2:= dcmpl(v7, v0);
  #L0c9c00.  if v2 < 0 then goto L0c9c16;
  #L0c9c04.  v0:= v7 * v7 @kind double;
  #L0c9c08.  v0:= v0 * v7 @kind double;
  #L0c9c0c.  v2:= 12I;
  #L0c9c10.  v2:= (`double`) v2 @kind i2d;
  #L0c9c12.  v0:= v0 / v2 @kind double;
  #L0c9c14.  v7:= v7 - v0 @kind double;
  #L0c9c16.  v0:= 2.0D;
  #L0c9c1a.  call temp:= `sqrt`(v0) @signature `Ljava/lang/Math;.sqrt:(D)D` @kind static;
  #L0c9c20.  v0:= temp @kind wide;
  #L0c9c22.  v7:= v7 * v0 @kind double;
  #L0c9c26.  return v7 @kind wide;
}
procedure `double` `asinh`(`double` v5 ) @signature `Lkotlin/math/c;.asinh:(D)D` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L0c9c38.  v0:= `@@kotlin.math.a.e` @type ^`double` @kind wide;
  #L0c9c3c.  v2:= dcmpl(v5, v0);
  #L0c9c40.  if v2 < 0 then goto L0c9ca2;
  #L0c9c44.  v0:= `@@kotlin.math.a.g` @type ^`double` @kind wide;
  #L0c9c48.  v2:= 1I;
  #L0c9c4a.  v3:= dcmpl(v5, v0);
  #L0c9c4e.  if v3 <= 0 then goto L0c9c86;
  #L0c9c52.  v0:= `@@kotlin.math.a.f` @type ^`double` @kind wide;
  #L0c9c56.  v3:= dcmpl(v5, v0);
  #L0c9c5a.  if v3 <= 0 then goto L0c9c6e;
  #L0c9c5e.  call temp:= `log`(v5) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9c64.  v5:= temp @kind wide;
  #L0c9c66.  v0:= `@@kotlin.math.a.b` @type ^`double` @kind wide;
  #L0c9c6a.  v5:= v5 + v0 @kind double;
  #L0c9c6c.  goto L0c9cde;
  #L0c9c6e.  v0:= 2I;
  #L0c9c70.  v0:= (`double`) v0 @kind i2d;
  #L0c9c72.  v5:= v5 * v0 @kind double;
  #L0c9c76.  v0:= (`double`) v2 @kind i2d;
  #L0c9c78.  v0:= v0 / v5 @kind double;
  #L0c9c7a.  v5:= v5 + v0 @kind double;
  #L0c9c7c.  call temp:= `log`(v5) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9c82.  v5:= temp @kind wide;
  #L0c9c84.  goto L0c9cde;
  #L0c9c86.  v0:= v5 * v5 @kind double;
  #L0c9c8a.  v2:= (`double`) v2 @kind i2d;
  #L0c9c8c.  v0:= v0 + v2 @kind double;
  #L0c9c8e.  call temp:= `sqrt`(v0) @signature `Ljava/lang/Math;.sqrt:(D)D` @kind static;
  #L0c9c94.  v0:= temp @kind wide;
  #L0c9c96.  v5:= v5 + v0 @kind double;
  #L0c9c98.  call temp:= `log`(v5) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9c9e.  v5:= temp @kind wide;
  #L0c9ca0.  goto L0c9cde;
  #L0c9ca2.  v0:= -v0 @kind double;
  #L0c9ca4.  v2:= dcmpg(v5, v0);
  #L0c9ca8.  if v2 > 0 then goto L0c9cba;
  #L0c9cac.  v5:= -v5 @kind double;
  #L0c9cae.  call temp:= `asinh`(v5) @signature `Lkotlin/math/c;.asinh:(D)D` @kind static;
  #L0c9cb4.  v5:= temp @kind wide;
  #L0c9cb6.  v5:= -v5 @kind double;
  #L0c9cb8.  goto L0c9cde;
  #L0c9cba.  call temp:= `abs`(v5) @signature `Ljava/lang/Math;.abs:(D)D` @kind static;
  #L0c9cc0.  v0:= temp @kind wide;
  #L0c9cc2.  v2:= `@@kotlin.math.a.d` @type ^`double` @kind wide;
  #L0c9cc6.  v4:= dcmpl(v0, v2);
  #L0c9cca.  if v4 < 0 then goto L0c9cde;
  #L0c9cce.  v0:= v5 * v5 @kind double;
  #L0c9cd2.  v0:= v0 * v5 @kind double;
  #L0c9cd6.  v2:= 6I;
  #L0c9cd8.  v2:= (`double`) v2 @kind i2d;
  #L0c9cda.  v0:= v0 / v2 @kind double;
  #L0c9cdc.  v5:= v5 - v0 @kind double;
  #L0c9cde.  return v5 @kind wide;
}
procedure `double` `atanh`(`double` v5 ) @signature `Lkotlin/math/c;.atanh:(D)D` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L0c9cf0.  call temp:= `abs`(v5) @signature `Ljava/lang/Math;.abs:(D)D` @kind static;
  #L0c9cf6.  v0:= temp @kind wide;
  #L0c9cf8.  v2:= `@@kotlin.math.a.e` @type ^`double` @kind wide;
  #L0c9cfc.  v4:= dcmpg(v0, v2);
  #L0c9d00.  if v4 >= 0 then goto L0c9d2a;
  #L0c9d04.  call temp:= `abs`(v5) @signature `Ljava/lang/Math;.abs:(D)D` @kind static;
  #L0c9d0a.  v0:= temp @kind wide;
  #L0c9d0c.  v2:= `@@kotlin.math.a.d` @type ^`double` @kind wide;
  #L0c9d10.  v4:= dcmpl(v0, v2);
  #L0c9d14.  if v4 <= 0 then goto L0c9d28;
  #L0c9d18.  v0:= v5 * v5 @kind double;
  #L0c9d1c.  v0:= v0 * v5 @kind double;
  #L0c9d20.  v2:= 3I;
  #L0c9d22.  v2:= (`double`) v2 @kind i2d;
  #L0c9d24.  v0:= v0 / v2 @kind double;
  #L0c9d26.  v5:= v5 + v0 @kind double;
  #L0c9d28.  return v5 @kind wide;
  #L0c9d2a.  v0:= 1I;
  #L0c9d2c.  v0:= (`double`) v0 @kind i2d;
  #L0c9d2e.  v2:= v0 + v5 @kind double;
  #L0c9d32.  v0:= v0 - v5 @kind double;
  #L0c9d34.  v2:= v2 / v0 @kind double;
  #L0c9d36.  call temp:= `log`(v2) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9d3c.  v5:= temp @kind wide;
  #L0c9d3e.  v0:= 2I;
  #L0c9d40.  v0:= (`double`) v0 @kind i2d;
  #L0c9d42.  v5:= v5 / v0 @kind double;
  #L0c9d44.  return v5 @kind wide;
}
procedure `void` `getAbsoluteValue$annotations`(`double` v0 ) @signature `Lkotlin/math/c;.getAbsoluteValue$annotations:(D)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca034.  return @kind void;
}
procedure `void` `getAbsoluteValue$annotations`(`float` v0 ) @signature `Lkotlin/math/c;.getAbsoluteValue$annotations:(F)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca048.  return @kind void;
}
procedure `void` `getAbsoluteValue$annotations`(`int` v0 ) @signature `Lkotlin/math/c;.getAbsoluteValue$annotations:(I)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca05c.  return @kind void;
}
procedure `void` `getAbsoluteValue$annotations`(`long` v0 ) @signature `Lkotlin/math/c;.getAbsoluteValue$annotations:(J)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca070.  return @kind void;
}
procedure `int` `getSign`(`int` v0 ) @signature `Lkotlin/math/c;.getSign:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L0c9edc.  if v0 >= 0 then goto L0c9ee4;
  #L0c9ee0.  v0:= -1I;
  #L0c9ee2.  goto L0c9eee;
  #L0c9ee4.  if v0 <= 0 then goto L0c9eec;
  #L0c9ee8.  v0:= 1I;
  #L0c9eea.  goto L0c9eee;
  #L0c9eec.  v0:= 0I;
  #L0c9eee.  return v0;
}
procedure `int` `getSign`(`long` v3 ) @signature `Lkotlin/math/c;.getSign:(J)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L0c9f00.  v0:= 0L;
  #L0c9f04.  v2:= lcmp(v3, v0);
  #L0c9f08.  if v2 >= 0 then goto L0c9f10;
  #L0c9f0c.  v3:= -1I;
  #L0c9f0e.  goto L0c9f1a;
  #L0c9f10.  if v2 <= 0 then goto L0c9f18;
  #L0c9f14.  v3:= 1I;
  #L0c9f16.  goto L0c9f1a;
  #L0c9f18.  v3:= 0I;
  #L0c9f1a.  return v3;
}
procedure `void` `getSign$annotations`(`double` v0 ) @signature `Lkotlin/math/c;.getSign$annotations:(D)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca084.  return @kind void;
}
procedure `void` `getSign$annotations`(`float` v0 ) @signature `Lkotlin/math/c;.getSign$annotations:(F)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca098.  return @kind void;
}
procedure `void` `getSign$annotations`(`int` v0 ) @signature `Lkotlin/math/c;.getSign$annotations:(I)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca0ac.  return @kind void;
}
procedure `void` `getSign$annotations`(`long` v0 ) @signature `Lkotlin/math/c;.getSign$annotations:(J)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca0c0.  return @kind void;
}
procedure `void` `getUlp$annotations`(`double` v0 ) @signature `Lkotlin/math/c;.getUlp$annotations:(D)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca0d4.  return @kind void;
}
procedure `void` `getUlp$annotations`(`float` v0 ) @signature `Lkotlin/math/c;.getUlp$annotations:(F)V` @AccessFlag PUBLIC_STATIC_SYNTHETIC {
    temp;

  #L0ca0e8.  return @kind void;
}
procedure `double` `log`(`double` v3 , `double` v5 ) @signature `Lkotlin/math/c;.log:(DD)D` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;
    v2;

  #L0c9d58.  v0:= 0L;
  #L0c9d5c.  v2:= dcmpg(v5, v0);
  #L0c9d60.  if v2 <= 0 then goto L0c9d90;
  #L0c9d64.  v0:= 1.0D;
  #L0c9d68.  v2:= dcmpg(v5, v0);
  #L0c9d6c.  if v2 != 0 then goto L0c9d74;
  #L0c9d70.  v0:= 1I;
  #L0c9d72.  goto L0c9d76;
  #L0c9d74.  v0:= 0I;
  #L0c9d76.  if v0 == 0 then goto L0c9d7c;
  #L0c9d7a.  goto L0c9d90;
  #L0c9d7c.  call temp:= `log`(v3) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9d82.  v3:= temp @kind wide;
  #L0c9d84.  call temp:= `log`(v5) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9d8a.  v5:= temp @kind wide;
  #L0c9d8c.  v3:= v3 / v5 @kind double;
  #L0c9d8e.  return v3 @kind wide;
  #L0c9d90.  v3:= NaND;
  #L0c9d94.  return v3 @kind wide;
}
procedure `float` `log`(`float` v2 , `float` v3 ) @signature `Lkotlin/math/c;.log:(FF)F` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;

  #L0c9e14.  v0:= 0I;
  #L0c9e16.  v0:= fcmpg(v3, v0);
  #L0c9e1a.  if v0 <= 0 then goto L0c9e50;
  #L0c9e1e.  v0:= 1.0F;
  #L0c9e22.  v0:= fcmpg(v3, v0);
  #L0c9e26.  if v0 != 0 then goto L0c9e2e;
  #L0c9e2a.  v0:= 1I;
  #L0c9e2c.  goto L0c9e30;
  #L0c9e2e.  v0:= 0I;
  #L0c9e30.  if v0 == 0 then goto L0c9e36;
  #L0c9e34.  goto L0c9e50;
  #L0c9e36.  v0:= (`double`) v2 @kind f2d;
  #L0c9e38.  call temp:= `log`(v0) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9e3e.  v0:= temp @kind wide;
  #L0c9e40.  v2:= (`double`) v3 @kind f2d;
  #L0c9e42.  call temp:= `log`(v2) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9e48.  v2:= temp @kind wide;
  #L0c9e4a.  v0:= v0 / v2 @kind double;
  #L0c9e4c.  v2:= (`float`) v0 @kind d2f;
  #L0c9e4e.  return v2;
  #L0c9e50.  v2:= NaNF;
  #L0c9e54.  return v2;
}
procedure `double` `log2`(`double` v2 ) @signature `Lkotlin/math/c;.log2:(D)D` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;

  #L0c9da8.  call temp:= `log`(v2) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9dae.  v2:= temp @kind wide;
  #L0c9db0.  v0:= `@@kotlin.math.a.b` @type ^`double` @kind wide;
  #L0c9db4.  v2:= v2 / v0 @kind double;
  #L0c9db6.  return v2 @kind wide;
}
procedure `float` `log2`(`float` v4 ) @signature `Lkotlin/math/c;.log2:(F)F` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L0c9e68.  v0:= (`double`) v4 @kind f2d;
  #L0c9e6a.  call temp:= `log`(v0) @signature `Ljava/lang/Math;.log:(D)D` @kind static;
  #L0c9e70.  v0:= temp @kind wide;
  #L0c9e72.  v2:= `@@kotlin.math.a.b` @type ^`double` @kind wide;
  #L0c9e76.  v0:= v0 / v2 @kind double;
  #L0c9e78.  v4:= (`float`) v0 @kind d2f;
  #L0c9e7a.  return v4;
}
procedure `int` `roundToInt`(`double` v3 ) @signature `Lkotlin/math/c;.roundToInt:(D)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L0c9f2c.  call temp:= `isNaN`(v3) @signature `Ljava/lang/Double;.isNaN:(D)Z` @kind static;
  #L0c9f32.  v0:= temp;
  #L0c9f34.  if v0 != 0 then goto L0c9f70;
  #L0c9f38.  v0:= 2.147483647E9D;
  #L0c9f42.  v2:= dcmpl(v3, v0);
  #L0c9f46.  if v2 <= 0 then goto L0c9f52;
  #L0c9f4a.  v3:= 2147483647I;
  #L0c9f50.  goto L0c9f6e;
  #L0c9f52.  v0:= -2.147483648E9D;
  #L0c9f56.  v2:= dcmpg(v3, v0);
  #L0c9f5a.  if v2 >= 0 then goto L0c9f64;
  #L0c9f5e.  v3:= -2147483648I;
  #L0c9f62.  goto L0c9f6e;
  #L0c9f64.  call temp:= `round`(v3) @signature `Ljava/lang/Math;.round:(D)J` @kind static;
  #L0c9f6a.  v3:= temp @kind wide;
  #L0c9f6c.  v3:= (`int`) v3 @kind l2i;
  #L0c9f6e.  return v3;
  #L0c9f70.  v3:= new `java.lang.IllegalArgumentException`;
  #L0c9f74.  v4:= "Cannot round NaN value." @kind object;
  #L0c9f78.  call `<init>`(v3, v4) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L0c9f7e.  throw v3;
}
procedure `int` `roundToInt`(`float` v1 ) @signature `Lkotlin/math/c;.roundToInt:(F)I` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;

  #L0c9f90.  call temp:= `isNaN`(v1) @signature `Ljava/lang/Float;.isNaN:(F)Z` @kind static;
  #L0c9f96.  v0:= temp;
  #L0c9f98.  if v0 != 0 then goto L0c9fa6;
  #L0c9f9c.  call temp:= `round`(v1) @signature `Ljava/lang/Math;.round:(F)I` @kind static;
  #L0c9fa2.  v1:= temp;
  #L0c9fa4.  return v1;
  #L0c9fa6.  v1:= new `java.lang.IllegalArgumentException`;
  #L0c9faa.  v0:= "Cannot round NaN value." @kind object;
  #L0c9fae.  call `<init>`(v1, v0) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L0c9fb4.  throw v1;
}
procedure `long` `roundToLong`(`double` v1 ) @signature `Lkotlin/math/c;.roundToLong:(D)J` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L0c9fc8.  call temp:= `isNaN`(v1) @signature `Ljava/lang/Double;.isNaN:(D)Z` @kind static;
  #L0c9fce.  v0:= temp;
  #L0c9fd0.  if v0 != 0 then goto L0c9fde;
  #L0c9fd4.  call temp:= `round`(v1) @signature `Ljava/lang/Math;.round:(D)J` @kind static;
  #L0c9fda.  v1:= temp @kind wide;
  #L0c9fdc.  return v1 @kind wide;
  #L0c9fde.  v1:= new `java.lang.IllegalArgumentException`;
  #L0c9fe2.  v2:= "Cannot round NaN value." @kind object;
  #L0c9fe6.  call `<init>`(v1, v2) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L0c9fec.  throw v1;
}
procedure `long` `roundToLong`(`float` v2 ) @signature `Lkotlin/math/c;.roundToLong:(F)J` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;

  #L0ca000.  v0:= (`double`) v2 @kind f2d;
  #L0ca002.  call temp:= `roundToLong`(v0) @signature `Lkotlin/math/MathKt;.roundToLong:(D)J` @kind static;
  #L0ca008.  v0:= temp @kind wide;
  #L0ca00a.  return v0 @kind wide;
}
procedure `double` `truncate`(`double` v3 ) @signature `Lkotlin/math/c;.truncate:(D)D` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;
    v2;

  #L0c9dc8.  call temp:= `isNaN`(v3) @signature `Ljava/lang/Double;.isNaN:(D)Z` @kind static;
  #L0c9dce.  v0:= temp;
  #L0c9dd0.  if v0 != 0 then goto L0c9e00;
  #L0c9dd4.  call temp:= `isInfinite`(v3) @signature `Ljava/lang/Double;.isInfinite:(D)Z` @kind static;
  #L0c9dda.  v0:= temp;
  #L0c9ddc.  if v0 == 0 then goto L0c9de2;
  #L0c9de0.  goto L0c9e00;
  #L0c9de2.  v0:= 0L;
  #L0c9de6.  v2:= dcmpl(v3, v0);
  #L0c9dea.  if v2 <= 0 then goto L0c9df8;
  #L0c9dee.  call temp:= `floor`(v3) @signature `Ljava/lang/Math;.floor:(D)D` @kind static;
  #L0c9df4.  v3:= temp @kind wide;
  #L0c9df6.  goto L0c9e00;
  #L0c9df8.  call temp:= `ceil`(v3) @signature `Ljava/lang/Math;.ceil:(D)D` @kind static;
  #L0c9dfe.  v3:= temp @kind wide;
  #L0c9e00.  return v3 @kind wide;
}
procedure `float` `truncate`(`float` v2 ) @signature `Lkotlin/math/c;.truncate:(F)F` @AccessFlag PUBLIC_STATIC_FINAL {
    temp;
    v0;
    v1;

  #L0c9e8c.  call temp:= `isNaN`(v2) @signature `Ljava/lang/Float;.isNaN:(F)Z` @kind static;
  #L0c9e92.  v0:= temp;
  #L0c9e94.  if v0 != 0 then goto L0c9ec8;
  #L0c9e98.  call temp:= `isInfinite`(v2) @signature `Ljava/lang/Float;.isInfinite:(F)Z` @kind static;
  #L0c9e9e.  v0:= temp;
  #L0c9ea0.  if v0 == 0 then goto L0c9ea6;
  #L0c9ea4.  goto L0c9ec8;
  #L0c9ea6.  v0:= 0I;
  #L0c9ea8.  v0:= fcmpl(v2, v0);
  #L0c9eac.  if v0 <= 0 then goto L0c9ebc;
  #L0c9eb0.  v0:= (`double`) v2 @kind f2d;
  #L0c9eb2.  call temp:= `floor`(v0) @signature `Ljava/lang/Math;.floor:(D)D` @kind static;
  #L0c9eb8.  v0:= temp @kind wide;
  #L0c9eba.  goto L0c9ec6;
  #L0c9ebc.  v0:= (`double`) v2 @kind f2d;
  #L0c9ebe.  call temp:= `ceil`(v0) @signature `Ljava/lang/Math;.ceil:(D)D` @kind static;
  #L0c9ec4.  v0:= temp @kind wide;
  #L0c9ec6.  v2:= (`float`) v0 @kind d2f;
  #L0c9ec8.  return v2;
}

record `io.reactivex.subjects.UnicastSubject` @kind class @AccessFlag PUBLIC_FINAL extends `io.reactivex.subjects.b` @kind class {
  `io.reactivex.internal.queue.a` `io.reactivex.subjects.UnicastSubject.b` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.subjects.UnicastSubject.c` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.subjects.UnicastSubject.d` @AccessFlag FINAL;
  `boolean` `io.reactivex.subjects.UnicastSubject.e` @AccessFlag FINAL;
  `boolean` `io.reactivex.subjects.UnicastSubject.f` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.subjects.UnicastSubject.g` @AccessFlag VOLATILE;
  `java.lang.Throwable` `io.reactivex.subjects.UnicastSubject.h` @AccessFlag ;
  `java.util.concurrent.atomic.AtomicBoolean` `io.reactivex.subjects.UnicastSubject.i` @AccessFlag FINAL;
  `io.reactivex.internal.observers.BasicIntQueueDisposable` `io.reactivex.subjects.UnicastSubject.j` @AccessFlag FINAL;
  `boolean` `io.reactivex.subjects.UnicastSubject.k` @AccessFlag ;
}
procedure `void` `<init>`(`io.reactivex.subjects.UnicastSubject` v2 @kind this, `int` v3 , `java.lang.Runnable` v4 @kind object, `boolean` v5 ) @signature `Lio/reactivex/subjects/UnicastSubject;.<init>:(ILjava/lang/Runnable;Z)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L2957bc.  call `<init>`(v2) @signature `Lio/reactivex/subjects/b;.<init>:()V` @kind direct;
  #L2957c2.  v0:= new `io.reactivex.internal.queue.a`;
  #L2957c6.  v1:= "capacityHint" @kind object;
  #L2957ca.  call temp:= `f`(v3, v1) @signature `Lio/reactivex/internal/functions/g0;.f:(ILjava/lang/String;)I` @kind static;
  #L2957d0.  v3:= temp;
  #L2957d2.  call `<init>`(v0, v3) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L2957d8.  v2.`io.reactivex.subjects.UnicastSubject.b` @type ^`io.reactivex.internal.queue.a` := v0 @kind object;
  #L2957dc.  v3:= new `java.util.concurrent.atomic.AtomicReference`;
  #L2957e0.  v0:= "onTerminate" @kind object;
  #L2957e4.  call temp:= `e`(v4, v0) @signature `Lio/reactivex/internal/functions/g0;.e:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L2957ea.  v4:= temp @kind object;
  #L2957ec.  call `<init>`(v3, v4) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L2957f2.  v2.`io.reactivex.subjects.UnicastSubject.d` @type ^`java.util.concurrent.atomic.AtomicReference` := v3 @kind object;
  #L2957f6.  v2.`io.reactivex.subjects.UnicastSubject.e` @type ^`boolean` := v5 @kind boolean;
  #L2957fa.  v3:= new `java.util.concurrent.atomic.AtomicReference`;
  #L2957fe.  call `<init>`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L295804.  v2.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` := v3 @kind object;
  #L295808.  v3:= new `java.util.concurrent.atomic.AtomicBoolean`;
  #L29580c.  call `<init>`(v3) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.<init>:()V` @kind direct;
  #L295812.  v2.`io.reactivex.subjects.UnicastSubject.i` @type ^`java.util.concurrent.atomic.AtomicBoolean` := v3 @kind object;
  #L295816.  v3:= new `io.reactivex.subjects.UnicastSubject$UnicastQueueDisposable`;
  #L29581a.  call `<init>`(v3, v2) @signature `Lio/reactivex/subjects/UnicastSubject$UnicastQueueDisposable;.<init>:(Lio/reactivex/subjects/UnicastSubject;)V` @kind direct;
  #L295820.  v2.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` := v3 @kind object;
  #L295824.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.subjects.UnicastSubject` v2 @kind this, `int` v3 , `boolean` v4 ) @signature `Lio/reactivex/subjects/UnicastSubject;.<init>:(IZ)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L29574c.  call `<init>`(v2) @signature `Lio/reactivex/subjects/b;.<init>:()V` @kind direct;
  #L295752.  v0:= new `io.reactivex.internal.queue.a`;
  #L295756.  v1:= "capacityHint" @kind object;
  #L29575a.  call temp:= `f`(v3, v1) @signature `Lio/reactivex/internal/functions/g0;.f:(ILjava/lang/String;)I` @kind static;
  #L295760.  v3:= temp;
  #L295762.  call `<init>`(v0, v3) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L295768.  v2.`io.reactivex.subjects.UnicastSubject.b` @type ^`io.reactivex.internal.queue.a` := v0 @kind object;
  #L29576c.  v3:= new `java.util.concurrent.atomic.AtomicReference`;
  #L295770.  call `<init>`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L295776.  v2.`io.reactivex.subjects.UnicastSubject.d` @type ^`java.util.concurrent.atomic.AtomicReference` := v3 @kind object;
  #L29577a.  v2.`io.reactivex.subjects.UnicastSubject.e` @type ^`boolean` := v4 @kind boolean;
  #L29577e.  v3:= new `java.util.concurrent.atomic.AtomicReference`;
  #L295782.  call `<init>`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L295788.  v2.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` := v3 @kind object;
  #L29578c.  v3:= new `java.util.concurrent.atomic.AtomicBoolean`;
  #L295790.  call `<init>`(v3) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.<init>:()V` @kind direct;
  #L295796.  v2.`io.reactivex.subjects.UnicastSubject.i` @type ^`java.util.concurrent.atomic.AtomicBoolean` := v3 @kind object;
  #L29579a.  v3:= new `io.reactivex.subjects.UnicastSubject$UnicastQueueDisposable`;
  #L29579e.  call `<init>`(v3, v2) @signature `Lio/reactivex/subjects/UnicastSubject$UnicastQueueDisposable;.<init>:(Lio/reactivex/subjects/UnicastSubject;)V` @kind direct;
  #L2957a4.  v2.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` := v3 @kind object;
  #L2957a8.  return @kind void;
}
procedure `io.reactivex.subjects.UnicastSubject` `x`() @signature `Lio/reactivex/subjects/UnicastSubject;.x:()Lio/reactivex/subjects/UnicastSubject;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L2956e4.  v0:= new `io.reactivex.subjects.UnicastSubject`;
  #L2956e8.  call temp:= `c`() @signature `Lio/reactivex/n;.c:()I` @kind static;
  #L2956ee.  v1:= temp;
  #L2956f0.  v2:= 1I;
  #L2956f2.  call `<init>`(v0, v1, v2) @signature `Lio/reactivex/subjects/UnicastSubject;.<init>:(IZ)V` @kind direct;
  #L2956f8.  return v0 @kind object;
}
procedure `io.reactivex.subjects.UnicastSubject` `y`(`int` v2 ) @signature `Lio/reactivex/subjects/UnicastSubject;.y:(I)Lio/reactivex/subjects/UnicastSubject;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L29570c.  v0:= new `io.reactivex.subjects.UnicastSubject`;
  #L295710.  v1:= 1I;
  #L295712.  call `<init>`(v0, v2, v1) @signature `Lio/reactivex/subjects/UnicastSubject;.<init>:(IZ)V` @kind direct;
  #L295718.  return v0 @kind object;
}
procedure `io.reactivex.subjects.UnicastSubject` `z`(`int` v2 , `java.lang.Runnable` v3 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.z:(ILjava/lang/Runnable;)Lio/reactivex/subjects/UnicastSubject;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L29572c.  v0:= new `io.reactivex.subjects.UnicastSubject`;
  #L295730.  v1:= 1I;
  #L295732.  call `<init>`(v0, v2, v3, v1) @signature `Lio/reactivex/subjects/UnicastSubject;.<init>:(ILjava/lang/Runnable;Z)V` @kind direct;
  #L295738.  return v0 @kind object;
}
procedure `void` `A`(`io.reactivex.subjects.UnicastSubject` v3 @kind this) @signature `Lio/reactivex/subjects/UnicastSubject;.A:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L295838.  v0:= v3.`io.reactivex.subjects.UnicastSubject.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L29583c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L295842.  v0:= temp @kind object;
  #L295844.  v0:= (`java.lang.Runnable`) v0 @kind object;
  #L295848.  if v0 == 0 then goto L295864;
  #L29584c.  v1:= v3.`io.reactivex.subjects.UnicastSubject.d` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L295850.  v2:= 0I;
  #L295852.  call temp:= `compareAndSet`(v1, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L295858.  v1:= temp;
  #L29585a.  if v1 == 0 then goto L295864;
  #L29585e.  call `run`(v0) @signature `Ljava/lang/Runnable;.run:()V` @kind interface;
  #L295864.  return @kind void;
}
procedure `void` `B`(`io.reactivex.subjects.UnicastSubject` v2 @kind this) @signature `Lio/reactivex/subjects/UnicastSubject;.B:()V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L295878.  v0:= v2.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` @kind object;
  #L29587c.  call temp:= `getAndIncrement`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L295882.  v0:= temp;
  #L295884.  if v0 == 0 then goto L29588a;
  #L295888.  return @kind void;
  #L29588a.  v0:= v2.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L29588e.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L295894.  v0:= temp @kind object;
  #L295896.  v0:= (`io.reactivex.t`) v0 @kind object;
  #L29589a.  v1:= 1I;
  #L29589c.  if v0 == 0 then goto L2958b8;
  #L2958a0.  v1:= v2.`io.reactivex.subjects.UnicastSubject.k` @type ^`boolean` @kind boolean;
  #L2958a4.  if v1 == 0 then goto L2958b0;
  #L2958a8.  call `C`(v2, v0) @signature `Lio/reactivex/subjects/UnicastSubject;.C:(Lio/reactivex/t;)V` @kind virtual;
  #L2958ae.  goto L2958b6;
  #L2958b0.  call `D`(v2, v0) @signature `Lio/reactivex/subjects/UnicastSubject;.D:(Lio/reactivex/t;)V` @kind virtual;
  #L2958b6.  return @kind void;
  #L2958b8.  v0:= v2.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` @kind object;
  #L2958bc.  v1:= -v1 @kind int;
  #L2958be.  call temp:= `addAndGet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L2958c4.  v1:= temp;
  #L2958c6.  if v1 != 0 then goto L2958cc;
  #L2958ca.  return @kind void;
  #L2958cc.  v0:= v2.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L2958d0.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L2958d6.  v0:= temp @kind object;
  #L2958d8.  v0:= (`io.reactivex.t`) v0 @kind object;
  #L2958dc.  goto L29589c;
}
procedure `void` `C`(`io.reactivex.subjects.UnicastSubject` v6 @kind this, `io.reactivex.t` v7 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.C:(Lio/reactivex/t;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L2958f0.  v0:= v6.`io.reactivex.subjects.UnicastSubject.b` @type ^`io.reactivex.internal.queue.a` @kind object;
  #L2958f4.  v1:= v6.`io.reactivex.subjects.UnicastSubject.e` @type ^`boolean` @kind boolean;
  #L2958f8.  v2:= 1I;
  #L2958fa.  v1:= v1 ^~ v2 @kind int;
  #L2958fc.  v3:= v6.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L295900.  v4:= 0I;
  #L295902.  if v3 == 0 then goto L295918;
  #L295906.  v7:= v6.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L29590a.  call `lazySet`(v7, v4) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L295910.  call `clear`(v0) @signature `Lio/reactivex/internal/queue/a;.clear:()V` @kind virtual;
  #L295916.  return @kind void;
  #L295918.  v3:= v6.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` @kind boolean;
  #L29591c.  if v1 == 0 then goto L295932;
  #L295920.  if v3 == 0 then goto L295932;
  #L295924.  call temp:= `F`(v6, v0, v7) @signature `Lio/reactivex/subjects/UnicastSubject;.F:(Lio/reactivex/e0/a/j;Lio/reactivex/t;)Z` @kind virtual;
  #L29592a.  v5:= temp;
  #L29592c.  if v5 == 0 then goto L295932;
  #L295930.  return @kind void;
  #L295932.  call `onNext`(v7, v4) @signature `Lio/reactivex/t;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L295938.  if v3 == 0 then goto L295944;
  #L29593c.  call `E`(v6, v7) @signature `Lio/reactivex/subjects/UnicastSubject;.E:(Lio/reactivex/t;)V` @kind virtual;
  #L295942.  return @kind void;
  #L295944.  v3:= v6.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` @kind object;
  #L295948.  v2:= -v2 @kind int;
  #L29594a.  call temp:= `addAndGet`(v3, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L295950.  v2:= temp;
  #L295952.  if v2 != 0 then goto L2958fc;
  #L295956.  return @kind void;
}
procedure `void` `D`(`io.reactivex.subjects.UnicastSubject` v9 @kind this, `io.reactivex.t` v10 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.D:(Lio/reactivex/t;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L295968.  v0:= v9.`io.reactivex.subjects.UnicastSubject.b` @type ^`io.reactivex.internal.queue.a` @kind object;
  #L29596c.  v1:= v9.`io.reactivex.subjects.UnicastSubject.e` @type ^`boolean` @kind boolean;
  #L295970.  v2:= 1I;
  #L295972.  v1:= v1 ^~ v2 @kind int;
  #L295974.  v3:= 1I;
  #L295976.  v4:= 1I;
  #L295978.  v5:= v9.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L29597c.  if v5 == 0 then goto L295994;
  #L295980.  v10:= v9.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L295984.  v1:= 0I;
  #L295986.  call `lazySet`(v10, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L29598c.  call `clear`(v0) @signature `Lio/reactivex/e0/a/j;.clear:()V` @kind interface;
  #L295992.  return @kind void;
  #L295994.  v5:= v9.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` @kind boolean;
  #L295998.  v6:= v9.`io.reactivex.subjects.UnicastSubject.b` @type ^`io.reactivex.internal.queue.a` @kind object;
  #L29599c.  call temp:= `poll`(v6) @signature `Lio/reactivex/internal/queue/a;.poll:()Ljava/lang/Object;` @kind virtual;
  #L2959a2.  v6:= temp @kind object;
  #L2959a4.  v7:= 0I;
  #L2959a6.  if v6 != 0 then goto L2959ae;
  #L2959aa.  v8:= 1I;
  #L2959ac.  goto L2959b0;
  #L2959ae.  v8:= 0I;
  #L2959b0.  if v5 == 0 then goto L2959d8;
  #L2959b4.  if v1 == 0 then goto L2959cc;
  #L2959b8.  if v3 == 0 then goto L2959cc;
  #L2959bc.  call temp:= `F`(v9, v0, v10) @signature `Lio/reactivex/subjects/UnicastSubject;.F:(Lio/reactivex/e0/a/j;Lio/reactivex/t;)Z` @kind virtual;
  #L2959c2.  v3:= temp;
  #L2959c4.  if v3 == 0 then goto L2959ca;
  #L2959c8.  return @kind void;
  #L2959ca.  v3:= 0I;
  #L2959cc.  if v8 == 0 then goto L2959d8;
  #L2959d0.  call `E`(v9, v10) @signature `Lio/reactivex/subjects/UnicastSubject;.E:(Lio/reactivex/t;)V` @kind virtual;
  #L2959d6.  return @kind void;
  #L2959d8.  if v8 == 0 then goto L2959f0;
  #L2959dc.  v5:= v9.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` @kind object;
  #L2959e0.  v4:= -v4 @kind int;
  #L2959e2.  call temp:= `addAndGet`(v5, v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L2959e8.  v4:= temp;
  #L2959ea.  if v4 != 0 then goto L295978;
  #L2959ee.  return @kind void;
  #L2959f0.  call `onNext`(v10, v6) @signature `Lio/reactivex/t;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L2959f6.  goto L295978;
}
procedure `void` `E`(`io.reactivex.subjects.UnicastSubject` v2 @kind this, `io.reactivex.t` v3 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.E:(Lio/reactivex/t;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L295a08.  v0:= v2.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L295a0c.  v1:= 0I;
  #L295a0e.  call `lazySet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L295a14.  v0:= v2.`io.reactivex.subjects.UnicastSubject.h` @type ^`java.lang.Throwable` @kind object;
  #L295a18.  if v0 == 0 then goto L295a24;
  #L295a1c.  call `onError`(v3, v0) @signature `Lio/reactivex/t;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L295a22.  goto L295a2a;
  #L295a24.  call `onComplete`(v3) @signature `Lio/reactivex/t;.onComplete:()V` @kind interface;
  #L295a2a.  return @kind void;
}
procedure `boolean` `F`(`io.reactivex.subjects.UnicastSubject` v3 @kind this, `io.reactivex.e0.a.j` v4 @kind object, `io.reactivex.t` v5 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.F:(Lio/reactivex/e0/a/j;Lio/reactivex/t;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L2956ac.  v0:= v3.`io.reactivex.subjects.UnicastSubject.h` @type ^`java.lang.Throwable` @kind object;
  #L2956b0.  if v0 == 0 then goto L2956d0;
  #L2956b4.  v1:= v3.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L2956b8.  v2:= 0I;
  #L2956ba.  call `lazySet`(v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L2956c0.  call `clear`(v4) @signature `Lio/reactivex/e0/a/j;.clear:()V` @kind interface;
  #L2956c6.  call `onError`(v5, v0) @signature `Lio/reactivex/t;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L2956cc.  v4:= 1I;
  #L2956ce.  return v4;
  #L2956d0.  v4:= 0I;
  #L2956d2.  return v4;
}
procedure `void` `onComplete`(`io.reactivex.subjects.UnicastSubject` v1 @kind this) @signature `Lio/reactivex/subjects/UnicastSubject;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L295a3c.  v0:= v1.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` @kind boolean;
  #L295a40.  if v0 != 0 then goto L295a60;
  #L295a44.  v0:= v1.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L295a48.  if v0 == 0 then goto L295a4e;
  #L295a4c.  goto L295a60;
  #L295a4e.  v0:= 1I;
  #L295a50.  v1.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` := v0 @kind boolean;
  #L295a54.  call `A`(v1) @signature `Lio/reactivex/subjects/UnicastSubject;.A:()V` @kind virtual;
  #L295a5a.  call `B`(v1) @signature `Lio/reactivex/subjects/UnicastSubject;.B:()V` @kind virtual;
  #L295a60.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.subjects.UnicastSubject` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L295a74.  v0:= "onError called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L295a78.  call temp:= `e`(v2, v0) @signature `Lio/reactivex/internal/functions/g0;.e:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L295a7e.  v0:= v1.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` @kind boolean;
  #L295a82.  if v0 != 0 then goto L295aa8;
  #L295a86.  v0:= v1.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L295a8a.  if v0 == 0 then goto L295a90;
  #L295a8e.  goto L295aa8;
  #L295a90.  v1.`io.reactivex.subjects.UnicastSubject.h` @type ^`java.lang.Throwable` := v2 @kind object;
  #L295a94.  v2:= 1I;
  #L295a96.  v1.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` := v2 @kind boolean;
  #L295a9a.  call `A`(v1) @signature `Lio/reactivex/subjects/UnicastSubject;.A:()V` @kind virtual;
  #L295aa0.  call `B`(v1) @signature `Lio/reactivex/subjects/UnicastSubject;.B:()V` @kind virtual;
  #L295aa6.  return @kind void;
  #L295aa8.  call `t`(v2) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L295aae.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.subjects.UnicastSubject` v1 @kind this, `java.lang.Object` v2 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L295ac0.  v0:= "onNext called with null. Null values are generally not allowed in 2.x operators and sources." @kind object;
  #L295ac4.  call temp:= `e`(v2, v0) @signature `Lio/reactivex/internal/functions/g0;.e:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L295aca.  v0:= v1.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` @kind boolean;
  #L295ace.  if v0 != 0 then goto L295aec;
  #L295ad2.  v0:= v1.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L295ad6.  if v0 == 0 then goto L295adc;
  #L295ada.  goto L295aec;
  #L295adc.  v0:= v1.`io.reactivex.subjects.UnicastSubject.b` @type ^`io.reactivex.internal.queue.a` @kind object;
  #L295ae0.  call temp:= `offer`(v0, v2) @signature `Lio/reactivex/internal/queue/a;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L295ae6.  call `B`(v1) @signature `Lio/reactivex/subjects/UnicastSubject;.B:()V` @kind virtual;
  #L295aec.  return @kind void;
}
procedure `void` `onSubscribe`(`io.reactivex.subjects.UnicastSubject` v1 @kind this, `io.reactivex.disposables.b` v2 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.onSubscribe:(Lio/reactivex/disposables/b;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L295b00.  v0:= v1.`io.reactivex.subjects.UnicastSubject.g` @type ^`boolean` @kind boolean;
  #L295b04.  if v0 != 0 then goto L295b10;
  #L295b08.  v0:= v1.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L295b0c.  if v0 == 0 then goto L295b16;
  #L295b10.  call `dispose`(v2) @signature `Lio/reactivex/disposables/b;.dispose:()V` @kind interface;
  #L295b16.  return @kind void;
}
procedure `void` `subscribeActual`(`io.reactivex.subjects.UnicastSubject` v3 @kind this, `io.reactivex.t` v4 @kind object) @signature `Lio/reactivex/subjects/UnicastSubject;.subscribeActual:(Lio/reactivex/t;)V` @AccessFlag PROTECTED {
    temp;
    v0;
    v1;
    v2;

  #L295b28.  v0:= v3.`io.reactivex.subjects.UnicastSubject.i` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L295b2c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L295b32.  v0:= temp;
  #L295b34.  if v0 != 0 then goto L295b7e;
  #L295b38.  v0:= v3.`io.reactivex.subjects.UnicastSubject.i` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L295b3c.  v1:= 0I;
  #L295b3e.  v2:= 1I;
  #L295b40.  call temp:= `compareAndSet`(v0, v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.compareAndSet:(ZZ)Z` @kind virtual;
  #L295b46.  v0:= temp;
  #L295b48.  if v0 == 0 then goto L295b7e;
  #L295b4c.  v0:= v3.`io.reactivex.subjects.UnicastSubject.j` @type ^`io.reactivex.internal.observers.BasicIntQueueDisposable` @kind object;
  #L295b50.  call `onSubscribe`(v4, v0) @signature `Lio/reactivex/t;.onSubscribe:(Lio/reactivex/disposables/b;)V` @kind interface;
  #L295b56.  v0:= v3.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L295b5a.  call `lazySet`(v0, v4) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L295b60.  v4:= v3.`io.reactivex.subjects.UnicastSubject.f` @type ^`boolean` @kind boolean;
  #L295b64.  if v4 == 0 then goto L295b76;
  #L295b68.  v4:= v3.`io.reactivex.subjects.UnicastSubject.c` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L295b6c.  v0:= 0I;
  #L295b6e.  call `lazySet`(v4, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L295b74.  return @kind void;
  #L295b76.  call `B`(v3) @signature `Lio/reactivex/subjects/UnicastSubject;.B:()V` @kind virtual;
  #L295b7c.  goto L295b92;
  #L295b7e.  v0:= new `java.lang.IllegalStateException`;
  #L295b82.  v1:= "Only a single observer allowed." @kind object;
  #L295b86.  call `<init>`(v0, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L295b8c.  call `error`(v0, v4) @signature `Lio/reactivex/internal/disposables/EmptyDisposable;.error:(Ljava/lang/Throwable;Lio/reactivex/t;)V` @kind static;
  #L295b92.  return @kind void;
}

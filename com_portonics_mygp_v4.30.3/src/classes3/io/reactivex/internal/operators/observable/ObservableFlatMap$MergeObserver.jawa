record `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.disposables.b` @kind interface, `io.reactivex.t` @kind interface {
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.delayErrors` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @AccessFlag VOLATILE;
  `io.reactivex.t` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @AccessFlag ;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @AccessFlag ;
  `io.reactivex.d0.k` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.mapper` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @AccessFlag FINAL;
  `io.reactivex.e0.a.i` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @AccessFlag VOLATILE;
  `java.util.Queue` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @AccessFlag ;
  `long` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.uniqueId` @AccessFlag ;
  `io.reactivex.disposables.b` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @AccessFlag ;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @AccessFlag ;
}
global `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L2746b8.  v0:= 0I;
  #L2746ba.  v1:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v0];
  #L2746be.  `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] := v1 @kind object;
  #L2746c2.  v0:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v0];
  #L2746c6.  `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] := v0 @kind object;
  #L2746ca.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this, `io.reactivex.t` v2 @kind object, `io.reactivex.d0.k` v3 @kind object, `boolean` v4 , `int` v5 , `int` v6 ) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.<init>:(Lio/reactivex/t;Lio/reactivex/d0/k;ZII)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L2746dc.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L2746e2.  v0:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L2746e6.  call `<init>`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L2746ec.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` := v0 @kind object;
  #L2746f0.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.t` := v2 @kind object;
  #L2746f4.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.mapper` @type ^`io.reactivex.d0.k` := v3 @kind object;
  #L2746f8.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.delayErrors` @type ^`boolean` := v4 @kind boolean;
  #L2746fc.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int` := v5;
  #L274700.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @type ^`int` := v6;
  #L274704.  v2:= 2147483647I;
  #L27470a.  if v5 == v2 then goto L27471c;
  #L27470e.  v2:= new `java.util.ArrayDeque`;
  #L274712.  call `<init>`(v2, v5) @signature `Ljava/util/ArrayDeque;.<init>:(I)V` @kind direct;
  #L274718.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` := v2 @kind object;
  #L27471c.  v2:= new `java.util.concurrent.atomic.AtomicReference`;
  #L274720.  v3:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L274724.  call `<init>`(v2, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L27472a.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` := v2 @kind object;
  #L27472e.  return @kind void;
}
procedure `boolean` `addInner`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v4 @kind this, `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver` v5 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.addInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L274494.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L274498.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L27449e.  v0:= temp @kind object;
  #L2744a0.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L2744a4.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L2744a8.  v2:= 0I;
  #L2744aa.  if v0 != v1 then goto L2744b6;
  #L2744ae.  call `dispose`(v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.dispose:()V` @kind virtual;
  #L2744b4.  return v2;
  #L2744b6.  v1:= length @variable v0;
  #L2744b8.  v3:= v1 + 1;
  #L2744bc.  v3:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v3];
  #L2744c0.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L2744c6.  v3[v1]:= v5 @kind object;
  #L2744ca.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L2744ce.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L2744d4.  v0:= temp;
  #L2744d6.  if v0 == 0 then goto L274494;
  #L2744da.  v5:= 1I;
  #L2744dc.  return v5;
}
procedure `boolean` `checkTerminate`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v3 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L2744f0.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` @kind boolean;
  #L2744f4.  v1:= 1I;
  #L2744f6.  if v0 == 0 then goto L2744fc;
  #L2744fa.  return v1;
  #L2744fc.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L274500.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L274506.  v0:= temp @kind object;
  #L274508.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L27450c.  v2:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.delayErrors` @type ^`boolean` @kind boolean;
  #L274510.  if v2 != 0 then goto L27453e;
  #L274514.  if v0 == 0 then goto L27453e;
  #L274518.  call temp:= `disposeAll`(v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.disposeAll:()Z` @kind virtual;
  #L27451e.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L274522.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L274528.  v0:= temp @kind object;
  #L27452a.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L27452e.  if v0 == v2 then goto L27453c;
  #L274532.  v2:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.t` @kind object;
  #L274536.  call `onError`(v2, v0) @signature `Lio/reactivex/t;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L27453c.  return v1;
  #L27453e.  v0:= 0I;
  #L274540.  return v0;
}
procedure `void` `dispose`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v2 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.dispose:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L274740.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` @kind boolean;
  #L274744.  if v0 != 0 then goto L274778;
  #L274748.  v0:= 1I;
  #L27474a.  v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L27474e.  call temp:= `disposeAll`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.disposeAll:()Z` @kind virtual;
  #L274754.  v0:= temp;
  #L274756.  if v0 == 0 then goto L274778;
  #L27475a.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L27475e.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L274764.  v0:= temp @kind object;
  #L274766.  if v0 == 0 then goto L274778;
  #L27476a.  v1:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L27476e.  if v0 == v1 then goto L274778;
  #L274772.  call `t`(v0) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L274778.  return @kind void;
}
procedure `boolean` `disposeAll`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v4 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.disposeAll:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L274554.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.b` @kind object;
  #L274558.  call `dispose`(v0) @signature `Lio/reactivex/disposables/b;.dispose:()V` @kind interface;
  #L27455e.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L274562.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L274568.  v0:= temp @kind object;
  #L27456a.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L27456e.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L274572.  v2:= 0I;
  #L274574.  if v0 == v1 then goto L2745a6;
  #L274578.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L27457c.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L274582.  v0:= temp @kind object;
  #L274584.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L274588.  if v0 == v1 then goto L2745a6;
  #L27458c.  v1:= length @variable v0;
  #L27458e.  if v2 >= v1 then goto L2745a2;
  #L274592.  v3:= v0[v2] @kind object;
  #L274596.  call `dispose`(v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.dispose:()V` @kind virtual;
  #L27459c.  v2:= v2 + 1;
  #L2745a0.  goto L27458e;
  #L2745a2.  v0:= 1I;
  #L2745a4.  return v0;
  #L2745a6.  return v2;
}
procedure `void` `drain`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @AccessFlag  {
    temp;
    v0;

  #L27478c.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L274792.  v0:= temp;
  #L274794.  if v0 != 0 then goto L27479e;
  #L274798.  call `drainLoop`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @kind virtual;
  #L27479e.  return @kind void;
}
procedure `void` `drainLoop`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v14 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;

  #L2747b0.  v0:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.t` @kind object;
  #L2747b4.  v1:= 1I;
  #L2747b6.  v2:= 1I;
  #L2747b8.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L2747be.  v3:= temp;
  #L2747c0.  if v3 == 0 then goto L2747c6;
  #L2747c4.  return @kind void;
  #L2747c6.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L2747ca.  if v3 == 0 then goto L2747f2;
  #L2747ce.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L2747d4.  v4:= temp;
  #L2747d6.  if v4 == 0 then goto L2747dc;
  #L2747da.  return @kind void;
  #L2747dc.  call temp:= `poll`(v3) @signature `Lio/reactivex/e0/a/i;.poll:()Ljava/lang/Object;` @kind interface;
  #L2747e2.  v4:= temp @kind object;
  #L2747e4.  if v4 != 0 then goto L2747ea;
  #L2747e8.  goto L2747f2;
  #L2747ea.  call `onNext`(v0, v4) @signature `Lio/reactivex/t;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L2747f0.  goto L2747ce;
  #L2747f2.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L2747f6.  v4:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L2747fa.  v5:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L2747fe.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L274804.  v5:= temp @kind object;
  #L274806.  v5:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v5 @kind object;
  #L27480a.  v6:= length @variable v5;
  #L27480c.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L274810.  v8:= 2147483647I;
  #L274816.  v9:= 0I;
  #L274818.  if v7 == v8 then goto L274834;
  #L27481c.  @monitorenter v14
  #L27481e.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L274822.  call temp:= `size`(v7) @signature `Ljava/util/Queue;.size:()I` @kind interface;
  #L274828.  v7:= temp;
  #L27482a.  @monitorexit v14
  #L27482c.  goto L274836;
  #L27482e.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L274830.  @monitorexit v14
  #L274832.  throw v0;
  #L274834.  v7:= 0I;
  #L274836.  if v3 == 0 then goto L27487a;
  #L27483a.  if v4 == 0 then goto L27484a;
  #L27483e.  call temp:= `isEmpty`(v4) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L274844.  v3:= temp;
  #L274846.  if v3 == 0 then goto L27487a;
  #L27484a.  if v6 != 0 then goto L27487a;
  #L27484e.  if v7 != 0 then goto L27487a;
  #L274852.  v1:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L274856.  call temp:= `terminate`(v1) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L27485c.  v1:= temp @kind object;
  #L27485e.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L274862.  if v1 == v2 then goto L274878;
  #L274866.  if v1 != 0 then goto L274872;
  #L27486a.  call `onComplete`(v0) @signature `Lio/reactivex/t;.onComplete:()V` @kind interface;
  #L274870.  goto L274878;
  #L274872.  call `onError`(v0, v1) @signature `Lio/reactivex/t;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L274878.  return @kind void;
  #L27487a.  if v6 == 0 then goto L2749ac;
  #L27487e.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @type ^`long` @kind wide;
  #L274882.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @type ^`int`;
  #L274886.  if v6 <= v7 then goto L27489a;
  #L27488a.  v10:= v5[v7] @kind object;
  #L27488e.  v10:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L274892.  v12:= lcmp(v10, v3);
  #L274896.  if v12 == 0 then goto L2748d8;
  #L27489a.  if v6 > v7 then goto L2748a0;
  #L27489e.  v7:= 0I;
  #L2748a0.  v10:= 0I;
  #L2748a2.  if v10 >= v6 then goto L2748c8;
  #L2748a6.  v11:= v5[v7] @kind object;
  #L2748aa.  v11:= v11.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L2748ae.  v13:= lcmp(v11, v3);
  #L2748b2.  if v13 != 0 then goto L2748b8;
  #L2748b6.  goto L2748c8;
  #L2748b8.  v7:= v7 + 1;
  #L2748bc.  if v7 != v6 then goto L2748c2;
  #L2748c0.  v7:= 0I;
  #L2748c2.  v10:= v10 + 1;
  #L2748c6.  goto L2748a2;
  #L2748c8.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @type ^`int` := v7;
  #L2748cc.  v3:= v5[v7] @kind object;
  #L2748d0.  v3:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L2748d4.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @type ^`long` := v3 @kind wide;
  #L2748d8.  v3:= 0I;
  #L2748da.  v4:= 0I;
  #L2748dc.  if v3 >= v6 then goto L27499a;
  #L2748e0.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L2748e6.  v10:= temp;
  #L2748e8.  if v10 == 0 then goto L2748ee;
  #L2748ec.  return @kind void;
  #L2748ee.  v10:= v5[v7] @kind object;
  #L2748f2.  v11:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L2748f6.  if v11 == 0 then goto L274956;
  #L2748fa.  call temp:= `poll`(v11) @signature `Lio/reactivex/e0/a/j;.poll:()Ljava/lang/Object;` @kind interface;
  #L274900.  v12:= temp @kind object;
  #L274902.  if v12 != 0 then goto L274908;
  #L274906.  goto L274956;
  #L274908.  call `onNext`(v0, v12) @signature `Lio/reactivex/t;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L27490e.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L274914.  v12:= temp;
  #L274916.  if v12 == 0 then goto L2748fa;
  #L27491a.  return @kind void;
  #L27491c.  v11:= Exception @type ^`java.lang.Throwable` @kind object;
  #L27491e.  call `b`(v11) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L274924.  call `dispose`(v10) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.dispose:()V` @kind virtual;
  #L27492a.  v12:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L27492e.  call temp:= `addThrowable`(v12, v11) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L274934.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L27493a.  v11:= temp;
  #L27493c.  if v11 == 0 then goto L274942;
  #L274940.  return @kind void;
  #L274942.  call `removeInner`(v14, v10) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.removeInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @kind virtual;
  #L274948.  v4:= v4 + 1;
  #L27494c.  v7:= v7 + 1;
  #L274950.  if v7 != v6 then goto L274994;
  #L274954.  goto L274992;
  #L274956.  v11:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.done` @type ^`boolean` @kind boolean;
  #L27495a.  v12:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L27495e.  if v11 == 0 then goto L27498a;
  #L274962.  if v12 == 0 then goto L274972;
  #L274966.  call temp:= `isEmpty`(v12) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L27496c.  v11:= temp;
  #L27496e.  if v11 == 0 then goto L27498a;
  #L274972.  call `removeInner`(v14, v10) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.removeInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @kind virtual;
  #L274978.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L27497e.  v10:= temp;
  #L274980.  if v10 == 0 then goto L274986;
  #L274984.  return @kind void;
  #L274986.  v4:= v4 + 1;
  #L27498a.  v7:= v7 + 1;
  #L27498e.  if v7 != v6 then goto L274994;
  #L274992.  v7:= 0I;
  #L274994.  v3:= v3 + 1;
  #L274998.  goto L2748dc;
  #L27499a.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @type ^`int` := v7;
  #L27499e.  v3:= v5[v7] @kind object;
  #L2749a2.  v5:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L2749a6.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @type ^`long` := v5 @kind wide;
  #L2749aa.  v9:= v4;
  #L2749ac.  if v9 == 0 then goto L2749f6;
  #L2749b0.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L2749b4.  if v3 == v8 then goto L2747b8;
  #L2749b8.  v3:= v9 + -1;
  #L2749bc.  if v9 == 0 then goto L2747b8;
  #L2749c0.  @monitorenter v14
  #L2749c2.  v4:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L2749c6.  call temp:= `poll`(v4) @signature `Ljava/util/Queue;.poll:()Ljava/lang/Object;` @kind interface;
  #L2749cc.  v4:= temp @kind object;
  #L2749ce.  v4:= (`io.reactivex.r`) v4 @kind object;
  #L2749d2.  if v4 != 0 then goto L2749e4;
  #L2749d6.  v4:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L2749da.  v4:= v4 - v1 @kind int;
  #L2749dc.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int` := v4;
  #L2749e0.  @monitorexit v14
  #L2749e2.  goto L2749ec;
  #L2749e4.  @monitorexit v14
  #L2749e6.  call `subscribeInner`(v14, v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.subscribeInner:(Lio/reactivex/r;)V` @kind virtual;
  #L2749ec.  v9:= v3;
  #L2749ee.  goto L2749b8;
  #L2749f0.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L2749f2.  @monitorexit v14
  #L2749f4.  throw v0;
  #L2749f6.  v2:= -v2 @kind int;
  #L2749f8.  call temp:= `addAndGet`(v14, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L2749fe.  v2:= temp;
  #L274a00.  if v2 != 0 then goto L2747b8;
  #L274a04.  return @kind void;
  catch `java.lang.Throwable` @[L27481e..L274832] goto L27482e;
  catch `java.lang.Throwable` @[L2748fa..L274902] goto L27491c;
  catch `java.lang.Throwable` @[L2749c2..L2749e6] goto L2749f0;
  catch `java.lang.Throwable` @[L2749f2..L2749f4] goto L2749f0;
}
procedure `boolean` `isDisposed`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.isDisposed:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L2745b8.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` @kind boolean;
  #L2745bc.  return v0;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L274a44.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L274a48.  if v0 == 0 then goto L274a4e;
  #L274a4c.  return @kind void;
  #L274a4e.  v0:= 1I;
  #L274a50.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` := v0 @kind boolean;
  #L274a54.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L274a5a.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L274a6c.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L274a70.  if v0 == 0 then goto L274a7c;
  #L274a74.  call `t`(v2) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L274a7a.  return @kind void;
  #L274a7c.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L274a80.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L274a86.  v0:= temp;
  #L274a88.  if v0 == 0 then goto L274a9a;
  #L274a8c.  v2:= 1I;
  #L274a8e.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` := v2 @kind boolean;
  #L274a92.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L274a98.  goto L274aa0;
  #L274a9a.  call `t`(v2) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L274aa0.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v2 @kind this, `java.lang.Object` v3 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L274ab4.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L274ab8.  if v0 == 0 then goto L274abe;
  #L274abc.  return @kind void;
  #L274abe.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.mapper` @type ^`io.reactivex.d0.k` @kind object;
  #L274ac2.  call temp:= `apply`(v0, v3) @signature `Lio/reactivex/d0/k;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L274ac8.  v3:= temp @kind object;
  #L274aca.  v0:= "The mapper returned a null ObservableSource" @kind object;
  #L274ace.  call temp:= `e`(v3, v0) @signature `Lio/reactivex/internal/functions/g0;.e:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L274ad4.  v3:= temp @kind object;
  #L274ad6.  v3:= (`io.reactivex.r`) v3 @kind object;
  #L274ada.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L274ade.  v1:= 2147483647I;
  #L274ae4.  if v0 == v1 then goto L274b16;
  #L274ae8.  @monitorenter v2
  #L274aea.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L274aee.  v1:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L274af2.  if v0 != v1 then goto L274b04;
  #L274af6.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L274afa.  call temp:= `offer`(v0, v3) @signature `Ljava/util/Queue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L274b00.  @monitorexit v2
  #L274b02.  return @kind void;
  #L274b04.  v0:= v0 + 1;
  #L274b08.  v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int` := v0;
  #L274b0c.  @monitorexit v2
  #L274b0e.  goto L274b16;
  #L274b10.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L274b12.  @monitorexit v2
  #L274b14.  throw v3;
  #L274b16.  call `subscribeInner`(v2, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.subscribeInner:(Lio/reactivex/r;)V` @kind virtual;
  #L274b1c.  return @kind void;
  #L274b1e.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L274b20.  call `b`(v3) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L274b26.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.b` @kind object;
  #L274b2a.  call `dispose`(v0) @signature `Lio/reactivex/disposables/b;.dispose:()V` @kind interface;
  #L274b30.  call `onError`(v2, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L274b36.  return @kind void;
  catch `java.lang.Throwable` @[L274abe..L274ada] goto L274b1e;
  catch `java.lang.Throwable` @[L274aea..L274b14] goto L274b10;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this, `io.reactivex.disposables.b` v2 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onSubscribe:(Lio/reactivex/disposables/b;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L274b60.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.b` @kind object;
  #L274b64.  call temp:= `validate`(v0, v2) @signature `Lio/reactivex/internal/disposables/DisposableHelper;.validate:(Lio/reactivex/disposables/b;Lio/reactivex/disposables/b;)Z` @kind static;
  #L274b6a.  v0:= temp;
  #L274b6c.  if v0 == 0 then goto L274b7e;
  #L274b70.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.b` := v2 @kind object;
  #L274b74.  v2:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.t` @kind object;
  #L274b78.  call `onSubscribe`(v2, v1) @signature `Lio/reactivex/t;.onSubscribe:(Lio/reactivex/disposables/b;)V` @kind interface;
  #L274b7e.  return @kind void;
}
procedure `void` `removeInner`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v6 @kind this, `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver` v7 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.removeInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L274b90.  v0:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L274b94.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L274b9a.  v0:= temp @kind object;
  #L274b9c.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L274ba0.  v1:= length @variable v0;
  #L274ba2.  if v1 != 0 then goto L274ba8;
  #L274ba6.  return @kind void;
  #L274ba8.  v2:= -1I;
  #L274baa.  v3:= 0I;
  #L274bac.  v4:= 0I;
  #L274bae.  if v4 >= v1 then goto L274bc4;
  #L274bb2.  v5:= v0[v4] @kind object;
  #L274bb6.  if v5 != v7 then goto L274bbe;
  #L274bba.  v2:= v4;
  #L274bbc.  goto L274bc4;
  #L274bbe.  v4:= v4 + 1;
  #L274bc2.  goto L274bae;
  #L274bc4.  if v2 >= 0 then goto L274bca;
  #L274bc8.  return @kind void;
  #L274bca.  v4:= 1I;
  #L274bcc.  if v1 != v4 then goto L274bd6;
  #L274bd0.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L274bd4.  goto L274bf4;
  #L274bd6.  v5:= v1 + -1;
  #L274bda.  v5:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v5];
  #L274bde.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L274be4.  v3:= v2 + 1;
  #L274be8.  v1:= v1 - v2 @kind int;
  #L274bea.  v1:= v1 - v4 @kind int;
  #L274bec.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L274bf2.  v1:= v5 @kind object;
  #L274bf4.  v2:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L274bf8.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L274bfe.  v0:= temp;
  #L274c00.  if v0 == 0 then goto L274b90;
  #L274c04.  return @kind void;
}
procedure `void` `subscribeInner`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v5 @kind this, `io.reactivex.r` v6 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.subscribeInner:(Lio/reactivex/r;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L274c18.  v0:= instanceof @variable v6 @type ^`java.util.concurrent.Callable` @kind boolean;
  #L274c1c.  if v0 == 0 then goto L274c7c;
  #L274c20.  v6:= (`java.util.concurrent.Callable`) v6 @kind object;
  #L274c24.  call temp:= `tryEmitScalar`(v5, v6) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.tryEmitScalar:(Ljava/util/concurrent/Callable;)Z` @kind virtual;
  #L274c2a.  v6:= temp;
  #L274c2c.  if v6 == 0 then goto L274ca6;
  #L274c30.  v6:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L274c34.  v0:= 2147483647I;
  #L274c3a.  if v6 == v0 then goto L274ca6;
  #L274c3e.  v6:= 0I;
  #L274c40.  @monitorenter v5
  #L274c42.  v0:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L274c46.  call temp:= `poll`(v0) @signature `Ljava/util/Queue;.poll:()Ljava/lang/Object;` @kind interface;
  #L274c4c.  v0:= temp @kind object;
  #L274c4e.  v0:= (`io.reactivex.r`) v0 @kind object;
  #L274c52.  v1:= 1I;
  #L274c54.  if v0 != 0 then goto L274c64;
  #L274c58.  v6:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L274c5c.  v6:= v6 - v1 @kind int;
  #L274c5e.  v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int` := v6;
  #L274c62.  v6:= 1I;
  #L274c64.  @monitorexit v5
  #L274c66.  if v6 == 0 then goto L274c72;
  #L274c6a.  call `drain`(v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L274c70.  goto L274ca6;
  #L274c72.  v6:= v0 @kind object;
  #L274c74.  goto L274c18;
  #L274c76.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L274c78.  @monitorexit v5
  #L274c7a.  throw v6;
  #L274c7c.  v0:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`;
  #L274c80.  v1:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.uniqueId` @type ^`long` @kind wide;
  #L274c84.  v3:= 1L;
  #L274c88.  v3:= v3 + v1 @kind long;
  #L274c8a.  v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.uniqueId` @type ^`long` := v3 @kind wide;
  #L274c8e.  call `<init>`(v0, v5, v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.<init>:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;J)V` @kind direct;
  #L274c94.  call temp:= `addInner`(v5, v0) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.addInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)Z` @kind virtual;
  #L274c9a.  v1:= temp;
  #L274c9c.  if v1 == 0 then goto L274ca6;
  #L274ca0.  call `subscribe`(v6, v0) @signature `Lio/reactivex/r;.subscribe:(Lio/reactivex/t;)V` @kind interface;
  #L274ca6.  return @kind void;
  catch `java.lang.Throwable` @[L274c42..L274c66] goto L274c76;
  catch `java.lang.Throwable` @[L274c78..L274c7a] goto L274c76;
}
procedure `void` `tryEmit`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v2 @kind this, `java.lang.Object` v3 @kind object, `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver` v4 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.tryEmit:(Ljava/lang/Object;Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L274ccc.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L274cd2.  v0:= temp;
  #L274cd4.  if v0 != 0 then goto L274d00;
  #L274cd8.  v0:= 0I;
  #L274cda.  v1:= 1I;
  #L274cdc.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L274ce2.  v0:= temp;
  #L274ce4.  if v0 == 0 then goto L274d00;
  #L274ce8.  v4:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.t` @kind object;
  #L274cec.  call `onNext`(v4, v3) @signature `Lio/reactivex/t;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L274cf2.  call temp:= `decrementAndGet`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L274cf8.  v3:= temp;
  #L274cfa.  if v3 != 0 then goto L274d2e;
  #L274cfe.  return @kind void;
  #L274d00.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L274d04.  if v0 != 0 then goto L274d1a;
  #L274d08.  v0:= new `io.reactivex.internal.queue.a`;
  #L274d0c.  v1:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @type ^`int`;
  #L274d10.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L274d16.  v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.e0.a.j` := v0 @kind object;
  #L274d1a.  call temp:= `offer`(v0, v3) @signature `Lio/reactivex/e0/a/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L274d20.  call temp:= `getAndIncrement`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L274d26.  v3:= temp;
  #L274d28.  if v3 == 0 then goto L274d2e;
  #L274d2c.  return @kind void;
  #L274d2e.  call `drainLoop`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @kind virtual;
  #L274d34.  return @kind void;
}
procedure `boolean` `tryEmitScalar`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v4 @kind this, `java.util.concurrent.Callable` v5 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.tryEmitScalar:(Ljava/util/concurrent/Callable;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L2745d0.  v0:= 1I;
  #L2745d2.  call temp:= `call`(v5) @signature `Ljava/util/concurrent/Callable;.call:()Ljava/lang/Object;` @kind interface;
  #L2745d8.  v5:= temp @kind object;
  #L2745da.  if v5 != 0 then goto L2745e0;
  #L2745de.  return v0;
  #L2745e0.  call temp:= `get`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L2745e6.  v1:= temp;
  #L2745e8.  v2:= 0I;
  #L2745ea.  if v1 != 0 then goto L274612;
  #L2745ee.  call temp:= `compareAndSet`(v4, v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L2745f4.  v1:= temp;
  #L2745f6.  if v1 == 0 then goto L274612;
  #L2745fa.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.t` @kind object;
  #L2745fe.  call `onNext`(v1, v5) @signature `Lio/reactivex/t;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L274604.  call temp:= `decrementAndGet`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L27460a.  v5:= temp;
  #L27460c.  if v5 != 0 then goto L27467a;
  #L274610.  return v0;
  #L274612.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L274616.  if v1 != 0 then goto L27464a;
  #L27461a.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L27461e.  v3:= 2147483647I;
  #L274624.  if v1 != v3 then goto L274638;
  #L274628.  v1:= new `io.reactivex.internal.queue.a`;
  #L27462c.  v3:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @type ^`int`;
  #L274630.  call `<init>`(v1, v3) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L274636.  goto L274646;
  #L274638.  v1:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L27463c.  v3:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L274640.  call `<init>`(v1, v3) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L274646.  v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.e0.a.i` := v1 @kind object;
  #L27464a.  call temp:= `offer`(v1, v5) @signature `Lio/reactivex/e0/a/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L274650.  v5:= temp;
  #L274652.  if v5 != 0 then goto L27466c;
  #L274656.  v5:= new `java.lang.IllegalStateException`;
  #L27465a.  v1:= "Scalar queue full?!" @kind object;
  #L27465e.  call `<init>`(v5, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L274664.  call `onError`(v4, v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L27466a.  return v0;
  #L27466c.  call temp:= `getAndIncrement`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L274672.  v5:= temp;
  #L274674.  if v5 == 0 then goto L27467a;
  #L274678.  return v2;
  #L27467a.  call `drainLoop`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @kind virtual;
  #L274680.  return v0;
  #L274682.  v5:= Exception @type ^`java.lang.Throwable` @kind object;
  #L274684.  call `b`(v5) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L27468a.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L27468e.  call temp:= `addThrowable`(v1, v5) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L274694.  call `drain`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L27469a.  return v0;
  catch `java.lang.Throwable` @[L2745d2..L2745da] goto L274682;
}

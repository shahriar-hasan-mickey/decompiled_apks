record `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.h` @kind interface, `n.b.d` @kind interface {
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @AccessFlag VOLATILE;
  `n.b.c` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @AccessFlag FINAL;
  `io.reactivex.d0.k` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.mapper` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @AccessFlag VOLATILE;
  `n.b.d` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @AccessFlag ;
}
global `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L25f6c4.  v0:= new `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`;
  #L25f6c8.  v1:= 0I;
  #L25f6ca.  v2:= -1L;
  #L25f6ce.  v4:= 1I;
  #L25f6d0.  call `<init>`(v0, v1, v2, v4) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;JI)V` @kind direct;
  #L25f6d6.  `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` := v0 @kind object;
  #L25f6da.  call `cancel`(v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L25f6e0.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this, `n.b.c` v2 @kind object, `io.reactivex.d0.k` v3 @kind object, `int` v4 , `boolean` v5 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.<init>:(Ln/b/c;Lio/reactivex/d0/k;IZ)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L25f6f4.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L25f6fa.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L25f6fe.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L25f704.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L25f708.  v0:= new `java.util.concurrent.atomic.AtomicLong`;
  #L25f70c.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L25f712.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` := v0 @kind object;
  #L25f716.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @type ^`n.b.c` := v2 @kind object;
  #L25f71a.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.mapper` @type ^`io.reactivex.d0.k` := v3 @kind object;
  #L25f71e.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.bufferSize` @type ^`int` := v4;
  #L25f722.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` := v5 @kind boolean;
  #L25f726.  v2:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L25f72a.  call `<init>`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L25f730.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` := v2 @kind object;
  #L25f734.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L25f748.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L25f74c.  if v0 != 0 then goto L25f766;
  #L25f750.  v0:= 1I;
  #L25f752.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L25f756.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L25f75a.  call `cancel`(v0) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L25f760.  call `disposeInner`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L25f766.  return @kind void;
}
procedure `void` `disposeInner`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L25f778.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f77c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f782.  v0:= temp @kind object;
  #L25f784.  v0:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v0 @kind object;
  #L25f788.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` @kind object;
  #L25f78c.  if v0 == v1 then goto L25f7ae;
  #L25f790.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f794.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L25f79a.  v0:= temp @kind object;
  #L25f79c.  v0:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v0 @kind object;
  #L25f7a0.  if v0 == v1 then goto L25f7ae;
  #L25f7a4.  if v0 == 0 then goto L25f7ae;
  #L25f7a8.  call `cancel`(v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L25f7ae.  return @kind void;
}
procedure `void` `drain`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v17 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;

  #L25f7c0.  v1:= v17 @kind object;
  #L25f7c4.  call temp:= `getAndIncrement`(v17) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L25f7ca.  v0:= temp;
  #L25f7cc.  if v0 == 0 then goto L25f7d2;
  #L25f7d0.  return @kind void;
  #L25f7d2.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L25f7d6.  v4:= 1I;
  #L25f7d8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L25f7dc.  v5:= 0I;
  #L25f7de.  if v0 == 0 then goto L25f7ee;
  #L25f7e2.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f7e6.  call `lazySet`(v0, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L25f7ec.  return @kind void;
  #L25f7ee.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L25f7f2.  if v0 == 0 then goto L25f884;
  #L25f7f6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L25f7fa.  if v0 == 0 then goto L25f83e;
  #L25f7fe.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f802.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f808.  v0:= temp @kind object;
  #L25f80a.  if v0 != 0 then goto L25f884;
  #L25f80e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f812.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f818.  v0:= temp @kind object;
  #L25f81a.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L25f81e.  if v0 == 0 then goto L25f836;
  #L25f822.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f826.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L25f82c.  v0:= temp @kind object;
  #L25f82e.  call `onError`(v2, v0) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L25f834.  goto L25f83c;
  #L25f836.  call `onComplete`(v2) @signature `Ln/b/c;.onComplete:()V` @kind interface;
  #L25f83c.  return @kind void;
  #L25f83e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f842.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f848.  v0:= temp @kind object;
  #L25f84a.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L25f84e.  if v0 == 0 then goto L25f86c;
  #L25f852.  call `disposeInner`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L25f858.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f85c.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L25f862.  v0:= temp @kind object;
  #L25f864.  call `onError`(v2, v0) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L25f86a.  return @kind void;
  #L25f86c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f870.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f876.  v0:= temp @kind object;
  #L25f878.  if v0 != 0 then goto L25f884;
  #L25f87c.  call `onComplete`(v2) @signature `Ln/b/c;.onComplete:()V` @kind interface;
  #L25f882.  return @kind void;
  #L25f884.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f888.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f88e.  v0:= temp @kind object;
  #L25f890.  v6:= v0 @kind object;
  #L25f892.  v6:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v6 @kind object;
  #L25f896.  if v6 == 0 then goto L25f8a2;
  #L25f89a.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L25f89e.  v7:= v0 @kind object;
  #L25f8a0.  goto L25f8a4;
  #L25f8a2.  v7:= v5 @kind object;
  #L25f8a4.  if v7 == 0 then goto L25fa3e;
  #L25f8a8.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber.done` @type ^`boolean` @kind boolean;
  #L25f8ac.  if v0 == 0 then goto L25f91a;
  #L25f8b0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L25f8b4.  if v0 != 0 then goto L25f900;
  #L25f8b8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f8bc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f8c2.  v0:= temp @kind object;
  #L25f8c4.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L25f8c8.  if v0 == 0 then goto L25f8e6;
  #L25f8cc.  call `disposeInner`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L25f8d2.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f8d6.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L25f8dc.  v0:= temp @kind object;
  #L25f8de.  call `onError`(v2, v0) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L25f8e4.  return @kind void;
  #L25f8e6.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L25f8ec.  v0:= temp;
  #L25f8ee.  if v0 == 0 then goto L25f91a;
  #L25f8f2.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f8f6.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L25f8fc.  goto L25f7d8;
  #L25f900.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L25f906.  v0:= temp;
  #L25f908.  if v0 == 0 then goto L25f91a;
  #L25f90c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f910.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L25f916.  goto L25f7d8;
  #L25f91a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L25f91e.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L25f924.  v8:= temp @kind wide;
  #L25f926.  v10:= 0L;
  #L25f92a.  v12:= v10 @kind wide;
  #L25f92c.  v14:= 0I;
  #L25f92e.  v0:= lcmp(v12, v8);
  #L25f932.  if v0 == 0 then goto L25f9f6;
  #L25f936.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L25f93a.  if v0 == 0 then goto L25f940;
  #L25f93e.  return @kind void;
  #L25f940.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber.done` @type ^`boolean` @kind boolean;
  #L25f944.  call temp:= `poll`(v7) @signature `Lio/reactivex/e0/a/j;.poll:()Ljava/lang/Object;` @kind interface;
  #L25f94a.  v15:= temp @kind object;
  #L25f94c.  goto L25f96c;
  #L25f94e.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L25f950.  v15:= v0 @kind object;
  #L25f952.  call `b`(v15) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L25f958.  call `cancel`(v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L25f95e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f962.  call temp:= `addThrowable`(v0, v15) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L25f968.  v15:= v5 @kind object;
  #L25f96a.  v0:= 1I;
  #L25f96c.  if v15 != 0 then goto L25f976;
  #L25f970.  v16:= 1I;
  #L25f974.  goto L25f97a;
  #L25f976.  v16:= 0I;
  #L25f97a.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f97e.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f984.  v3:= temp @kind object;
  #L25f986.  if v6 == v3 then goto L25f98e;
  #L25f98a.  v14:= 1I;
  #L25f98c.  goto L25f9f6;
  #L25f98e.  if v0 == 0 then goto L25f9e2;
  #L25f992.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L25f996.  if v0 != 0 then goto L25f9d2;
  #L25f99a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f99e.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25f9a4.  v0:= temp @kind object;
  #L25f9a6.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L25f9aa.  if v0 == 0 then goto L25f9c2;
  #L25f9ae.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25f9b2.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L25f9b8.  v0:= temp @kind object;
  #L25f9ba.  call `onError`(v2, v0) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L25f9c0.  return @kind void;
  #L25f9c2.  if v16 == 0 then goto L25f9e2;
  #L25f9c6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f9ca.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L25f9d0.  goto L25f98a;
  #L25f9d2.  if v16 == 0 then goto L25f9e2;
  #L25f9d6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25f9da.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L25f9e0.  goto L25f98a;
  #L25f9e2.  if v16 == 0 then goto L25f9e8;
  #L25f9e6.  goto L25f9f6;
  #L25f9e8.  call `onNext`(v2, v15) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L25f9ee.  v14:= 1L;
  #L25f9f2.  v12:= v12 + v14 @kind long;
  #L25f9f4.  goto L25f92c;
  #L25f9f6.  v0:= lcmp(v12, v10);
  #L25f9fa.  if v0 == 0 then goto L25fa36;
  #L25f9fe.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L25fa02.  if v0 != 0 then goto L25fa36;
  #L25fa06.  v10:= 9223372036854775807L;
  #L25fa10.  v0:= lcmp(v8, v10);
  #L25fa14.  if v0 == 0 then goto L25fa24;
  #L25fa18.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L25fa1c.  v7:= -v12 @kind long;
  #L25fa1e.  call temp:= `addAndGet`(v0, v7) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L25fa24.  call temp:= `get`(v6) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25fa2a.  v0:= temp @kind object;
  #L25fa2c.  v0:= (`n.b.d`) v0 @kind object;
  #L25fa30.  call `request`(v0, v12) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L25fa36.  if v14 == 0 then goto L25fa3e;
  #L25fa3a.  goto L25f7d8;
  #L25fa3e.  v0:= -v4 @kind int;
  #L25fa40.  call temp:= `addAndGet`(v1, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L25fa46.  v4:= temp;
  #L25fa48.  if v4 != 0 then goto L25f7d8;
  #L25fa4c.  return @kind void;
  catch `java.lang.Throwable` @[L25f944..L25f94c] goto L25f94e;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L25fa6c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L25fa70.  if v0 == 0 then goto L25fa76;
  #L25fa74.  return @kind void;
  #L25fa76.  v0:= 1I;
  #L25fa78.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` := v0 @kind boolean;
  #L25fa7c.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @kind virtual;
  #L25fa82.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L25fa94.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L25fa98.  if v0 != 0 then goto L25fac8;
  #L25fa9c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25faa0.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L25faa6.  v0:= temp;
  #L25faa8.  if v0 == 0 then goto L25fac8;
  #L25faac.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L25fab0.  if v2 != 0 then goto L25faba;
  #L25fab4.  call `disposeInner`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L25faba.  v2:= 1I;
  #L25fabc.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` := v2 @kind boolean;
  #L25fac0.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @kind virtual;
  #L25fac6.  goto L25face;
  #L25fac8.  call `t`(v2) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L25face.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v4 @kind this, `java.lang.Object` v5 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L25fae0.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L25fae4.  if v0 == 0 then goto L25faea;
  #L25fae8.  return @kind void;
  #L25faea.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @type ^`long` @kind wide;
  #L25faee.  v2:= 1L;
  #L25faf2.  v0:= v0 + v2 @kind long;
  #L25faf4.  v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @type ^`long` := v0 @kind wide;
  #L25faf8.  v2:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25fafc.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25fb02.  v2:= temp @kind object;
  #L25fb04.  v2:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v2 @kind object;
  #L25fb08.  if v2 == 0 then goto L25fb12;
  #L25fb0c.  call `cancel`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L25fb12.  v2:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.mapper` @type ^`io.reactivex.d0.k` @kind object;
  #L25fb16.  call temp:= `apply`(v2, v5) @signature `Lio/reactivex/d0/k;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L25fb1c.  v5:= temp @kind object;
  #L25fb1e.  v2:= "The publisher returned is null" @kind object;
  #L25fb22.  call temp:= `e`(v5, v2) @signature `Lio/reactivex/internal/functions/g0;.e:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L25fb28.  v5:= temp @kind object;
  #L25fb2a.  v5:= (`n.b.b`) v5 @kind object;
  #L25fb2e.  v2:= new `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`;
  #L25fb32.  v3:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.bufferSize` @type ^`int`;
  #L25fb36.  call `<init>`(v2, v4, v0, v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;JI)V` @kind direct;
  #L25fb3c.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25fb40.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25fb46.  v0:= temp @kind object;
  #L25fb48.  v0:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v0 @kind object;
  #L25fb4c.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` @kind object;
  #L25fb50.  if v0 != v1 then goto L25fb56;
  #L25fb54.  goto L25fb6c;
  #L25fb56.  v1:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25fb5a.  call temp:= `compareAndSet`(v1, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L25fb60.  v0:= temp;
  #L25fb62.  if v0 == 0 then goto L25fb3c;
  #L25fb66.  call `subscribe`(v5, v2) @signature `Ln/b/b;.subscribe:(Ln/b/c;)V` @kind interface;
  #L25fb6c.  return @kind void;
  #L25fb6e.  v5:= Exception @type ^`java.lang.Throwable` @kind object;
  #L25fb70.  call `b`(v5) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L25fb76.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L25fb7a.  call `cancel`(v0) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L25fb80.  call `onError`(v4, v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L25fb86.  return @kind void;
  catch `java.lang.Throwable` @[L25fb12..L25fb2e] goto L25fb6e;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this, `n.b.d` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onSubscribe:(Ln/b/d;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L25fba4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L25fba8.  call temp:= `validate`(v0, v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(Ln/b/d;Ln/b/d;)Z` @kind static;
  #L25fbae.  v0:= temp;
  #L25fbb0.  if v0 == 0 then goto L25fbc2;
  #L25fbb4.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`n.b.d` := v2 @kind object;
  #L25fbb8.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L25fbbc.  call `onSubscribe`(v2, v1) @signature `Ln/b/c;.onSubscribe:(Ln/b/d;)V` @kind interface;
  #L25fbc2.  return @kind void;
}
procedure `void` `request`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v3 @kind this, `long` v4 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.request:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L25fbd4.  call temp:= `validate`(v4) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(J)Z` @kind static;
  #L25fbda.  v0:= temp;
  #L25fbdc.  if v0 == 0 then goto L25fc16;
  #L25fbe0.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L25fbe4.  call temp:= `a`(v0, v4) @signature `Lio/reactivex/internal/util/b;.a:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L25fbea.  v4:= v3.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @type ^`long` @kind wide;
  #L25fbee.  v0:= 0L;
  #L25fbf2.  v2:= lcmp(v4, v0);
  #L25fbf6.  if v2 != 0 then goto L25fc10;
  #L25fbfa.  v4:= v3.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L25fbfe.  v0:= 9223372036854775807L;
  #L25fc08.  call `request`(v4, v0) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L25fc0e.  goto L25fc16;
  #L25fc10.  call `drain`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @kind virtual;
  #L25fc16.  return @kind void;
}

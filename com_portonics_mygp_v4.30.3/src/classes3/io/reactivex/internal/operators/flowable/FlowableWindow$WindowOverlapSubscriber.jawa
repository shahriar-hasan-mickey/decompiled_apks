record `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.h` @kind interface, `n.b.d` @kind interface, `java.lang.Runnable` @kind interface {
  `int` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @AccessFlag VOLATILE;
  `n.b.c` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.downstream` @AccessFlag FINAL;
  `java.lang.Throwable` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.error` @AccessFlag ;
  `java.util.concurrent.atomic.AtomicBoolean` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.firstRequest` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.index` @AccessFlag ;
  `java.util.concurrent.atomic.AtomicBoolean` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.once` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.produced` @AccessFlag ;
  `io.reactivex.internal.queue.a` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.queue` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.requested` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.size` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.skip` @AccessFlag FINAL;
  `n.b.d` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.upstream` @AccessFlag ;
  `java.util.ArrayDeque` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicInteger` `io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.wip` @AccessFlag FINAL;
}
global `long` `@@io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v1 @kind this, `n.b.c` v2 @kind object, `long` v3 , `long` v5 , `int` v7 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.<init>:(Ln/b/c;JJI)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L26220c.  v0:= 1I;
  #L26220e.  call `<init>`(v1, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:(I)V` @kind direct;
  #L262214.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.downstream` @type ^`n.b.c` := v2 @kind object;
  #L262218.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.size` @type ^`long` := v3 @kind wide;
  #L26221c.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.skip` @type ^`long` := v5 @kind wide;
  #L262220.  v2:= new `io.reactivex.internal.queue.a`;
  #L262224.  call `<init>`(v2, v7) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L26222a.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.queue` @type ^`io.reactivex.internal.queue.a` := v2 @kind object;
  #L26222e.  v2:= new `java.util.ArrayDeque`;
  #L262232.  call `<init>`(v2) @signature `Ljava/util/ArrayDeque;.<init>:()V` @kind direct;
  #L262238.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` := v2 @kind object;
  #L26223c.  v2:= new `java.util.concurrent.atomic.AtomicBoolean`;
  #L262240.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.<init>:()V` @kind direct;
  #L262246.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.once` @type ^`java.util.concurrent.atomic.AtomicBoolean` := v2 @kind object;
  #L26224a.  v2:= new `java.util.concurrent.atomic.AtomicBoolean`;
  #L26224e.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.<init>:()V` @kind direct;
  #L262254.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.firstRequest` @type ^`java.util.concurrent.atomic.AtomicBoolean` := v2 @kind object;
  #L262258.  v2:= new `java.util.concurrent.atomic.AtomicLong`;
  #L26225c.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L262262.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` := v2 @kind object;
  #L262266.  v2:= new `java.util.concurrent.atomic.AtomicInteger`;
  #L26226a.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L262270.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.wip` @type ^`java.util.concurrent.atomic.AtomicInteger` := v2 @kind object;
  #L262274.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.bufferSize` @type ^`int` := v7;
  #L262278.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v3 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L26228c.  v0:= 1I;
  #L26228e.  v3.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L262292.  v1:= v3.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.once` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L262296.  v2:= 0I;
  #L262298.  call temp:= `compareAndSet`(v1, v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.compareAndSet:(ZZ)Z` @kind virtual;
  #L26229e.  v0:= temp;
  #L2622a0.  if v0 == 0 then goto L2622aa;
  #L2622a4.  call `run`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.run:()V` @kind virtual;
  #L2622aa.  return @kind void;
}
procedure `boolean` `checkTerminated`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v2 @kind this, `boolean` v3 , `boolean` v4 , `n.b.c` v5 @kind object, `io.reactivex.internal.queue.a` v6 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.checkTerminated:(ZZLn/b/c;Lio/reactivex/internal/queue/a;)Z` @AccessFlag  {
    temp;
    v0;
    v1;

  #L2621c0.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L2621c4.  v1:= 1I;
  #L2621c6.  if v0 == 0 then goto L2621d2;
  #L2621ca.  call `clear`(v6) @signature `Lio/reactivex/internal/queue/a;.clear:()V` @kind virtual;
  #L2621d0.  return v1;
  #L2621d2.  if v3 == 0 then goto L2621f8;
  #L2621d6.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.error` @type ^`java.lang.Throwable` @kind object;
  #L2621da.  if v3 == 0 then goto L2621ec;
  #L2621de.  call `clear`(v6) @signature `Lio/reactivex/internal/queue/a;.clear:()V` @kind virtual;
  #L2621e4.  call `onError`(v5, v3) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L2621ea.  return v1;
  #L2621ec.  if v4 == 0 then goto L2621f8;
  #L2621f0.  call `onComplete`(v5) @signature `Ln/b/c;.onComplete:()V` @kind interface;
  #L2621f6.  return v1;
  #L2621f8.  v3:= 0I;
  #L2621fa.  return v3;
}
procedure `void` `drain`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v13 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.drain:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;

  #L2622bc.  v0:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.wip` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L2622c0.  call temp:= `getAndIncrement`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L2622c6.  v0:= temp;
  #L2622c8.  if v0 == 0 then goto L2622ce;
  #L2622cc.  return @kind void;
  #L2622ce.  v0:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L2622d2.  v1:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.queue` @type ^`io.reactivex.internal.queue.a` @kind object;
  #L2622d6.  v2:= 1I;
  #L2622d8.  v3:= 1I;
  #L2622da.  v4:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L2622de.  call temp:= `get`(v4) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L2622e4.  v4:= temp @kind wide;
  #L2622e6.  v6:= 0L;
  #L2622ea.  v8:= v6 @kind wide;
  #L2622ec.  v10:= lcmp(v8, v4);
  #L2622f0.  if v10 == 0 then goto L262330;
  #L2622f4.  v10:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` @kind boolean;
  #L2622f8.  call temp:= `poll`(v1) @signature `Lio/reactivex/internal/queue/a;.poll:()Ljava/lang/Object;` @kind virtual;
  #L2622fe.  v11:= temp @kind object;
  #L262300.  v11:= (`io.reactivex.processors.UnicastProcessor`) v11 @kind object;
  #L262304.  if v11 != 0 then goto L26230c;
  #L262308.  v12:= 1I;
  #L26230a.  goto L26230e;
  #L26230c.  v12:= 0I;
  #L26230e.  call temp:= `checkTerminated`(v13, v10, v12, v0, v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.checkTerminated:(ZZLn/b/c;Lio/reactivex/internal/queue/a;)Z` @kind virtual;
  #L262314.  v10:= temp;
  #L262316.  if v10 == 0 then goto L26231c;
  #L26231a.  return @kind void;
  #L26231c.  if v12 == 0 then goto L262322;
  #L262320.  goto L262330;
  #L262322.  call `onNext`(v0, v11) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L262328.  v10:= 1L;
  #L26232c.  v8:= v8 + v10 @kind long;
  #L26232e.  goto L2622ec;
  #L262330.  v10:= lcmp(v8, v4);
  #L262334.  if v10 != 0 then goto L262352;
  #L262338.  v10:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` @kind boolean;
  #L26233c.  call temp:= `isEmpty`(v1) @signature `Lio/reactivex/internal/queue/a;.isEmpty:()Z` @kind virtual;
  #L262342.  v11:= temp;
  #L262344.  call temp:= `checkTerminated`(v13, v10, v11, v0, v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.checkTerminated:(ZZLn/b/c;Lio/reactivex/internal/queue/a;)Z` @kind virtual;
  #L26234a.  v10:= temp;
  #L26234c.  if v10 == 0 then goto L262352;
  #L262350.  return @kind void;
  #L262352.  v10:= lcmp(v8, v6);
  #L262356.  if v10 == 0 then goto L262378;
  #L26235a.  v6:= 9223372036854775807L;
  #L262364.  v10:= lcmp(v4, v6);
  #L262368.  if v10 == 0 then goto L262378;
  #L26236c.  v4:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L262370.  v5:= -v8 @kind long;
  #L262372.  call temp:= `addAndGet`(v4, v5) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L262378.  v4:= v13.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.wip` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L26237c.  v3:= -v3 @kind int;
  #L26237e.  call temp:= `addAndGet`(v4, v3) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L262384.  v3:= temp;
  #L262386.  if v3 != 0 then goto L2622da;
  #L26238a.  return @kind void;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L26239c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` @kind boolean;
  #L2623a0.  if v0 == 0 then goto L2623a6;
  #L2623a4.  return @kind void;
  #L2623a6.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L2623aa.  call temp:= `iterator`(v0) @signature `Ljava/util/ArrayDeque;.iterator:()Ljava/util/Iterator;` @kind virtual;
  #L2623b0.  v0:= temp @kind object;
  #L2623b2.  call temp:= `hasNext`(v0) @signature `Ljava/util/Iterator;.hasNext:()Z` @kind interface;
  #L2623b8.  v1:= temp;
  #L2623ba.  if v1 == 0 then goto L2623d2;
  #L2623be.  call temp:= `next`(v0) @signature `Ljava/util/Iterator;.next:()Ljava/lang/Object;` @kind interface;
  #L2623c4.  v1:= temp @kind object;
  #L2623c6.  v1:= (`n.b.a`) v1 @kind object;
  #L2623ca.  call `onComplete`(v1) @signature `Ln/b/c;.onComplete:()V` @kind interface;
  #L2623d0.  goto L2623b2;
  #L2623d2.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L2623d6.  call `clear`(v0) @signature `Ljava/util/ArrayDeque;.clear:()V` @kind virtual;
  #L2623dc.  v0:= 1I;
  #L2623de.  v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` := v0 @kind boolean;
  #L2623e2.  call `drain`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.drain:()V` @kind virtual;
  #L2623e8.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v2 @kind this, `java.lang.Throwable` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L2623fc.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` @kind boolean;
  #L262400.  if v0 == 0 then goto L26240c;
  #L262404.  call `t`(v3) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L26240a.  return @kind void;
  #L26240c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L262410.  call temp:= `iterator`(v0) @signature `Ljava/util/ArrayDeque;.iterator:()Ljava/util/Iterator;` @kind virtual;
  #L262416.  v0:= temp @kind object;
  #L262418.  call temp:= `hasNext`(v0) @signature `Ljava/util/Iterator;.hasNext:()Z` @kind interface;
  #L26241e.  v1:= temp;
  #L262420.  if v1 == 0 then goto L262438;
  #L262424.  call temp:= `next`(v0) @signature `Ljava/util/Iterator;.next:()Ljava/lang/Object;` @kind interface;
  #L26242a.  v1:= temp @kind object;
  #L26242c.  v1:= (`n.b.a`) v1 @kind object;
  #L262430.  call `onError`(v1, v3) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L262436.  goto L262418;
  #L262438.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L26243c.  call `clear`(v0) @signature `Ljava/util/ArrayDeque;.clear:()V` @kind virtual;
  #L262442.  v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.error` @type ^`java.lang.Throwable` := v3 @kind object;
  #L262446.  v3:= 1I;
  #L262448.  v2.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` := v3 @kind boolean;
  #L26244c.  call `drain`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.drain:()V` @kind virtual;
  #L262452.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v8 @kind this, `java.lang.Object` v9 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L262464.  v0:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.done` @type ^`boolean` @kind boolean;
  #L262468.  if v0 == 0 then goto L26246e;
  #L26246c.  return @kind void;
  #L26246e.  v0:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.index` @type ^`long` @kind wide;
  #L262472.  v2:= 0L;
  #L262476.  v4:= lcmp(v0, v2);
  #L26247a.  if v4 != 0 then goto L2624b2;
  #L26247e.  v4:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L262482.  if v4 != 0 then goto L2624b2;
  #L262486.  call temp:= `getAndIncrement`(v8) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L26248c.  v4:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.bufferSize` @type ^`int`;
  #L262490.  call temp:= `L`(v4, v8) @signature `Lio/reactivex/processors/UnicastProcessor;.L:(ILjava/lang/Runnable;)Lio/reactivex/processors/UnicastProcessor;` @kind static;
  #L262496.  v4:= temp @kind object;
  #L262498.  v5:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L26249c.  call temp:= `offer`(v5, v4) @signature `Ljava/util/ArrayDeque;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L2624a2.  v5:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.queue` @type ^`io.reactivex.internal.queue.a` @kind object;
  #L2624a6.  call temp:= `offer`(v5, v4) @signature `Lio/reactivex/internal/queue/a;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L2624ac.  call `drain`(v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.drain:()V` @kind virtual;
  #L2624b2.  v4:= 1L;
  #L2624b6.  v0:= v0 + v4 @kind long;
  #L2624b8.  v6:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L2624bc.  call temp:= `iterator`(v6) @signature `Ljava/util/ArrayDeque;.iterator:()Ljava/util/Iterator;` @kind virtual;
  #L2624c2.  v6:= temp @kind object;
  #L2624c4.  call temp:= `hasNext`(v6) @signature `Ljava/util/Iterator;.hasNext:()Z` @kind interface;
  #L2624ca.  v7:= temp;
  #L2624cc.  if v7 == 0 then goto L2624e4;
  #L2624d0.  call temp:= `next`(v6) @signature `Ljava/util/Iterator;.next:()Ljava/lang/Object;` @kind interface;
  #L2624d6.  v7:= temp @kind object;
  #L2624d8.  v7:= (`n.b.a`) v7 @kind object;
  #L2624dc.  call `onNext`(v7, v9) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L2624e2.  goto L2624c4;
  #L2624e4.  v6:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.produced` @type ^`long` @kind wide;
  #L2624e8.  v6:= v6 + v4 @kind long;
  #L2624ea.  v4:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.size` @type ^`long` @kind wide;
  #L2624ee.  v9:= lcmp(v6, v4);
  #L2624f2.  if v9 != 0 then goto L26251c;
  #L2624f6.  v4:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.skip` @type ^`long` @kind wide;
  #L2624fa.  v6:= v6 - v4 @kind long;
  #L2624fc.  v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.produced` @type ^`long` := v6 @kind wide;
  #L262500.  v9:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.windows` @type ^`java.util.ArrayDeque` @kind object;
  #L262504.  call temp:= `poll`(v9) @signature `Ljava/util/ArrayDeque;.poll:()Ljava/lang/Object;` @kind virtual;
  #L26250a.  v9:= temp @kind object;
  #L26250c.  v9:= (`n.b.a`) v9 @kind object;
  #L262510.  if v9 == 0 then goto L262520;
  #L262514.  call `onComplete`(v9) @signature `Ln/b/c;.onComplete:()V` @kind interface;
  #L26251a.  goto L262520;
  #L26251c.  v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.produced` @type ^`long` := v6 @kind wide;
  #L262520.  v4:= v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.skip` @type ^`long` @kind wide;
  #L262524.  v9:= lcmp(v0, v4);
  #L262528.  if v9 != 0 then goto L262532;
  #L26252c.  v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.index` @type ^`long` := v2 @kind wide;
  #L262530.  goto L262536;
  #L262532.  v8.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.index` @type ^`long` := v0 @kind wide;
  #L262536.  return @kind void;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v1 @kind this, `n.b.d` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.onSubscribe:(Ln/b/d;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L262548.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L26254c.  call temp:= `validate`(v0, v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(Ln/b/d;Ln/b/d;)Z` @kind static;
  #L262552.  v0:= temp;
  #L262554.  if v0 == 0 then goto L262566;
  #L262558.  v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.upstream` @type ^`n.b.d` := v2 @kind object;
  #L26255c.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L262560.  call `onSubscribe`(v2, v1) @signature `Ln/b/c;.onSubscribe:(Ln/b/d;)V` @kind interface;
  #L262566.  return @kind void;
}
procedure `void` `request`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v4 @kind this, `long` v5 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.request:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L262578.  call temp:= `validate`(v5) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(J)Z` @kind static;
  #L26257e.  v0:= temp;
  #L262580.  if v0 == 0 then goto L2625f8;
  #L262584.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L262588.  call temp:= `a`(v0, v5) @signature `Lio/reactivex/internal/util/b;.a:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L26258e.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.firstRequest` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L262592.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.get:()Z` @kind virtual;
  #L262598.  v0:= temp;
  #L26259a.  if v0 != 0 then goto L2625dc;
  #L26259e.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.firstRequest` @type ^`java.util.concurrent.atomic.AtomicBoolean` @kind object;
  #L2625a2.  v1:= 0I;
  #L2625a4.  v2:= 1I;
  #L2625a6.  call temp:= `compareAndSet`(v0, v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.compareAndSet:(ZZ)Z` @kind virtual;
  #L2625ac.  v0:= temp;
  #L2625ae.  if v0 == 0 then goto L2625dc;
  #L2625b2.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.skip` @type ^`long` @kind wide;
  #L2625b6.  v2:= 1L;
  #L2625ba.  v5:= v5 - v2 @kind long;
  #L2625bc.  call temp:= `d`(v0, v5) @signature `Lio/reactivex/internal/util/b;.d:(JJ)J` @kind static;
  #L2625c2.  v5:= temp @kind wide;
  #L2625c4.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.size` @type ^`long` @kind wide;
  #L2625c8.  call temp:= `c`(v0, v5) @signature `Lio/reactivex/internal/util/b;.c:(JJ)J` @kind static;
  #L2625ce.  v5:= temp @kind wide;
  #L2625d0.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L2625d4.  call `request`(v0, v5) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L2625da.  goto L2625f2;
  #L2625dc.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.skip` @type ^`long` @kind wide;
  #L2625e0.  call temp:= `d`(v0, v5) @signature `Lio/reactivex/internal/util/b;.d:(JJ)J` @kind static;
  #L2625e6.  v5:= temp @kind wide;
  #L2625e8.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L2625ec.  call `request`(v0, v5) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L2625f2.  call `drain`(v4) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.drain:()V` @kind virtual;
  #L2625f8.  return @kind void;
}
procedure `void` `run`(`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableWindow$WindowOverlapSubscriber;.run:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L26260c.  call temp:= `decrementAndGet`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L262612.  v0:= temp;
  #L262614.  if v0 != 0 then goto L262622;
  #L262618.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableWindow$WindowOverlapSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L26261c.  call `cancel`(v0) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L262622.  return @kind void;
}

record `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.h` @kind interface, `n.b.d` @kind interface {
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @AccessFlag VOLATILE;
  `n.b.c` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @AccessFlag ;
  `io.reactivex.d0.k` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.mapper` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @AccessFlag FINAL;
  `io.reactivex.e0.a.i` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @AccessFlag VOLATILE;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.uniqueId` @AccessFlag ;
  `n.b.d` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @AccessFlag ;
}
global `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.CANCELLED` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.EMPTY` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L25273c.  v0:= 0I;
  #L25273e.  v1:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v0];
  #L252742.  `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.EMPTY` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] := v1 @kind object;
  #L252746.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v0];
  #L25274a.  `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] := v0 @kind object;
  #L25274e.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `n.b.c` v3 @kind object, `io.reactivex.d0.k` v4 @kind object, `boolean` v5 , `int` v6 , `int` v7 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.<init>:(Ln/b/c;Lio/reactivex/d0/k;ZII)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L252760.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L252766.  v0:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L25276a.  call `<init>`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L252770.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` := v0 @kind object;
  #L252774.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L252778.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L25277e.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L252782.  v1:= new `java.util.concurrent.atomic.AtomicLong`;
  #L252786.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L25278c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` := v1 @kind object;
  #L252790.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @type ^`n.b.c` := v3 @kind object;
  #L252794.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.mapper` @type ^`io.reactivex.d0.k` := v4 @kind object;
  #L252798.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` := v5 @kind boolean;
  #L25279c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int` := v6;
  #L2527a0.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int` := v7;
  #L2527a4.  v3:= 1I;
  #L2527a6.  v4:= v6 ^> 1;
  #L2527aa.  call temp:= `max`(v3, v4) @signature `Ljava/lang/Math;.max:(II)I` @kind static;
  #L2527b0.  v3:= temp;
  #L2527b2.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @type ^`int` := v3;
  #L2527b6.  v3:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.EMPTY` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L2527ba.  call `lazySet`(v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L2527c0.  return @kind void;
}
procedure `boolean` `addInner`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v4 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v5 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.addInner:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L252604.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L252608.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25260e.  v0:= temp @kind object;
  #L252610.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L252614.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L252618.  v2:= 0I;
  #L25261a.  if v0 != v1 then goto L252626;
  #L25261e.  call `dispose`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.dispose:()V` @kind virtual;
  #L252624.  return v2;
  #L252626.  v1:= length @variable v0;
  #L252628.  v3:= v1 + 1;
  #L25262c.  v3:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v3];
  #L252630.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L252636.  v3[v1]:= v5 @kind object;
  #L25263a.  v1:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25263e.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L252644.  v0:= temp;
  #L252646.  if v0 == 0 then goto L252604;
  #L25264a.  v5:= 1I;
  #L25264c.  return v5;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L2527d4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L2527d8.  if v0 != 0 then goto L25280c;
  #L2527dc.  v0:= 1I;
  #L2527de.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L2527e2.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L2527e6.  call `cancel`(v0) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L2527ec.  call `disposeAll`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.disposeAll:()V` @kind virtual;
  #L2527f2.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L2527f8.  v0:= temp;
  #L2527fa.  if v0 != 0 then goto L25280c;
  #L2527fe.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L252802.  if v0 == 0 then goto L25280c;
  #L252806.  call `clear`(v0) @signature `Lio/reactivex/e0/a/j;.clear:()V` @kind interface;
  #L25280c.  return @kind void;
}
procedure `boolean` `checkTerminate`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v3 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L252660.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L252664.  v1:= 1I;
  #L252666.  if v0 == 0 then goto L252672;
  #L25266a.  call `clearScalarQueue`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.clearScalarQueue:()V` @kind virtual;
  #L252670.  return v1;
  #L252672.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L252676.  if v0 != 0 then goto L2526b0;
  #L25267a.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L25267e.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L252684.  v0:= temp @kind object;
  #L252686.  if v0 == 0 then goto L2526b0;
  #L25268a.  call `clearScalarQueue`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.clearScalarQueue:()V` @kind virtual;
  #L252690.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L252694.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L25269a.  v0:= temp @kind object;
  #L25269c.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L2526a0.  if v0 == v2 then goto L2526ae;
  #L2526a4.  v2:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L2526a8.  call `onError`(v2, v0) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L2526ae.  return v1;
  #L2526b0.  v0:= 0I;
  #L2526b2.  return v0;
}
procedure `void` `clearScalarQueue`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.clearScalarQueue:()V` @AccessFlag  {
    temp;
    v0;

  #L252820.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L252824.  if v0 == 0 then goto L25282e;
  #L252828.  call `clear`(v0) @signature `Lio/reactivex/e0/a/j;.clear:()V` @kind interface;
  #L25282e.  return @kind void;
}
procedure `void` `disposeAll`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v4 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.disposeAll:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L252840.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L252844.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L25284a.  v0:= temp @kind object;
  #L25284c.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L252850.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L252854.  if v0 == v1 then goto L2528a2;
  #L252858.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L25285c.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L252862.  v0:= temp @kind object;
  #L252864.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L252868.  if v0 == v1 then goto L2528a2;
  #L25286c.  v1:= length @variable v0;
  #L25286e.  v2:= 0I;
  #L252870.  if v2 >= v1 then goto L252884;
  #L252874.  v3:= v0[v2] @kind object;
  #L252878.  call `dispose`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.dispose:()V` @kind virtual;
  #L25287e.  v2:= v2 + 1;
  #L252882.  goto L252870;
  #L252884.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L252888.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L25288e.  v0:= temp @kind object;
  #L252890.  if v0 == 0 then goto L2528a2;
  #L252894.  v1:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L252898.  if v0 == v1 then goto L2528a2;
  #L25289c.  call `t`(v0) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L2528a2.  return @kind void;
}
procedure `void` `drain`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drain:()V` @AccessFlag  {
    temp;
    v0;

  #L2528b4.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L2528ba.  v0:= temp;
  #L2528bc.  if v0 != 0 then goto L2528c6;
  #L2528c0.  call `drainLoop`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drainLoop:()V` @kind virtual;
  #L2528c6.  return @kind void;
}
procedure `void` `drainLoop`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v24 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drainLoop:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;
    v23;

  #L2528d8.  v1:= v24 @kind object;
  #L2528dc.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L2528e0.  v4:= 1I;
  #L2528e2.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L2528e8.  v0:= temp;
  #L2528ea.  if v0 == 0 then goto L2528f0;
  #L2528ee.  return @kind void;
  #L2528f0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L2528f4.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L2528f8.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L2528fe.  v5:= temp @kind wide;
  #L252900.  v7:= 9223372036854775807L;
  #L25290a.  v10:= lcmp(v5, v7);
  #L25290e.  if v10 != 0 then goto L252916;
  #L252912.  v10:= 1I;
  #L252914.  goto L252918;
  #L252916.  v10:= 0I;
  #L252918.  v12:= 1L;
  #L25291c.  v14:= 0L;
  #L252920.  v16:= v14 @kind wide;
  #L252924.  if v0 == 0 then goto L2529aa;
  #L252928.  v7:= v14 @kind wide;
  #L25292a.  v18:= 0I;
  #L25292e.  v19:= lcmp(v5, v14);
  #L252932.  if v19 == 0 then goto L25296a;
  #L252936.  call temp:= `poll`(v0) @signature `Lio/reactivex/e0/a/i;.poll:()Ljava/lang/Object;` @kind interface;
  #L25293c.  v9:= temp @kind object;
  #L25293e.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L252944.  v18:= temp;
  #L252946.  if v18 == 0 then goto L25294c;
  #L25294a.  return @kind void;
  #L25294c.  if v9 != 0 then goto L252956;
  #L252950.  v18:= v9 @kind object;
  #L252954.  goto L25296a;
  #L252956.  call `onNext`(v2, v9) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L25295c.  v16:= v16 + v12 @kind long;
  #L252960.  v7:= v7 + v12 @kind long;
  #L252962.  v5:= v5 - v12 @kind long;
  #L252964.  v18:= v9 @kind object;
  #L252968.  goto L25292e;
  #L25296a.  v9:= lcmp(v7, v14);
  #L25296e.  if v9 == 0 then goto L252990;
  #L252972.  if v10 == 0 then goto L252982;
  #L252976.  v5:= 9223372036854775807L;
  #L252980.  goto L252990;
  #L252982.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L252986.  v6:= -v7 @kind long;
  #L252988.  call temp:= `addAndGet`(v5, v6) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L25298e.  v5:= temp @kind wide;
  #L252990.  v7:= lcmp(v5, v14);
  #L252994.  if v7 == 0 then goto L2529aa;
  #L252998.  if v18 != 0 then goto L25299e;
  #L25299c.  goto L2529aa;
  #L25299e.  v7:= 9223372036854775807L;
  #L2529a8.  goto L252928;
  #L2529aa.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L2529ae.  v7:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L2529b2.  v8:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L2529b6.  call temp:= `get`(v8) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L2529bc.  v8:= temp @kind object;
  #L2529be.  v8:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v8 @kind object;
  #L2529c2.  v9:= length @variable v8;
  #L2529c4.  if v0 == 0 then goto L252a04;
  #L2529c8.  if v7 == 0 then goto L2529d8;
  #L2529cc.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L2529d2.  v0:= temp;
  #L2529d4.  if v0 == 0 then goto L252a04;
  #L2529d8.  if v9 != 0 then goto L252a04;
  #L2529dc.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L2529e0.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L2529e6.  v0:= temp @kind object;
  #L2529e8.  v3:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L2529ec.  if v0 == v3 then goto L252a02;
  #L2529f0.  if v0 != 0 then goto L2529fc;
  #L2529f4.  call `onComplete`(v2) @signature `Ln/b/c;.onComplete:()V` @kind interface;
  #L2529fa.  goto L252a02;
  #L2529fc.  call `onError`(v2, v0) @signature `Ln/b/c;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L252a02.  return @kind void;
  #L252a04.  v18:= v4;
  #L252a08.  if v9 == 0 then goto L252c10;
  #L252a0c.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @type ^`long` @kind wide;
  #L252a10.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @type ^`int`;
  #L252a14.  if v9 <= v0 then goto L252a28;
  #L252a18.  v7:= v8[v0] @kind object;
  #L252a1c.  v11:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L252a20.  v7:= lcmp(v11, v3);
  #L252a24.  if v7 == 0 then goto L252a66;
  #L252a28.  if v9 > v0 then goto L252a2e;
  #L252a2c.  v0:= 0I;
  #L252a2e.  v7:= 0I;
  #L252a30.  if v7 >= v9 then goto L252a56;
  #L252a34.  v11:= v8[v0] @kind object;
  #L252a38.  v11:= v11.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L252a3c.  v13:= lcmp(v11, v3);
  #L252a40.  if v13 != 0 then goto L252a46;
  #L252a44.  goto L252a56;
  #L252a46.  v0:= v0 + 1;
  #L252a4a.  if v0 != v9 then goto L252a50;
  #L252a4e.  v0:= 0I;
  #L252a50.  v7:= v7 + 1;
  #L252a54.  goto L252a30;
  #L252a56.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @type ^`int` := v0;
  #L252a5a.  v3:= v8[v0] @kind object;
  #L252a5e.  v3:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L252a62.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @type ^`long` := v3 @kind wide;
  #L252a66.  v3:= v0;
  #L252a68.  v0:= 0I;
  #L252a6a.  v4:= 0I;
  #L252a6c.  if v4 >= v9 then goto L252bf0;
  #L252a70.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L252a76.  v7:= temp;
  #L252a78.  if v7 == 0 then goto L252a7e;
  #L252a7c.  return @kind void;
  #L252a7e.  v7:= v8[v3] @kind object;
  #L252a82.  v11:= 0I;
  #L252a84.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L252a8a.  v12:= temp;
  #L252a8c.  if v12 == 0 then goto L252a92;
  #L252a90.  return @kind void;
  #L252a92.  v12:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L252a96.  if v12 != 0 then goto L252aa4;
  #L252a9a.  v13:= v8 @kind object;
  #L252a9c.  v22:= v9;
  #L252aa0.  goto L252b82;
  #L252aa4.  v13:= v8 @kind object;
  #L252aa6.  v22:= v9;
  #L252aaa.  v8:= v14 @kind wide;
  #L252aac.  v23:= lcmp(v5, v14);
  #L252ab0.  if v23 == 0 then goto L252b34;
  #L252ab4.  call temp:= `poll`(v12) @signature `Lio/reactivex/e0/a/j;.poll:()Ljava/lang/Object;` @kind interface;
  #L252aba.  v11:= temp @kind object;
  #L252abc.  if v11 != 0 then goto L252ac2;
  #L252ac0.  goto L252b34;
  #L252ac2.  call `onNext`(v2, v11) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L252ac8.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L252ace.  v23:= temp;
  #L252ad0.  if v23 == 0 then goto L252ad6;
  #L252ad4.  return @kind void;
  #L252ad6.  v20:= 1L;
  #L252ada.  v5:= v5 - v20 @kind long;
  #L252ade.  v8:= v8 + v20 @kind long;
  #L252ae2.  goto L252aac;
  #L252ae4.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L252ae6.  v8:= v0 @kind object;
  #L252ae8.  call `b`(v8) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L252aee.  call `dispose`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.dispose:()V` @kind virtual;
  #L252af4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L252af8.  call temp:= `addThrowable`(v0, v8) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L252afe.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L252b02.  if v0 != 0 then goto L252b10;
  #L252b06.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L252b0a.  call `cancel`(v0) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L252b10.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L252b16.  v0:= temp;
  #L252b18.  if v0 == 0 then goto L252b1e;
  #L252b1c.  return @kind void;
  #L252b1e.  call `removeInner`(v1, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.removeInner:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @kind virtual;
  #L252b24.  v4:= v4 + 1;
  #L252b28.  v9:= v22;
  #L252b2c.  v0:= 1I;
  #L252b2e.  v7:= 1L;
  #L252b32.  goto L252be2;
  #L252b34.  v12:= lcmp(v8, v14);
  #L252b38.  if v12 == 0 then goto L252b66;
  #L252b3c.  if v10 != 0 then goto L252b50;
  #L252b40.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L252b44.  v14:= -v8 @kind long;
  #L252b46.  call temp:= `addAndGet`(v5, v14) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L252b4c.  v5:= temp @kind wide;
  #L252b4e.  goto L252b5a;
  #L252b50.  v5:= 9223372036854775807L;
  #L252b5a.  call `requestMore`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.requestMore:(J)V` @kind virtual;
  #L252b60.  v8:= 0L;
  #L252b64.  goto L252b68;
  #L252b66.  v8:= v14 @kind wide;
  #L252b68.  v12:= lcmp(v5, v8);
  #L252b6c.  if v12 == 0 then goto L252b82;
  #L252b70.  if v11 != 0 then goto L252b76;
  #L252b74.  goto L252b82;
  #L252b76.  v8:= v13 @kind object;
  #L252b78.  v9:= v22;
  #L252b7c.  v14:= 0L;
  #L252b80.  goto L252a84;
  #L252b82.  v8:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.done` @type ^`boolean` @kind boolean;
  #L252b86.  v9:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L252b8a.  if v8 == 0 then goto L252bbe;
  #L252b8e.  if v9 == 0 then goto L252b9e;
  #L252b92.  call temp:= `isEmpty`(v9) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L252b98.  v8:= temp;
  #L252b9a.  if v8 == 0 then goto L252bbe;
  #L252b9e.  call `removeInner`(v1, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.removeInner:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @kind virtual;
  #L252ba4.  call temp:= `checkTerminate`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.checkTerminate:()Z` @kind virtual;
  #L252baa.  v0:= temp;
  #L252bac.  if v0 == 0 then goto L252bb2;
  #L252bb0.  return @kind void;
  #L252bb2.  v7:= 1L;
  #L252bb6.  v16:= v16 + v7 @kind long;
  #L252bba.  v0:= 1I;
  #L252bbc.  goto L252bc2;
  #L252bbe.  v7:= 1L;
  #L252bc2.  v11:= 0L;
  #L252bc6.  v9:= lcmp(v5, v11);
  #L252bca.  if v9 != 0 then goto L252bd4;
  #L252bce.  v9:= v0;
  #L252bd0.  v11:= 1I;
  #L252bd2.  goto L252bf6;
  #L252bd4.  v3:= v3 + 1;
  #L252bd8.  v9:= v22;
  #L252bdc.  if v3 != v9 then goto L252be2;
  #L252be0.  v3:= 0I;
  #L252be2.  v11:= 1I;
  #L252be4.  v4:= v4 + v11 @kind int;
  #L252be6.  v8:= v13 @kind object;
  #L252be8.  v14:= 0L;
  #L252bec.  goto L252a6c;
  #L252bf0.  v13:= v8 @kind object;
  #L252bf2.  v11:= 1I;
  #L252bf4.  v9:= v0;
  #L252bf6.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @type ^`int` := v3;
  #L252bfa.  v0:= v13[v3] @kind object;
  #L252bfe.  v3:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L252c02.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @type ^`long` := v3 @kind wide;
  #L252c06.  v3:= v16 @kind wide;
  #L252c0a.  v5:= 0L;
  #L252c0e.  goto L252c1a;
  #L252c10.  v11:= 1I;
  #L252c12.  v5:= v14 @kind wide;
  #L252c14.  v3:= v16 @kind wide;
  #L252c18.  v9:= 0I;
  #L252c1a.  v0:= lcmp(v3, v5);
  #L252c1e.  if v0 == 0 then goto L252c34;
  #L252c22.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L252c26.  if v0 != 0 then goto L252c34;
  #L252c2a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L252c2e.  call `request`(v0, v3) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L252c34.  if v9 == 0 then goto L252c40;
  #L252c38.  v4:= v18;
  #L252c3c.  goto L2528e2;
  #L252c40.  v3:= v18;
  #L252c44.  v0:= -v3 @kind int;
  #L252c46.  call temp:= `addAndGet`(v1, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L252c4c.  v4:= temp;
  #L252c4e.  if v4 != 0 then goto L2528e2;
  #L252c52.  return @kind void;
  catch `java.lang.Throwable` @[L252ab4..L252abc] goto L252ae4;
}
procedure `io.reactivex.e0.a.j` `getInnerQueue`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.getInnerQueue:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Lio/reactivex/e0/a/j;` @AccessFlag  {
    temp;
    v0;
    v1;

  #L2526c4.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L2526c8.  if v0 != 0 then goto L2526de;
  #L2526cc.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L2526d0.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int`;
  #L2526d4.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L2526da.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` := v0 @kind object;
  #L2526de.  return v0 @kind object;
}
procedure `io.reactivex.e0.a.j` `getMainQueue`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.getMainQueue:()Lio/reactivex/e0/a/j;` @AccessFlag  {
    temp;
    v0;
    v1;

  #L2526f0.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L2526f4.  if v0 != 0 then goto L252728;
  #L2526f8.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L2526fc.  v1:= 2147483647I;
  #L252702.  if v0 != v1 then goto L252716;
  #L252706.  v0:= new `io.reactivex.internal.queue.a`;
  #L25270a.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int`;
  #L25270e.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L252714.  goto L252724;
  #L252716.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L25271a.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L25271e.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L252724.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` := v0 @kind object;
  #L252728.  return v0 @kind object;
}
procedure `void` `innerError`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v3 @kind object, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.innerError:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;Ljava/lang/Throwable;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L252c70.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L252c74.  call temp:= `addThrowable`(v0, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L252c7a.  v0:= temp;
  #L252c7c.  if v0 == 0 then goto L252ccc;
  #L252c80.  v4:= 1I;
  #L252c82.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.done` @type ^`boolean` := v4 @kind boolean;
  #L252c86.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L252c8a.  if v3 != 0 then goto L252cc4;
  #L252c8e.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L252c92.  call `cancel`(v3) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L252c98.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L252c9c.  v4:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L252ca0.  call temp:= `getAndSet`(v3, v4) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L252ca6.  v3:= temp @kind object;
  #L252ca8.  v3:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v3 @kind object;
  #L252cac.  v4:= length @variable v3;
  #L252cae.  v0:= 0I;
  #L252cb0.  if v0 >= v4 then goto L252cc4;
  #L252cb4.  v1:= v3[v0] @kind object;
  #L252cb8.  call `dispose`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.dispose:()V` @kind virtual;
  #L252cbe.  v0:= v0 + 1;
  #L252cc2.  goto L252cb0;
  #L252cc4.  call `drain`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drain:()V` @kind virtual;
  #L252cca.  goto L252cd2;
  #L252ccc.  call `t`(v4) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L252cd2.  return @kind void;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L252ce4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L252ce8.  if v0 == 0 then goto L252cee;
  #L252cec.  return @kind void;
  #L252cee.  v0:= 1I;
  #L252cf0.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` := v0 @kind boolean;
  #L252cf4.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drain:()V` @kind virtual;
  #L252cfa.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L252d0c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L252d10.  if v0 == 0 then goto L252d1c;
  #L252d14.  call `t`(v2) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L252d1a.  return @kind void;
  #L252d1c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L252d20.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L252d26.  v0:= temp;
  #L252d28.  if v0 == 0 then goto L252d3a;
  #L252d2c.  v2:= 1I;
  #L252d2e.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` := v2 @kind boolean;
  #L252d32.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drain:()V` @kind virtual;
  #L252d38.  goto L252d40;
  #L252d3a.  call `t`(v2) @signature `Lio/reactivex/g0/a;.t:(Ljava/lang/Throwable;)V` @kind static;
  #L252d40.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v5 @kind this, `java.lang.Object` v6 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L252d54.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L252d58.  if v0 == 0 then goto L252d5e;
  #L252d5c.  return @kind void;
  #L252d5e.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.mapper` @type ^`io.reactivex.d0.k` @kind object;
  #L252d62.  call temp:= `apply`(v0, v6) @signature `Lio/reactivex/d0/k;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L252d68.  v6:= temp @kind object;
  #L252d6a.  v0:= "The mapper returned a null Publisher" @kind object;
  #L252d6e.  call temp:= `e`(v6, v0) @signature `Lio/reactivex/internal/functions/g0;.e:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L252d74.  v6:= temp @kind object;
  #L252d76.  v6:= (`n.b.b`) v6 @kind object;
  #L252d7a.  v0:= instanceof @variable v6 @type ^`java.util.concurrent.Callable` @kind boolean;
  #L252d7e.  if v0 == 0 then goto L252df2;
  #L252d82.  v6:= (`java.util.concurrent.Callable`) v6 @kind object;
  #L252d86.  call temp:= `call`(v6) @signature `Ljava/util/concurrent/Callable;.call:()Ljava/lang/Object;` @kind interface;
  #L252d8c.  v6:= temp @kind object;
  #L252d8e.  if v6 == 0 then goto L252d9a;
  #L252d92.  call `tryEmitScalar`(v5, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.tryEmitScalar:(Ljava/lang/Object;)V` @kind virtual;
  #L252d98.  goto L252e1c;
  #L252d9a.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L252d9e.  v0:= 2147483647I;
  #L252da4.  if v6 == v0 then goto L252e1c;
  #L252da8.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L252dac.  if v6 != 0 then goto L252e1c;
  #L252db0.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int`;
  #L252db4.  v6:= v6 + 1;
  #L252db8.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v6;
  #L252dbc.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @type ^`int`;
  #L252dc0.  if v6 != v0 then goto L252e1c;
  #L252dc4.  v6:= 0I;
  #L252dc6.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v6;
  #L252dca.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L252dce.  v0:= (`long`) v0 @kind i2l;
  #L252dd0.  call `request`(v6, v0) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L252dd6.  goto L252e1c;
  #L252dd8.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L252dda.  call `b`(v6) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L252de0.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L252de4.  call temp:= `addThrowable`(v0, v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L252dea.  call `drain`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drain:()V` @kind virtual;
  #L252df0.  return @kind void;
  #L252df2.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`;
  #L252df6.  v1:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.uniqueId` @type ^`long` @kind wide;
  #L252dfa.  v3:= 1L;
  #L252dfe.  v3:= v3 + v1 @kind long;
  #L252e00.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.uniqueId` @type ^`long` := v3 @kind wide;
  #L252e04.  call `<init>`(v0, v5, v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;J)V` @kind direct;
  #L252e0a.  call temp:= `addInner`(v5, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.addInner:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Z` @kind virtual;
  #L252e10.  v1:= temp;
  #L252e12.  if v1 == 0 then goto L252e1c;
  #L252e16.  call `subscribe`(v6, v0) @signature `Ln/b/b;.subscribe:(Ln/b/c;)V` @kind interface;
  #L252e1c.  return @kind void;
  #L252e1e.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L252e20.  call `b`(v6) @signature `Lio/reactivex/exceptions/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L252e26.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L252e2a.  call `cancel`(v0) @signature `Ln/b/d;.cancel:()V` @kind interface;
  #L252e30.  call `onError`(v5, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L252e36.  return @kind void;
  catch `java.lang.Throwable` @[L252d5e..L252d7a] goto L252e1e;
  catch `java.lang.Throwable` @[L252d82..L252d8e] goto L252dd8;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `n.b.d` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onSubscribe:(Ln/b/d;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L252e60.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L252e64.  call temp:= `validate`(v0, v3) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(Ln/b/d;Ln/b/d;)Z` @kind static;
  #L252e6a.  v0:= temp;
  #L252e6c.  if v0 == 0 then goto L252eae;
  #L252e70.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` := v3 @kind object;
  #L252e74.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L252e78.  call `onSubscribe`(v0, v2) @signature `Ln/b/c;.onSubscribe:(Ln/b/d;)V` @kind interface;
  #L252e7e.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L252e82.  if v0 != 0 then goto L252eae;
  #L252e86.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L252e8a.  v1:= 2147483647I;
  #L252e90.  if v0 != v1 then goto L252ea6;
  #L252e94.  v0:= 9223372036854775807L;
  #L252e9e.  call `request`(v3, v0) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L252ea4.  goto L252eae;
  #L252ea6.  v0:= (`long`) v0 @kind i2l;
  #L252ea8.  call `request`(v3, v0) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L252eae.  return @kind void;
}
procedure `void` `removeInner`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v6 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v7 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.removeInner:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L252ec0.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L252ec4.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L252eca.  v0:= temp @kind object;
  #L252ecc.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L252ed0.  v1:= length @variable v0;
  #L252ed2.  if v1 != 0 then goto L252ed8;
  #L252ed6.  return @kind void;
  #L252ed8.  v2:= -1I;
  #L252eda.  v3:= 0I;
  #L252edc.  v4:= 0I;
  #L252ede.  if v4 >= v1 then goto L252ef4;
  #L252ee2.  v5:= v0[v4] @kind object;
  #L252ee6.  if v5 != v7 then goto L252eee;
  #L252eea.  v2:= v4;
  #L252eec.  goto L252ef4;
  #L252eee.  v4:= v4 + 1;
  #L252ef2.  goto L252ede;
  #L252ef4.  if v2 >= 0 then goto L252efa;
  #L252ef8.  return @kind void;
  #L252efa.  v4:= 1I;
  #L252efc.  if v1 != v4 then goto L252f06;
  #L252f00.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.EMPTY` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L252f04.  goto L252f24;
  #L252f06.  v5:= v1 + -1;
  #L252f0a.  v5:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v5];
  #L252f0e.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L252f14.  v3:= v2 + 1;
  #L252f18.  v1:= v1 - v2 @kind int;
  #L252f1a.  v1:= v1 - v4 @kind int;
  #L252f1c.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L252f22.  v1:= v5 @kind object;
  #L252f24.  v2:= v6.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L252f28.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L252f2e.  v0:= temp;
  #L252f30.  if v0 == 0 then goto L252ec0;
  #L252f34.  return @kind void;
}
procedure `void` `request`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this, `long` v2 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.request:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L252f48.  call temp:= `validate`(v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(J)Z` @kind static;
  #L252f4e.  v0:= temp;
  #L252f50.  if v0 == 0 then goto L252f64;
  #L252f54.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L252f58.  call temp:= `a`(v0, v2) @signature `Lio/reactivex/internal/util/b;.a:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L252f5e.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drain:()V` @kind virtual;
  #L252f64.  return @kind void;
}
procedure `void` `tryEmit`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v7 @kind this, `java.lang.Object` v8 @kind object, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v9 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.tryEmit:(Ljava/lang/Object;Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L252f78.  call temp:= `get`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L252f7e.  v0:= temp;
  #L252f80.  v1:= "Inner queue full?!" @kind object;
  #L252f84.  if v0 != 0 then goto L25302e;
  #L252f88.  v0:= 0I;
  #L252f8a.  v2:= 1I;
  #L252f8c.  call temp:= `compareAndSet`(v7, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L252f92.  v0:= temp;
  #L252f94.  if v0 == 0 then goto L25302e;
  #L252f98.  v0:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L252f9c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L252fa2.  v2:= temp @kind wide;
  #L252fa4.  v0:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L252fa8.  v4:= 0L;
  #L252fac.  v6:= lcmp(v2, v4);
  #L252fb0.  if v6 == 0 then goto L252ff6;
  #L252fb4.  if v0 == 0 then goto L252fc4;
  #L252fb8.  call temp:= `isEmpty`(v0) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L252fbe.  v4:= temp;
  #L252fc0.  if v4 == 0 then goto L252ff6;
  #L252fc4.  v0:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L252fc8.  call `onNext`(v0, v8) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L252fce.  v0:= 9223372036854775807L;
  #L252fd8.  v8:= lcmp(v2, v0);
  #L252fdc.  if v8 == 0 then goto L252fea;
  #L252fe0.  v8:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L252fe4.  call temp:= `decrementAndGet`(v8) @signature `Ljava/util/concurrent/atomic/AtomicLong;.decrementAndGet:()J` @kind virtual;
  #L252fea.  v0:= 1L;
  #L252fee.  call `requestMore`(v9, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.requestMore:(J)V` @kind virtual;
  #L252ff4.  goto L253020;
  #L252ff6.  if v0 != 0 then goto L253002;
  #L252ffa.  call temp:= `getInnerQueue`(v7, v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.getInnerQueue:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Lio/reactivex/e0/a/j;` @kind virtual;
  #L253000.  v0:= temp @kind object;
  #L253002.  call temp:= `offer`(v0, v8) @signature `Lio/reactivex/e0/a/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L253008.  v8:= temp;
  #L25300a.  if v8 != 0 then goto L253020;
  #L25300e.  v8:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L253012.  call `<init>`(v8, v1) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L253018.  call `onError`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L25301e.  return @kind void;
  #L253020.  call temp:= `decrementAndGet`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L253026.  v8:= temp;
  #L253028.  if v8 != 0 then goto L253074;
  #L25302c.  return @kind void;
  #L25302e.  v0:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` @kind object;
  #L253032.  if v0 != 0 then goto L253048;
  #L253036.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L25303a.  v2:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int`;
  #L25303e.  call `<init>`(v0, v2) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L253044.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`io.reactivex.e0.a.j` := v0 @kind object;
  #L253048.  call temp:= `offer`(v0, v8) @signature `Lio/reactivex/e0/a/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L25304e.  v8:= temp;
  #L253050.  if v8 != 0 then goto L253066;
  #L253054.  v8:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L253058.  call `<init>`(v8, v1) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L25305e.  call `onError`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L253064.  return @kind void;
  #L253066.  call temp:= `getAndIncrement`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L25306c.  v8:= temp;
  #L25306e.  if v8 == 0 then goto L253074;
  #L253072.  return @kind void;
  #L253074.  call `drainLoop`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drainLoop:()V` @kind virtual;
  #L25307a.  return @kind void;
}
procedure `void` `tryEmitScalar`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v9 @kind this, `java.lang.Object` v10 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.tryEmitScalar:(Ljava/lang/Object;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L25308c.  call temp:= `get`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L253092.  v0:= temp;
  #L253094.  v1:= "Scalar queue full?!" @kind object;
  #L253098.  if v0 != 0 then goto L253170;
  #L25309c.  v0:= 0I;
  #L25309e.  v2:= 1I;
  #L2530a0.  call temp:= `compareAndSet`(v9, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L2530a6.  v3:= temp;
  #L2530a8.  if v3 == 0 then goto L253170;
  #L2530ac.  v3:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L2530b0.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L2530b6.  v3:= temp @kind wide;
  #L2530b8.  v5:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`io.reactivex.e0.a.i` @kind object;
  #L2530bc.  v6:= 0L;
  #L2530c0.  v8:= lcmp(v3, v6);
  #L2530c4.  if v8 == 0 then goto L253138;
  #L2530c8.  if v5 == 0 then goto L2530d8;
  #L2530cc.  call temp:= `isEmpty`(v5) @signature `Lio/reactivex/e0/a/j;.isEmpty:()Z` @kind interface;
  #L2530d2.  v6:= temp;
  #L2530d4.  if v6 == 0 then goto L253138;
  #L2530d8.  v1:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.downstream` @type ^`n.b.c` @kind object;
  #L2530dc.  call `onNext`(v1, v10) @signature `Ln/b/c;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L2530e2.  v5:= 9223372036854775807L;
  #L2530ec.  v10:= lcmp(v3, v5);
  #L2530f0.  if v10 == 0 then goto L2530fe;
  #L2530f4.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L2530f8.  call temp:= `decrementAndGet`(v10) @signature `Ljava/util/concurrent/atomic/AtomicLong;.decrementAndGet:()J` @kind virtual;
  #L2530fe.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L253102.  v1:= 2147483647I;
  #L253108.  if v10 == v1 then goto L253162;
  #L25310c.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L253110.  if v10 != 0 then goto L253162;
  #L253114.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int`;
  #L253118.  v10:= v10 + v2 @kind int;
  #L25311a.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v10;
  #L25311e.  v1:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @type ^`int`;
  #L253122.  if v10 != v1 then goto L253162;
  #L253126.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v0;
  #L25312a.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`n.b.d` @kind object;
  #L25312e.  v0:= (`long`) v1 @kind i2l;
  #L253130.  call `request`(v10, v0) @signature `Ln/b/d;.request:(J)V` @kind interface;
  #L253136.  goto L253162;
  #L253138.  if v5 != 0 then goto L253144;
  #L25313c.  call temp:= `getMainQueue`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.getMainQueue:()Lio/reactivex/e0/a/j;` @kind virtual;
  #L253142.  v5:= temp @kind object;
  #L253144.  call temp:= `offer`(v5, v10) @signature `Lio/reactivex/e0/a/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L25314a.  v10:= temp;
  #L25314c.  if v10 != 0 then goto L253162;
  #L253150.  v10:= new `java.lang.IllegalStateException`;
  #L253154.  call `<init>`(v10, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L25315a.  call `onError`(v9, v10) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L253160.  return @kind void;
  #L253162.  call temp:= `decrementAndGet`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L253168.  v10:= temp;
  #L25316a.  if v10 != 0 then goto L2531a4;
  #L25316e.  return @kind void;
  #L253170.  call temp:= `getMainQueue`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.getMainQueue:()Lio/reactivex/e0/a/j;` @kind virtual;
  #L253176.  v0:= temp @kind object;
  #L253178.  call temp:= `offer`(v0, v10) @signature `Lio/reactivex/e0/a/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L25317e.  v10:= temp;
  #L253180.  if v10 != 0 then goto L253196;
  #L253184.  v10:= new `java.lang.IllegalStateException`;
  #L253188.  call `<init>`(v10, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L25318e.  call `onError`(v9, v10) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L253194.  return @kind void;
  #L253196.  call temp:= `getAndIncrement`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L25319c.  v10:= temp;
  #L25319e.  if v10 == 0 then goto L2531a4;
  #L2531a2.  return @kind void;
  #L2531a4.  call `drainLoop`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.drainLoop:()V` @kind virtual;
  #L2531aa.  return @kind void;
}

record `n.a.a.a.t.a.b` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `int`[] `@@n.a.a.a.t.a.b.a` @AccessFlag STATIC_FINAL;
global `int`[] `@@n.a.a.a.t.a.b.b` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Ln/a/a/a/t/a/b;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;

  #L3503ac.  v0:= 8I;
  #L3503b0.  v0:= new `int`[v0];
  #L3503b4.  goto L3503d4;
  #L3503ba.  `@@n.a.a.a.t.a.b.a` @type ^`int`[] := v0 @kind object;
  #L3503be.  v0:= 16I;
  #L3503c2.  v0:= new `int`[v0];
  #L3503c6.  goto L3503fc;
  #L3503cc.  `@@n.a.a.a.t.a.b.b` @type ^`int`[] := v0 @kind object;
  #L3503d0.  return @kind void;
  #L3503d2.  
  #L3503d4.  v0:= (-19I, -1I, -1I, -1I, -1I, -1I, -1I, 2147483647I) @kind object;
  #L3503fb.  goto L3503ba;
  #L3503fc.  v0:= (361I, 0I, 0I, 0I, 0I, 0I, 0I, 0I, -19I, -1I, -1I, -1I, -1I, -1I, -1I, 1073741823I) @kind object;
  #L350443.  goto L3503cc;
}
procedure `void` `a`(`int`[] v0 @kind object, `int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/a/b;.a:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;

  #L350454.  call temp:= `a`(v0, v1, v2) @signature `Ln/a/a/c/d;.a:([I[I[I)I` @kind static;
  #L35045a.  v0:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L35045e.  call temp:= `m`(v2, v0) @signature `Ln/a/a/c/d;.m:([I[I)Z` @kind static;
  #L350464.  v0:= temp;
  #L350466.  if v0 == 0 then goto L350470;
  #L35046a.  call temp:= `m`(v2) @signature `Ln/a/a/a/t/a/b;.m:([I)I` @kind static;
  #L350470.  return @kind void;
}
procedure `void` `b`(`int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/a/b;.b:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L350484.  v0:= 8I;
  #L350488.  call temp:= `q`(v0, v1, v2) @signature `Ln/a/a/c/g;.q:(I[I[I)I` @kind static;
  #L35048e.  v1:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L350492.  call temp:= `m`(v2, v1) @signature `Ln/a/a/c/d;.m:([I[I)Z` @kind static;
  #L350498.  v1:= temp;
  #L35049a.  if v1 == 0 then goto L3504a4;
  #L35049e.  call temp:= `m`(v2) @signature `Ln/a/a/a/t/a/b;.m:([I)I` @kind static;
  #L3504a4.  return @kind void;
}
procedure `int` `c`(`int`[] v9 @kind object) @signature `Ln/a/a/a/t/a/b;.c:([I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L3501e0.  v0:= 0I;
  #L3501e2.  v1:= v9[v0];
  #L3501e6.  v1:= (`long`) v1 @kind i2l;
  #L3501e8.  v3:= 4294967295L;
  #L3501f2.  v1:= v1 ^& v3 @kind long;
  #L3501f4.  v5:= 19L;
  #L3501f8.  v1:= v1 - v5 @kind long;
  #L3501fa.  v5:= (`int`) v1 @kind l2i;
  #L3501fc.  v9[v0]:= v5;
  #L350200.  v0:= 32I;
  #L350204.  v1:= v1 ^> v0 @kind long;
  #L350206.  v5:= 7I;
  #L350208.  v6:= 0L;
  #L35020c.  v8:= lcmp(v1, v6);
  #L350210.  if v8 == 0 then goto L350220;
  #L350214.  v1:= 1I;
  #L350216.  call temp:= `k`(v5, v9, v1) @signature `Ln/a/a/c/g;.k:(I[II)I` @kind static;
  #L35021c.  v1:= temp;
  #L35021e.  v1:= (`long`) v1 @kind i2l;
  #L350220.  v6:= v9[v5];
  #L350224.  v6:= (`long`) v6 @kind i2l;
  #L350226.  v3:= v3 ^& v6 @kind long;
  #L350228.  v6:= 2147483648L;
  #L350232.  v3:= v3 + v6 @kind long;
  #L350234.  v1:= v1 + v3 @kind long;
  #L350236.  v3:= (`int`) v1 @kind l2i;
  #L350238.  v9[v5]:= v3;
  #L35023c.  v0:= v1 ^> v0 @kind long;
  #L350240.  v9:= (`int`) v0 @kind l2i;
  #L350242.  return v9;
}
procedure `int`[] `d`(`java.math.BigInteger` v2 @kind object) @signature `Ln/a/a/a/t/a/b;.d:(Ljava/math/BigInteger;)[I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L350378.  call temp:= `j`(v2) @signature `Ln/a/a/c/d;.j:(Ljava/math/BigInteger;)[I` @kind static;
  #L35037e.  v2:= temp @kind object;
  #L350380.  v0:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L350384.  call temp:= `m`(v2, v0) @signature `Ln/a/a/c/d;.m:([I[I)Z` @kind static;
  #L35038a.  v1:= temp;
  #L35038c.  if v1 == 0 then goto L350398;
  #L350390.  call temp:= `A`(v0, v2) @signature `Ln/a/a/c/d;.A:([I[I)I` @kind static;
  #L350396.  goto L350380;
  #L350398.  return v2 @kind object;
}
procedure `void` `e`(`int`[] v1 @kind object, `int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Ln/a/a/a/t/a/b;.e:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L3504b8.  call temp:= `g`() @signature `Ln/a/a/c/d;.g:()[I` @kind static;
  #L3504be.  v0:= temp @kind object;
  #L3504c0.  call `q`(v1, v2, v0) @signature `Ln/a/a/c/d;.q:([I[I[I)V` @kind static;
  #L3504c6.  call `h`(v0, v3) @signature `Ln/a/a/a/t/a/b;.h:([I[I)V` @kind static;
  #L3504cc.  return @kind void;
}
procedure `void` `f`(`int`[] v0 @kind object, `int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/a/b;.f:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;

  #L3504e0.  call temp:= `u`(v0, v1, v2) @signature `Ln/a/a/c/d;.u:([I[I[I)I` @kind static;
  #L3504e6.  v0:= `@@n.a.a.a.t.a.b.b` @type ^`int`[] @kind object;
  #L3504ea.  v1:= 16I;
  #L3504ee.  call temp:= `o`(v1, v2, v0) @signature `Ln/a/a/c/g;.o:(I[I[I)Z` @kind static;
  #L3504f4.  v0:= temp;
  #L3504f6.  if v0 == 0 then goto L350500;
  #L3504fa.  call temp:= `l`(v2) @signature `Ln/a/a/a/t/a/b;.l:([I)I` @kind static;
  #L350500.  return @kind void;
}
procedure `void` `g`(`int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/a/b;.g:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L350514.  call temp:= `o`(v1) @signature `Ln/a/a/c/d;.o:([I)Z` @kind static;
  #L35051a.  v0:= temp;
  #L35051c.  if v0 == 0 then goto L350528;
  #L350520.  call `C`(v2) @signature `Ln/a/a/c/d;.C:([I)V` @kind static;
  #L350526.  goto L350532;
  #L350528.  v0:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L35052c.  call temp:= `z`(v0, v1, v2) @signature `Ln/a/a/c/d;.z:([I[I[I)I` @kind static;
  #L350532.  return @kind void;
}
procedure `void` `h`(`int`[] v8 @kind object, `int`[] v9 @kind object) @signature `Ln/a/a/a/t/a/b;.h:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L350544.  v0:= 7I;
  #L350546.  v7:= v8[v0];
  #L35054a.  v1:= 8I;
  #L35054e.  v3:= 8I;
  #L350552.  v6:= 0I;
  #L350554.  v2:= v8 @kind object;
  #L350556.  v4:= v7;
  #L350558.  v5:= v9 @kind object;
  #L35055a.  call temp:= `B`(v1, v2, v3, v4, v5, v6) @signature `Ln/a/a/c/g;.B:(I[III[II)I` @kind static;
  #L350560.  v1:= 19I;
  #L350564.  call temp:= `v`(v1, v8, v9) @signature `Ln/a/a/c/d;.v:(I[I[I)I` @kind static;
  #L35056a.  v8:= temp;
  #L35056c.  v8:= v8 ^< 1;
  #L350570.  v2:= v9[v0];
  #L350574.  v3:= v2 ^>> 31;
  #L350578.  v4:= v7 ^>> 31;
  #L35057c.  v3:= v3 - v4 @kind int;
  #L35057e.  v8:= v8 + v3 @kind int;
  #L350580.  v3:= 2147483647I;
  #L350586.  v2:= v2 ^& v3 @kind int;
  #L350588.  v8:= v8 * 19;
  #L35058c.  call temp:= `g`(v0, v8, v9) @signature `Ln/a/a/c/g;.g:(II[I)I` @kind static;
  #L350592.  v8:= temp;
  #L350594.  v2:= v2 + v8 @kind int;
  #L350596.  v9[v0]:= v2;
  #L35059a.  v8:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L35059e.  call temp:= `m`(v9, v8) @signature `Ln/a/a/c/d;.m:([I[I)Z` @kind static;
  #L3505a4.  v8:= temp;
  #L3505a6.  if v8 == 0 then goto L3505b0;
  #L3505aa.  call temp:= `m`(v9) @signature `Ln/a/a/a/t/a/b;.m:([I)I` @kind static;
  #L3505b0.  return @kind void;
}
procedure `void` `i`(`int` v3 , `int`[] v4 @kind object) @signature `Ln/a/a/a/t/a/b;.i:(I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L3505c4.  v0:= 7I;
  #L3505c6.  v1:= v4[v0];
  #L3505ca.  v3:= v3 ^< 1;
  #L3505ce.  v2:= v1 ^>> 31;
  #L3505d2.  v3:= v3 ^| v2 @kind int;
  #L3505d4.  v2:= 2147483647I;
  #L3505da.  v1:= v1 ^& v2 @kind int;
  #L3505dc.  v3:= v3 * 19;
  #L3505e0.  call temp:= `g`(v0, v3, v4) @signature `Ln/a/a/c/g;.g:(II[I)I` @kind static;
  #L3505e6.  v3:= temp;
  #L3505e8.  v1:= v1 + v3 @kind int;
  #L3505ea.  v4[v0]:= v1;
  #L3505ee.  v3:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L3505f2.  call temp:= `m`(v4, v3) @signature `Ln/a/a/c/d;.m:([I[I)Z` @kind static;
  #L3505f8.  v3:= temp;
  #L3505fa.  if v3 == 0 then goto L350604;
  #L3505fe.  call temp:= `m`(v4) @signature `Ln/a/a/a/t/a/b;.m:([I)I` @kind static;
  #L350604.  return @kind void;
}
procedure `void` `j`(`int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/a/b;.j:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L350618.  call temp:= `g`() @signature `Ln/a/a/c/d;.g:()[I` @kind static;
  #L35061e.  v0:= temp @kind object;
  #L350620.  call `x`(v1, v0) @signature `Ln/a/a/c/d;.x:([I[I)V` @kind static;
  #L350626.  call `h`(v0, v2) @signature `Ln/a/a/a/t/a/b;.h:([I[I)V` @kind static;
  #L35062c.  return @kind void;
}
procedure `void` `k`(`int`[] v1 @kind object, `int` v2 , `int`[] v3 @kind object) @signature `Ln/a/a/a/t/a/b;.k:([II[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L350640.  call temp:= `g`() @signature `Ln/a/a/c/d;.g:()[I` @kind static;
  #L350646.  v0:= temp @kind object;
  #L350648.  call `x`(v1, v0) @signature `Ln/a/a/c/d;.x:([I[I)V` @kind static;
  #L35064e.  call `h`(v0, v3) @signature `Ln/a/a/a/t/a/b;.h:([I[I)V` @kind static;
  #L350654.  v2:= v2 + -1;
  #L350658.  if v2 <= 0 then goto L350664;
  #L35065c.  call `x`(v3, v0) @signature `Ln/a/a/c/d;.x:([I[I)V` @kind static;
  #L350662.  goto L35064e;
  #L350664.  return @kind void;
}
procedure `int` `l`(`int`[] v14 @kind object) @signature `Ln/a/a/a/t/a/b;.l:([I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;

  #L350254.  v0:= 0I;
  #L350256.  v1:= v14[v0];
  #L35025a.  v1:= (`long`) v1 @kind i2l;
  #L35025c.  v3:= 4294967295L;
  #L350266.  v1:= v1 ^& v3 @kind long;
  #L350268.  v5:= `@@n.a.a.a.t.a.b.b` @type ^`int`[] @kind object;
  #L35026c.  v6:= v5[v0];
  #L350270.  v6:= (`long`) v6 @kind i2l;
  #L350272.  v6:= v6 ^& v3 @kind long;
  #L350274.  v1:= v1 - v6 @kind long;
  #L350276.  v6:= (`int`) v1 @kind l2i;
  #L350278.  v14[v0]:= v6;
  #L35027c.  v0:= 32I;
  #L350280.  v1:= v1 ^> v0 @kind long;
  #L350282.  v6:= 1I;
  #L350284.  v7:= 0L;
  #L350288.  v9:= 8I;
  #L35028c.  v10:= lcmp(v1, v7);
  #L350290.  if v10 == 0 then goto L35029e;
  #L350294.  call temp:= `k`(v9, v14, v6) @signature `Ln/a/a/c/g;.k:(I[II)I` @kind static;
  #L35029a.  v1:= temp;
  #L35029c.  v1:= (`long`) v1 @kind i2l;
  #L35029e.  v10:= v14[v9];
  #L3502a2.  v10:= (`long`) v10 @kind i2l;
  #L3502a4.  v10:= v10 ^& v3 @kind long;
  #L3502a6.  v12:= 19L;
  #L3502aa.  v10:= v10 + v12 @kind long;
  #L3502ac.  v1:= v1 + v10 @kind long;
  #L3502ae.  v10:= (`int`) v1 @kind l2i;
  #L3502b0.  v14[v9]:= v10;
  #L3502b4.  v1:= v1 ^> v0 @kind long;
  #L3502b6.  v9:= 15I;
  #L3502ba.  v10:= lcmp(v1, v7);
  #L3502be.  if v10 == 0 then goto L3502d0;
  #L3502c2.  v1:= 9I;
  #L3502c6.  call temp:= `r`(v9, v14, v1) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L3502cc.  v1:= temp;
  #L3502ce.  v1:= (`long`) v1 @kind i2l;
  #L3502d0.  v7:= v14[v9];
  #L3502d4.  v7:= (`long`) v7 @kind i2l;
  #L3502d6.  v7:= v7 ^& v3 @kind long;
  #L3502d8.  v5:= v5[v9];
  #L3502dc.  v5:= v5 + v6 @kind int;
  #L3502de.  v5:= (`long`) v5 @kind i2l;
  #L3502e0.  v3:= v3 ^& v5 @kind long;
  #L3502e2.  v7:= v7 - v3 @kind long;
  #L3502e4.  v1:= v1 + v7 @kind long;
  #L3502e6.  v3:= (`int`) v1 @kind l2i;
  #L3502e8.  v14[v9]:= v3;
  #L3502ec.  v0:= v1 ^> v0 @kind long;
  #L3502f0.  v14:= (`int`) v0 @kind l2i;
  #L3502f2.  return v14;
}
procedure `int` `m`(`int`[] v9 @kind object) @signature `Ln/a/a/a/t/a/b;.m:([I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L350304.  v0:= 0I;
  #L350306.  v1:= v9[v0];
  #L35030a.  v1:= (`long`) v1 @kind i2l;
  #L35030c.  v3:= 4294967295L;
  #L350316.  v1:= v1 ^& v3 @kind long;
  #L350318.  v5:= 19L;
  #L35031c.  v1:= v1 + v5 @kind long;
  #L35031e.  v5:= (`int`) v1 @kind l2i;
  #L350320.  v9[v0]:= v5;
  #L350324.  v0:= 32I;
  #L350328.  v1:= v1 ^> v0 @kind long;
  #L35032a.  v5:= 7I;
  #L35032c.  v6:= 0L;
  #L350330.  v8:= lcmp(v1, v6);
  #L350334.  if v8 == 0 then goto L350344;
  #L350338.  v1:= 1I;
  #L35033a.  call temp:= `r`(v5, v9, v1) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L350340.  v1:= temp;
  #L350342.  v1:= (`long`) v1 @kind i2l;
  #L350344.  v6:= v9[v5];
  #L350348.  v6:= (`long`) v6 @kind i2l;
  #L35034a.  v3:= v3 ^& v6 @kind long;
  #L35034c.  v6:= 2147483648L;
  #L350356.  v3:= v3 - v6 @kind long;
  #L350358.  v1:= v1 + v3 @kind long;
  #L35035a.  v3:= (`int`) v1 @kind l2i;
  #L35035c.  v9[v5]:= v3;
  #L350360.  v0:= v1 ^> v0 @kind long;
  #L350364.  v9:= (`int`) v0 @kind l2i;
  #L350366.  return v9;
}
procedure `void` `n`(`int`[] v0 @kind object, `int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/a/b;.n:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;

  #L350678.  call temp:= `z`(v0, v1, v2) @signature `Ln/a/a/c/d;.z:([I[I[I)I` @kind static;
  #L35067e.  v0:= temp;
  #L350680.  if v0 == 0 then goto L35068a;
  #L350684.  call temp:= `c`(v2) @signature `Ln/a/a/a/t/a/b;.c:([I)I` @kind static;
  #L35068a.  return @kind void;
}
procedure `void` `o`(`int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Ln/a/a/a/t/a/b;.o:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35069c.  v0:= 8I;
  #L3506a0.  v1:= 0I;
  #L3506a2.  call temp:= `C`(v0, v2, v1, v3) @signature `Ln/a/a/c/g;.C:(I[II[I)I` @kind static;
  #L3506a8.  v2:= `@@n.a.a.a.t.a.b.a` @type ^`int`[] @kind object;
  #L3506ac.  call temp:= `m`(v3, v2) @signature `Ln/a/a/c/d;.m:([I[I)Z` @kind static;
  #L3506b2.  v2:= temp;
  #L3506b4.  if v2 == 0 then goto L3506be;
  #L3506b8.  call temp:= `m`(v3) @signature `Ln/a/a/a/t/a/b;.m:([I)I` @kind static;
  #L3506be.  return @kind void;
}

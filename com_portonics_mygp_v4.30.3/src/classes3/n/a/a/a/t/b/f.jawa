record `n.a.a.a.t.b.f` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `int`[] `@@n.a.a.a.t.b.f.a` @AccessFlag STATIC_FINAL;
global `int`[] `@@n.a.a.a.t.b.f.b` @AccessFlag STATIC_FINAL;
global `int`[] `@@n.a.a.a.t.b.f.c` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Ln/a/a/a/t/b/f;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;

  #L352268.  v0:= 6I;
  #L35226a.  v0:= new `int`[v0];
  #L35226e.  goto L3522a0;
  #L352274.  `@@n.a.a.a.t.b.f.a` @type ^`int`[] := v0 @kind object;
  #L352278.  v0:= 12I;
  #L35227c.  v0:= new `int`[v0];
  #L352280.  goto L3522c0;
  #L352286.  `@@n.a.a.a.t.b.f.b` @type ^`int`[] := v0 @kind object;
  #L35228a.  v0:= 9I;
  #L35228e.  v0:= new `int`[v0];
  #L352292.  goto L3522f8;
  #L352298.  `@@n.a.a.a.t.b.f.c` @type ^`int`[] := v0 @kind object;
  #L35229c.  return @kind void;
  #L35229e.  
  #L3522a0.  v0:= (-1I, -1I, -2I, -1I, -1I, -1I) @kind object;
  #L3522bf.  goto L352274;
  #L3522c0.  v0:= (1I, 0I, 2I, 0I, 1I, 0I, -2I, -1I, -3I, -1I, -1I, -1I) @kind object;
  #L3522f7.  goto L352286;
  #L3522f8.  v0:= (-1I, -1I, -3I, -1I, -2I, -1I, 1I, 0I, 2I) @kind object;
  #L352323.  goto L352298;
}
procedure `void` `a`(`int`[] v0 @kind object, `int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/b/f;.a:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;

  #L352334.  call temp:= `a`(v0, v1, v2) @signature `Ln/a/a/c/b;.a:([I[I[I)I` @kind static;
  #L35233a.  v0:= temp;
  #L35233c.  if v0 != 0 then goto L35235c;
  #L352340.  v0:= 5I;
  #L352342.  v0:= v2[v0];
  #L352346.  v1:= -1I;
  #L352348.  if v0 != v1 then goto L352362;
  #L35234c.  v0:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L352350.  call temp:= `l`(v2, v0) @signature `Ln/a/a/c/b;.l:([I[I)Z` @kind static;
  #L352356.  v0:= temp;
  #L352358.  if v0 == 0 then goto L352362;
  #L35235c.  call `c`(v2) @signature `Ln/a/a/a/t/b/f;.c:([I)V` @kind static;
  #L352362.  return @kind void;
}
procedure `void` `b`(`int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/b/f;.b:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L352374.  v0:= 6I;
  #L352376.  call temp:= `q`(v0, v1, v2) @signature `Ln/a/a/c/g;.q:(I[I[I)I` @kind static;
  #L35237c.  v1:= temp;
  #L35237e.  if v1 != 0 then goto L35239e;
  #L352382.  v1:= 5I;
  #L352384.  v1:= v2[v1];
  #L352388.  v0:= -1I;
  #L35238a.  if v1 != v0 then goto L3523a4;
  #L35238e.  v1:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L352392.  call temp:= `l`(v2, v1) @signature `Ln/a/a/c/b;.l:([I[I)Z` @kind static;
  #L352398.  v1:= temp;
  #L35239a.  if v1 == 0 then goto L3523a4;
  #L35239e.  call `c`(v2) @signature `Ln/a/a/a/t/b/f;.c:([I)V` @kind static;
  #L3523a4.  return @kind void;
}
procedure `void` `c`(`int`[] v12 @kind object) @signature `Ln/a/a/a/t/b/f;.c:([I)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;

  #L3523b8.  v0:= 0I;
  #L3523ba.  v1:= v12[v0];
  #L3523be.  v1:= (`long`) v1 @kind i2l;
  #L3523c0.  v3:= 4294967295L;
  #L3523ca.  v1:= v1 ^& v3 @kind long;
  #L3523cc.  v5:= 1L;
  #L3523d0.  v1:= v1 + v5 @kind long;
  #L3523d2.  v7:= (`int`) v1 @kind l2i;
  #L3523d4.  v12[v0]:= v7;
  #L3523d8.  v0:= 32I;
  #L3523dc.  v1:= v1 ^> v0 @kind long;
  #L3523de.  v7:= 0L;
  #L3523e2.  v9:= lcmp(v1, v7);
  #L3523e6.  if v9 == 0 then goto L3523fe;
  #L3523ea.  v9:= 1I;
  #L3523ec.  v10:= v12[v9];
  #L3523f0.  v10:= (`long`) v10 @kind i2l;
  #L3523f2.  v10:= v10 ^& v3 @kind long;
  #L3523f4.  v1:= v1 + v10 @kind long;
  #L3523f6.  v10:= (`int`) v1 @kind l2i;
  #L3523f8.  v12[v9]:= v10;
  #L3523fc.  v1:= v1 ^> v0 @kind long;
  #L3523fe.  v9:= 2I;
  #L352400.  v10:= v12[v9];
  #L352404.  v10:= (`long`) v10 @kind i2l;
  #L352406.  v3:= v3 ^& v10 @kind long;
  #L352408.  v3:= v3 + v5 @kind long;
  #L35240a.  v1:= v1 + v3 @kind long;
  #L35240c.  v3:= (`int`) v1 @kind l2i;
  #L35240e.  v12[v9]:= v3;
  #L352412.  v0:= v1 ^> v0 @kind long;
  #L352416.  v2:= lcmp(v0, v7);
  #L35241a.  if v2 == 0 then goto L352428;
  #L35241e.  v0:= 6I;
  #L352420.  v1:= 3I;
  #L352422.  call temp:= `r`(v0, v12, v1) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L352428.  return @kind void;
}
procedure `int`[] `d`(`java.math.BigInteger` v2 @kind object) @signature `Ln/a/a/a/t/b/f;.d:(Ljava/math/BigInteger;)[I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35222c.  call temp:= `i`(v2) @signature `Ln/a/a/c/b;.i:(Ljava/math/BigInteger;)[I` @kind static;
  #L352232.  v2:= temp @kind object;
  #L352234.  v0:= 5I;
  #L352236.  v0:= v2[v0];
  #L35223a.  v1:= -1I;
  #L35223c.  if v0 != v1 then goto L352256;
  #L352240.  v0:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L352244.  call temp:= `l`(v2, v0) @signature `Ln/a/a/c/b;.l:([I[I)Z` @kind static;
  #L35224a.  v1:= temp;
  #L35224c.  if v1 == 0 then goto L352256;
  #L352250.  call temp:= `y`(v0, v2) @signature `Ln/a/a/c/b;.y:([I[I)I` @kind static;
  #L352256.  return v2 @kind object;
}
procedure `void` `e`(`int`[] v1 @kind object, `int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Ln/a/a/a/t/b/f;.e:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L35243c.  call temp:= `f`() @signature `Ln/a/a/c/b;.f:()[I` @kind static;
  #L352442.  v0:= temp @kind object;
  #L352444.  call `p`(v1, v2, v0) @signature `Ln/a/a/c/b;.p:([I[I[I)V` @kind static;
  #L35244a.  call `h`(v0, v3) @signature `Ln/a/a/a/t/b/f;.h:([I[I)V` @kind static;
  #L352450.  return @kind void;
}
procedure `void` `f`(`int`[] v1 @kind object, `int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Ln/a/a/a/t/b/f;.f:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L352464.  call temp:= `t`(v1, v2, v3) @signature `Ln/a/a/c/b;.t:([I[I[I)I` @kind static;
  #L35246a.  v1:= temp;
  #L35246c.  v2:= 12I;
  #L352470.  if v1 != 0 then goto L352492;
  #L352474.  v1:= 11I;
  #L352478.  v1:= v3[v1];
  #L35247c.  v0:= -1I;
  #L35247e.  if v1 != v0 then goto L3524ac;
  #L352482.  v1:= `@@n.a.a.a.t.b.f.b` @type ^`int`[] @kind object;
  #L352486.  call temp:= `o`(v2, v3, v1) @signature `Ln/a/a/c/g;.o:(I[I[I)Z` @kind static;
  #L35248c.  v1:= temp;
  #L35248e.  if v1 == 0 then goto L3524ac;
  #L352492.  v1:= `@@n.a.a.a.t.b.f.c` @type ^`int`[] @kind object;
  #L352496.  v0:= length @variable v1;
  #L352498.  call temp:= `e`(v0, v1, v3) @signature `Ln/a/a/c/g;.e:(I[I[I)I` @kind static;
  #L35249e.  v0:= temp;
  #L3524a0.  if v0 == 0 then goto L3524ac;
  #L3524a4.  v1:= length @variable v1;
  #L3524a6.  call temp:= `r`(v2, v3, v1) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L3524ac.  return @kind void;
}
procedure `void` `g`(`int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/b/f;.g:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L3524c0.  call temp:= `n`(v1) @signature `Ln/a/a/c/b;.n:([I)Z` @kind static;
  #L3524c6.  v0:= temp;
  #L3524c8.  if v0 == 0 then goto L3524d4;
  #L3524cc.  call `A`(v2) @signature `Ln/a/a/c/b;.A:([I)V` @kind static;
  #L3524d2.  goto L3524de;
  #L3524d4.  v0:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L3524d8.  call temp:= `x`(v0, v1, v2) @signature `Ln/a/a/c/b;.x:([I[I[I)I` @kind static;
  #L3524de.  return @kind void;
}
procedure `void` `h`(`int`[] v26 @kind object, `int`[] v27 @kind object) @signature `Ln/a/a/a/t/b/f;.h:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;
    v23;
    v24;
    v25;

  #L3524f0.  v0:= v27 @kind object;
  #L3524f4.  v1:= 6I;
  #L3524f6.  v2:= v26[v1];
  #L3524fa.  v2:= (`long`) v2 @kind i2l;
  #L3524fc.  v4:= 4294967295L;
  #L352506.  v2:= v2 ^& v4 @kind long;
  #L352508.  v6:= 7I;
  #L35250a.  v6:= v26[v6];
  #L35250e.  v6:= (`long`) v6 @kind i2l;
  #L352510.  v6:= v6 ^& v4 @kind long;
  #L352512.  v8:= 8I;
  #L352516.  v8:= v26[v8];
  #L35251a.  v8:= (`long`) v8 @kind i2l;
  #L35251c.  v8:= v8 ^& v4 @kind long;
  #L35251e.  v10:= 9I;
  #L352522.  v10:= v26[v10];
  #L352526.  v10:= (`long`) v10 @kind i2l;
  #L352528.  v10:= v10 ^& v4 @kind long;
  #L35252a.  v12:= 10I;
  #L35252e.  v12:= v26[v12];
  #L352532.  v12:= (`long`) v12 @kind i2l;
  #L352534.  v12:= v12 ^& v4 @kind long;
  #L352536.  v14:= 11I;
  #L35253a.  v14:= v26[v14];
  #L35253e.  v14:= (`long`) v14 @kind i2l;
  #L352540.  v14:= v14 ^& v4 @kind long;
  #L352542.  v12:= v12 + v2 @kind long;
  #L352544.  v14:= v14 + v6 @kind long;
  #L352546.  v16:= 0I;
  #L35254a.  v1:= v26[v16];
  #L35254e.  v17:= v6 @kind wide;
  #L352552.  v6:= (`long`) v1 @kind i2l;
  #L352554.  v6:= v6 ^& v4 @kind long;
  #L352556.  v6:= v6 + v12 @kind long;
  #L352558.  v19:= 0L;
  #L35255c.  v6:= v6 + v19 @kind long;
  #L352560.  v1:= (`int`) v6 @kind l2i;
  #L352562.  v21:= 32I;
  #L352566.  v6:= v6 ^> v21 @kind long;
  #L35256a.  v22:= 1I;
  #L35256e.  v23:= v1;
  #L352572.  v1:= v26[v22];
  #L352576.  v24:= v2 @kind wide;
  #L35257a.  v1:= (`long`) v1 @kind i2l;
  #L35257c.  v1:= v1 ^& v4 @kind long;
  #L35257e.  v1:= v1 + v14 @kind long;
  #L352580.  v6:= v6 + v1 @kind long;
  #L352582.  v1:= (`int`) v6 @kind l2i;
  #L352584.  v0[v22]:= v1;
  #L352588.  v1:= v6 ^> v21 @kind long;
  #L35258c.  v12:= v12 + v8 @kind long;
  #L35258e.  v14:= v14 + v10 @kind long;
  #L352590.  v3:= 2I;
  #L352592.  v6:= v26[v3];
  #L352596.  v6:= (`long`) v6 @kind i2l;
  #L352598.  v6:= v6 ^& v4 @kind long;
  #L35259a.  v6:= v6 + v12 @kind long;
  #L35259c.  v1:= v1 + v6 @kind long;
  #L35259e.  v6:= v1 ^& v4 @kind long;
  #L3525a2.  v1:= v1 ^> v21 @kind long;
  #L3525a6.  v8:= 3I;
  #L3525a8.  v9:= v26[v8];
  #L3525ac.  v9:= (`long`) v9 @kind i2l;
  #L3525ae.  v9:= v9 ^& v4 @kind long;
  #L3525b0.  v9:= v9 + v14 @kind long;
  #L3525b2.  v1:= v1 + v9 @kind long;
  #L3525b4.  v9:= (`int`) v1 @kind l2i;
  #L3525b6.  v0[v8]:= v9;
  #L3525ba.  v1:= v1 ^> v21 @kind long;
  #L3525be.  v12:= v12 - v24 @kind long;
  #L3525c2.  v14:= v14 - v17 @kind long;
  #L3525c6.  v9:= 4I;
  #L3525c8.  v10:= v26[v9];
  #L3525cc.  v10:= (`long`) v10 @kind i2l;
  #L3525ce.  v10:= v10 ^& v4 @kind long;
  #L3525d0.  v10:= v10 + v12 @kind long;
  #L3525d2.  v1:= v1 + v10 @kind long;
  #L3525d4.  v10:= (`int`) v1 @kind l2i;
  #L3525d6.  v0[v9]:= v10;
  #L3525da.  v1:= v1 ^> v21 @kind long;
  #L3525de.  v9:= 5I;
  #L3525e0.  v10:= v26[v9];
  #L3525e4.  v10:= (`long`) v10 @kind i2l;
  #L3525e6.  v10:= v10 ^& v4 @kind long;
  #L3525e8.  v10:= v10 + v14 @kind long;
  #L3525ea.  v1:= v1 + v10 @kind long;
  #L3525ec.  v10:= (`int`) v1 @kind l2i;
  #L3525ee.  v0[v9]:= v10;
  #L3525f2.  v1:= v1 ^> v21 @kind long;
  #L3525f6.  v6:= v6 + v1 @kind long;
  #L3525f8.  v10:= v23;
  #L3525fc.  v10:= (`long`) v10 @kind i2l;
  #L3525fe.  v10:= v10 ^& v4 @kind long;
  #L352600.  v1:= v1 + v10 @kind long;
  #L352602.  v10:= (`int`) v1 @kind l2i;
  #L352604.  v0[v16]:= v10;
  #L352608.  v1:= v1 ^> v21 @kind long;
  #L35260c.  v10:= lcmp(v1, v19);
  #L352610.  if v10 == 0 then goto L35262a;
  #L352614.  v10:= v0[v22];
  #L352618.  v10:= (`long`) v10 @kind i2l;
  #L35261a.  v4:= v4 ^& v10 @kind long;
  #L35261c.  v1:= v1 + v4 @kind long;
  #L35261e.  v4:= (`int`) v1 @kind l2i;
  #L352620.  v0[v22]:= v4;
  #L352624.  v1:= v1 ^> v21 @kind long;
  #L352628.  v6:= v6 + v1 @kind long;
  #L35262a.  v1:= (`int`) v6 @kind l2i;
  #L35262c.  v0[v3]:= v1;
  #L352630.  v1:= v6 ^> v21 @kind long;
  #L352634.  v3:= lcmp(v1, v19);
  #L352638.  if v3 == 0 then goto L35264a;
  #L35263c.  v1:= 6I;
  #L35263e.  call temp:= `r`(v1, v0, v8) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L352644.  v1:= temp;
  #L352646.  if v1 != 0 then goto L352664;
  #L35264a.  v1:= v0[v9];
  #L35264e.  v2:= -1I;
  #L352650.  if v1 != v2 then goto L35266a;
  #L352654.  v1:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L352658.  call temp:= `l`(v0, v1) @signature `Ln/a/a/c/b;.l:([I[I)Z` @kind static;
  #L35265e.  v1:= temp;
  #L352660.  if v1 == 0 then goto L35266a;
  #L352664.  call `c`(v27) @signature `Ln/a/a/a/t/b/f;.c:([I)V` @kind static;
  #L35266a.  return @kind void;
}
procedure `void` `i`(`int` v11 , `int`[] v12 @kind object) @signature `Ln/a/a/a/t/b/f;.i:(I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;

  #L35267c.  v0:= 0L;
  #L352680.  if v11 == 0 then goto L3526e2;
  #L352684.  v2:= (`long`) v11 @kind i2l;
  #L352686.  v4:= 4294967295L;
  #L352690.  v2:= v2 ^& v4 @kind long;
  #L352692.  v11:= 0I;
  #L352694.  v6:= v12[v11];
  #L352698.  v6:= (`long`) v6 @kind i2l;
  #L35269a.  v6:= v6 ^& v4 @kind long;
  #L35269c.  v6:= v6 + v2 @kind long;
  #L35269e.  v6:= v6 + v0 @kind long;
  #L3526a0.  v8:= (`int`) v6 @kind l2i;
  #L3526a2.  v12[v11]:= v8;
  #L3526a6.  v11:= 32I;
  #L3526aa.  v6:= v6 ^> v11 @kind long;
  #L3526ac.  v8:= lcmp(v6, v0);
  #L3526b0.  if v8 == 0 then goto L3526c8;
  #L3526b4.  v8:= 1I;
  #L3526b6.  v9:= v12[v8];
  #L3526ba.  v9:= (`long`) v9 @kind i2l;
  #L3526bc.  v9:= v9 ^& v4 @kind long;
  #L3526be.  v6:= v6 + v9 @kind long;
  #L3526c0.  v9:= (`int`) v6 @kind l2i;
  #L3526c2.  v12[v8]:= v9;
  #L3526c6.  v6:= v6 ^> v11 @kind long;
  #L3526c8.  v8:= 2I;
  #L3526ca.  v9:= v12[v8];
  #L3526ce.  v9:= (`long`) v9 @kind i2l;
  #L3526d0.  v4:= v4 ^& v9 @kind long;
  #L3526d2.  v4:= v4 + v2 @kind long;
  #L3526d4.  v6:= v6 + v4 @kind long;
  #L3526d6.  v2:= (`int`) v6 @kind l2i;
  #L3526d8.  v12[v8]:= v2;
  #L3526dc.  v2:= v6 ^> v11 @kind long;
  #L3526e0.  goto L3526e4;
  #L3526e2.  v2:= v0 @kind wide;
  #L3526e4.  v11:= lcmp(v2, v0);
  #L3526e8.  if v11 == 0 then goto L3526fc;
  #L3526ec.  v11:= 6I;
  #L3526ee.  v0:= 3I;
  #L3526f0.  call temp:= `r`(v11, v12, v0) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L3526f6.  v11:= temp;
  #L3526f8.  if v11 != 0 then goto L352718;
  #L3526fc.  v11:= 5I;
  #L3526fe.  v11:= v12[v11];
  #L352702.  v0:= -1I;
  #L352704.  if v11 != v0 then goto L35271e;
  #L352708.  v11:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L35270c.  call temp:= `l`(v12, v11) @signature `Ln/a/a/c/b;.l:([I[I)Z` @kind static;
  #L352712.  v11:= temp;
  #L352714.  if v11 == 0 then goto L35271e;
  #L352718.  call `c`(v12) @signature `Ln/a/a/a/t/b/f;.c:([I)V` @kind static;
  #L35271e.  return @kind void;
}
procedure `void` `j`(`int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/b/f;.j:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L352730.  call temp:= `f`() @signature `Ln/a/a/c/b;.f:()[I` @kind static;
  #L352736.  v0:= temp @kind object;
  #L352738.  call `v`(v1, v0) @signature `Ln/a/a/c/b;.v:([I[I)V` @kind static;
  #L35273e.  call `h`(v0, v2) @signature `Ln/a/a/a/t/b/f;.h:([I[I)V` @kind static;
  #L352744.  return @kind void;
}
procedure `void` `k`(`int`[] v1 @kind object, `int` v2 , `int`[] v3 @kind object) @signature `Ln/a/a/a/t/b/f;.k:([II[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L352758.  call temp:= `f`() @signature `Ln/a/a/c/b;.f:()[I` @kind static;
  #L35275e.  v0:= temp @kind object;
  #L352760.  call `v`(v1, v0) @signature `Ln/a/a/c/b;.v:([I[I)V` @kind static;
  #L352766.  call `h`(v0, v3) @signature `Ln/a/a/a/t/b/f;.h:([I[I)V` @kind static;
  #L35276c.  v2:= v2 + -1;
  #L352770.  if v2 <= 0 then goto L35277c;
  #L352774.  call `v`(v3, v0) @signature `Ln/a/a/c/b;.v:([I[I)V` @kind static;
  #L35277a.  goto L352766;
  #L35277c.  return @kind void;
}
procedure `void` `l`(`int`[] v12 @kind object) @signature `Ln/a/a/a/t/b/f;.l:([I)V` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;

  #L352790.  v0:= 0I;
  #L352792.  v1:= v12[v0];
  #L352796.  v1:= (`long`) v1 @kind i2l;
  #L352798.  v3:= 4294967295L;
  #L3527a2.  v1:= v1 ^& v3 @kind long;
  #L3527a4.  v5:= 1L;
  #L3527a8.  v1:= v1 - v5 @kind long;
  #L3527aa.  v7:= (`int`) v1 @kind l2i;
  #L3527ac.  v12[v0]:= v7;
  #L3527b0.  v0:= 32I;
  #L3527b4.  v1:= v1 ^> v0 @kind long;
  #L3527b6.  v7:= 0L;
  #L3527ba.  v9:= lcmp(v1, v7);
  #L3527be.  if v9 == 0 then goto L3527d6;
  #L3527c2.  v9:= 1I;
  #L3527c4.  v10:= v12[v9];
  #L3527c8.  v10:= (`long`) v10 @kind i2l;
  #L3527ca.  v10:= v10 ^& v3 @kind long;
  #L3527cc.  v1:= v1 + v10 @kind long;
  #L3527ce.  v10:= (`int`) v1 @kind l2i;
  #L3527d0.  v12[v9]:= v10;
  #L3527d4.  v1:= v1 ^> v0 @kind long;
  #L3527d6.  v9:= 2I;
  #L3527d8.  v10:= v12[v9];
  #L3527dc.  v10:= (`long`) v10 @kind i2l;
  #L3527de.  v3:= v3 ^& v10 @kind long;
  #L3527e0.  v3:= v3 - v5 @kind long;
  #L3527e2.  v1:= v1 + v3 @kind long;
  #L3527e4.  v3:= (`int`) v1 @kind l2i;
  #L3527e6.  v12[v9]:= v3;
  #L3527ea.  v0:= v1 ^> v0 @kind long;
  #L3527ee.  v2:= lcmp(v0, v7);
  #L3527f2.  if v2 == 0 then goto L352800;
  #L3527f6.  v0:= 6I;
  #L3527f8.  v1:= 3I;
  #L3527fa.  call temp:= `k`(v0, v12, v1) @signature `Ln/a/a/c/g;.k:(I[II)I` @kind static;
  #L352800.  return @kind void;
}
procedure `void` `m`(`int`[] v0 @kind object, `int`[] v1 @kind object, `int`[] v2 @kind object) @signature `Ln/a/a/a/t/b/f;.m:([I[I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;

  #L352814.  call temp:= `x`(v0, v1, v2) @signature `Ln/a/a/c/b;.x:([I[I[I)I` @kind static;
  #L35281a.  v0:= temp;
  #L35281c.  if v0 == 0 then goto L352826;
  #L352820.  call `l`(v2) @signature `Ln/a/a/a/t/b/f;.l:([I)V` @kind static;
  #L352826.  return @kind void;
}
procedure `void` `n`(`int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Ln/a/a/a/t/b/f;.n:([I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L352838.  v0:= 6I;
  #L35283a.  v1:= 0I;
  #L35283c.  call temp:= `C`(v0, v2, v1, v3) @signature `Ln/a/a/c/g;.C:(I[II[I)I` @kind static;
  #L352842.  v2:= temp;
  #L352844.  if v2 != 0 then goto L352864;
  #L352848.  v2:= 5I;
  #L35284a.  v2:= v3[v2];
  #L35284e.  v0:= -1I;
  #L352850.  if v2 != v0 then goto L35286a;
  #L352854.  v2:= `@@n.a.a.a.t.b.f.a` @type ^`int`[] @kind object;
  #L352858.  call temp:= `l`(v3, v2) @signature `Ln/a/a/c/b;.l:([I[I)Z` @kind static;
  #L35285e.  v2:= temp;
  #L352860.  if v2 == 0 then goto L35286a;
  #L352864.  call `c`(v3) @signature `Ln/a/a/a/t/b/f;.c:([I)V` @kind static;
  #L35286a.  return @kind void;
}

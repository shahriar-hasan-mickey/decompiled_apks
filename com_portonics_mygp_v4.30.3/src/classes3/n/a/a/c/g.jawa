record `n.a.a.c.g` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
procedure `int` `A`(`int` v1 , `int`[] v2 @kind object, `int` v3 ) @signature `Ln/a/a/c/g;.A:(I[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L35ec9c.  v1:= v1 + -1;
  #L35eca0.  if v1 < 0 then goto L35ecb0;
  #L35eca4.  v0:= v2[v1];
  #L35eca8.  v2[v1]:= v3;
  #L35ecac.  v3:= v0;
  #L35ecae.  goto L35ec9c;
  #L35ecb0.  return v3;
}
procedure `int` `B`(`int` v4 , `int`[] v5 @kind object, `int` v6 , `int` v7 , `int`[] v8 @kind object, `int` v9 ) @signature `Ln/a/a/c/g;.B:(I[III[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35ecc4.  v0:= 0I;
  #L35ecc6.  if v0 >= v4 then goto L35ecec;
  #L35ecca.  v1:= v6 + v0 @kind int;
  #L35ecce.  v1:= v5[v1];
  #L35ecd2.  v2:= v9 + v0 @kind int;
  #L35ecd6.  v3:= v1 ^< 1;
  #L35ecda.  v7:= v7 ^>> 31;
  #L35ecde.  v7:= v7 ^| v3 @kind int;
  #L35ece0.  v8[v2]:= v7;
  #L35ece4.  v0:= v0 + 1;
  #L35ece8.  v7:= v1;
  #L35ecea.  goto L35ecc6;
  #L35ecec.  v4:= v7 ^>> 31;
  #L35ecf0.  return v4;
}
procedure `int` `C`(`int` v3 , `int`[] v4 @kind object, `int` v5 , `int`[] v6 @kind object) @signature `Ln/a/a/c/g;.C:(I[II[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35ed04.  v0:= 0I;
  #L35ed06.  if v0 >= v3 then goto L35ed24;
  #L35ed0a.  v1:= v4[v0];
  #L35ed0e.  v2:= v1 ^< 1;
  #L35ed12.  v5:= v5 ^>> 31;
  #L35ed16.  v5:= v5 ^| v2 @kind int;
  #L35ed18.  v6[v0]:= v5;
  #L35ed1c.  v0:= v0 + 1;
  #L35ed20.  v5:= v1;
  #L35ed22.  goto L35ed06;
  #L35ed24.  v3:= v5 ^>> 31;
  #L35ed28.  return v3;
}
procedure `int` `D`(`int` v4 , `int`[] v5 @kind object, `int` v6 , `int` v7 ) @signature `Ln/a/a/c/g;.D:(I[III)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35ed3c.  v0:= 0I;
  #L35ed3e.  if v0 >= v4 then goto L35ed5c;
  #L35ed42.  v1:= v5[v0];
  #L35ed46.  v2:= v1 ^< v6 @kind int;
  #L35ed4a.  v3:= -v6 @kind int;
  #L35ed4c.  v7:= v7 ^>> v3 @kind int;
  #L35ed4e.  v7:= v7 ^| v2 @kind int;
  #L35ed50.  v5[v0]:= v7;
  #L35ed54.  v0:= v0 + 1;
  #L35ed58.  v7:= v1;
  #L35ed5a.  goto L35ed3e;
  #L35ed5c.  v4:= -v6 @kind int;
  #L35ed5e.  v4:= v7 ^>> v4 @kind int;
  #L35ed62.  return v4;
}
procedure `int` `E`(`int` v4 , `int`[] v5 @kind object, `int` v6 , `int` v7 , `int`[] v8 @kind object) @signature `Ln/a/a/c/g;.E:(I[III[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35ed74.  v0:= 0I;
  #L35ed76.  if v0 >= v4 then goto L35ed94;
  #L35ed7a.  v1:= v5[v0];
  #L35ed7e.  v2:= v1 ^< v6 @kind int;
  #L35ed82.  v3:= -v6 @kind int;
  #L35ed84.  v7:= v7 ^>> v3 @kind int;
  #L35ed86.  v7:= v7 ^| v2 @kind int;
  #L35ed88.  v8[v0]:= v7;
  #L35ed8c.  v0:= v0 + 1;
  #L35ed90.  v7:= v1;
  #L35ed92.  goto L35ed76;
  #L35ed94.  v4:= -v6 @kind int;
  #L35ed96.  v4:= v7 ^>> v4 @kind int;
  #L35ed9a.  return v4;
}
procedure `int` `F`(`int` v9 , `int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Ln/a/a/c/g;.F:(I[I[I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L35edac.  v0:= 0L;
  #L35edb0.  v2:= 0I;
  #L35edb2.  if v2 >= v9 then goto L35ede6;
  #L35edb6.  v3:= v10[v2];
  #L35edba.  v3:= (`long`) v3 @kind i2l;
  #L35edbc.  v5:= 4294967295L;
  #L35edc6.  v3:= v3 ^& v5 @kind long;
  #L35edc8.  v7:= v11[v2];
  #L35edcc.  v7:= (`long`) v7 @kind i2l;
  #L35edce.  v5:= v5 ^& v7 @kind long;
  #L35edd0.  v3:= v3 - v5 @kind long;
  #L35edd2.  v0:= v0 + v3 @kind long;
  #L35edd4.  v3:= (`int`) v0 @kind l2i;
  #L35edd6.  v12[v2]:= v3;
  #L35edda.  v3:= 32I;
  #L35edde.  v0:= v0 ^> v3 @kind long;
  #L35ede0.  v2:= v2 + 1;
  #L35ede4.  goto L35edb2;
  #L35ede6.  v9:= (`int`) v0 @kind l2i;
  #L35ede8.  return v9;
}
procedure `int` `G`(`int` v8 , `int` v9 , `int`[] v10 @kind object) @signature `Ln/a/a/c/g;.G:(II[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L35edfc.  v0:= 0I;
  #L35edfe.  v1:= v10[v0];
  #L35ee02.  v1:= (`long`) v1 @kind i2l;
  #L35ee04.  v3:= 4294967295L;
  #L35ee0e.  v1:= v1 ^& v3 @kind long;
  #L35ee10.  v5:= (`long`) v9 @kind i2l;
  #L35ee12.  v5:= v5 ^& v3 @kind long;
  #L35ee14.  v1:= v1 - v5 @kind long;
  #L35ee16.  v9:= (`int`) v1 @kind l2i;
  #L35ee18.  v10[v0]:= v9;
  #L35ee1c.  v9:= 32I;
  #L35ee20.  v1:= v1 ^> v9 @kind long;
  #L35ee22.  v5:= 1I;
  #L35ee24.  v6:= v10[v5];
  #L35ee28.  v6:= (`long`) v6 @kind i2l;
  #L35ee2a.  v3:= v3 ^& v6 @kind long;
  #L35ee2c.  v6:= 1L;
  #L35ee30.  v3:= v3 - v6 @kind long;
  #L35ee32.  v1:= v1 + v3 @kind long;
  #L35ee34.  v3:= (`int`) v1 @kind l2i;
  #L35ee36.  v10[v5]:= v3;
  #L35ee3a.  v1:= v1 ^> v9 @kind long;
  #L35ee3c.  v3:= 0L;
  #L35ee40.  v9:= lcmp(v1, v3);
  #L35ee44.  if v9 != 0 then goto L35ee4a;
  #L35ee48.  goto L35ee54;
  #L35ee4a.  v9:= 2I;
  #L35ee4c.  call temp:= `k`(v8, v10, v9) @signature `Ln/a/a/c/g;.k:(I[II)I` @kind static;
  #L35ee52.  v0:= temp;
  #L35ee54.  return v0;
}
procedure `int` `H`(`int` v10 , `int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Ln/a/a/c/g;.H:(I[II[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L35ee68.  v0:= 0L;
  #L35ee6c.  v2:= 0I;
  #L35ee6e.  if v2 >= v10 then goto L35eeaa;
  #L35ee72.  v3:= v14 + v2 @kind int;
  #L35ee76.  v4:= v13[v3];
  #L35ee7a.  v4:= (`long`) v4 @kind i2l;
  #L35ee7c.  v6:= 4294967295L;
  #L35ee86.  v4:= v4 ^& v6 @kind long;
  #L35ee88.  v8:= v12 + v2 @kind int;
  #L35ee8c.  v8:= v11[v8];
  #L35ee90.  v8:= (`long`) v8 @kind i2l;
  #L35ee92.  v6:= v6 ^& v8 @kind long;
  #L35ee94.  v4:= v4 - v6 @kind long;
  #L35ee96.  v0:= v0 + v4 @kind long;
  #L35ee98.  v4:= (`int`) v0 @kind l2i;
  #L35ee9a.  v13[v3]:= v4;
  #L35ee9e.  v3:= 32I;
  #L35eea2.  v0:= v0 ^> v3 @kind long;
  #L35eea4.  v2:= v2 + 1;
  #L35eea8.  goto L35ee6e;
  #L35eeaa.  v10:= (`int`) v0 @kind l2i;
  #L35eeac.  return v10;
}
procedure `int` `I`(`int` v9 , `int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Ln/a/a/c/g;.I:(I[I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L35eec0.  v0:= 0L;
  #L35eec4.  v2:= 0I;
  #L35eec6.  if v2 >= v9 then goto L35eefa;
  #L35eeca.  v3:= v11[v2];
  #L35eece.  v3:= (`long`) v3 @kind i2l;
  #L35eed0.  v5:= 4294967295L;
  #L35eeda.  v3:= v3 ^& v5 @kind long;
  #L35eedc.  v7:= v10[v2];
  #L35eee0.  v7:= (`long`) v7 @kind i2l;
  #L35eee2.  v5:= v5 ^& v7 @kind long;
  #L35eee4.  v3:= v3 - v5 @kind long;
  #L35eee6.  v0:= v0 + v3 @kind long;
  #L35eee8.  v3:= (`int`) v0 @kind l2i;
  #L35eeea.  v11[v2]:= v3;
  #L35eeee.  v3:= 32I;
  #L35eef2.  v0:= v0 ^> v3 @kind long;
  #L35eef4.  v2:= v2 + 1;
  #L35eef8.  goto L35eec6;
  #L35eefa.  v9:= (`int`) v0 @kind l2i;
  #L35eefc.  return v9;
}
procedure `java.math.BigInteger` `J`(`int` v4 , `int`[] v5 @kind object) @signature `Ln/a/a/c/g;.J:(I[I)Ljava/math/BigInteger;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35efc0.  v0:= v4 ^< 2;
  #L35efc4.  v0:= new `byte`[v0];
  #L35efc8.  v1:= 0I;
  #L35efca.  if v1 >= v4 then goto L35efec;
  #L35efce.  v2:= v5[v1];
  #L35efd2.  if v2 == 0 then goto L35efe6;
  #L35efd6.  v3:= v4 + -1;
  #L35efda.  v3:= v3 - v1 @kind int;
  #L35efdc.  v3:= v3 ^< 2;
  #L35efe0.  call `a`(v2, v0, v3) @signature `Lorg/bouncycastle/util/d;.a:(I[BI)V` @kind static;
  #L35efe6.  v1:= v1 + 1;
  #L35efea.  goto L35efca;
  #L35efec.  v4:= new `java.math.BigInteger`;
  #L35eff0.  v5:= 1I;
  #L35eff2.  call `<init>`(v4, v5, v0) @signature `Ljava/math/BigInteger;.<init>:(I[B)V` @kind direct;
  #L35eff8.  return v4 @kind object;
}
procedure `void` `K`(`int` v2 , `int`[] v3 @kind object) @signature `Ln/a/a/c/g;.K:(I[I)V` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35f00c.  v0:= 0I;
  #L35f00e.  v1:= 0I;
  #L35f010.  if v1 >= v2 then goto L35f01e;
  #L35f014.  v3[v1]:= v0;
  #L35f018.  v1:= v1 + 1;
  #L35f01c.  goto L35f010;
  #L35f01e.  return @kind void;
}
procedure `int` `a`(`int` v9 , `int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Ln/a/a/c/g;.a:(I[I[I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L35e738.  v0:= 0L;
  #L35e73c.  v2:= 0I;
  #L35e73e.  if v2 >= v9 then goto L35e772;
  #L35e742.  v3:= v10[v2];
  #L35e746.  v3:= (`long`) v3 @kind i2l;
  #L35e748.  v5:= 4294967295L;
  #L35e752.  v3:= v3 ^& v5 @kind long;
  #L35e754.  v7:= v11[v2];
  #L35e758.  v7:= (`long`) v7 @kind i2l;
  #L35e75a.  v5:= v5 ^& v7 @kind long;
  #L35e75c.  v3:= v3 + v5 @kind long;
  #L35e75e.  v0:= v0 + v3 @kind long;
  #L35e760.  v3:= (`int`) v0 @kind l2i;
  #L35e762.  v12[v2]:= v3;
  #L35e766.  v3:= 32I;
  #L35e76a.  v0:= v0 ^>> v3 @kind long;
  #L35e76c.  v2:= v2 + 1;
  #L35e770.  goto L35e73e;
  #L35e772.  v9:= (`int`) v0 @kind l2i;
  #L35e774.  return v9;
}
procedure `int` `b`(`int` v8 , `int` v9 , `int`[] v10 @kind object) @signature `Ln/a/a/c/g;.b:(II[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L35e788.  v0:= 0I;
  #L35e78a.  v1:= v10[v0];
  #L35e78e.  v1:= (`long`) v1 @kind i2l;
  #L35e790.  v3:= 4294967295L;
  #L35e79a.  v1:= v1 ^& v3 @kind long;
  #L35e79c.  v5:= (`long`) v9 @kind i2l;
  #L35e79e.  v5:= v5 ^& v3 @kind long;
  #L35e7a0.  v1:= v1 + v5 @kind long;
  #L35e7a2.  v9:= (`int`) v1 @kind l2i;
  #L35e7a4.  v10[v0]:= v9;
  #L35e7a8.  v9:= 32I;
  #L35e7ac.  v1:= v1 ^>> v9 @kind long;
  #L35e7ae.  v5:= 1I;
  #L35e7b0.  v6:= v10[v5];
  #L35e7b4.  v6:= (`long`) v6 @kind i2l;
  #L35e7b6.  v3:= v3 ^& v6 @kind long;
  #L35e7b8.  v6:= 1L;
  #L35e7bc.  v3:= v3 + v6 @kind long;
  #L35e7be.  v1:= v1 + v3 @kind long;
  #L35e7c0.  v3:= (`int`) v1 @kind l2i;
  #L35e7c2.  v10[v5]:= v3;
  #L35e7c6.  v1:= v1 ^>> v9 @kind long;
  #L35e7c8.  v3:= 0L;
  #L35e7cc.  v9:= lcmp(v1, v3);
  #L35e7d0.  if v9 != 0 then goto L35e7d6;
  #L35e7d4.  goto L35e7e0;
  #L35e7d6.  v9:= 2I;
  #L35e7d8.  call temp:= `r`(v8, v10, v9) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L35e7de.  v0:= temp;
  #L35e7e0.  return v0;
}
procedure `int` `c`(`int` v9 , `int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Ln/a/a/c/g;.c:(I[I[I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L35e7f4.  v0:= 0L;
  #L35e7f8.  v2:= 0I;
  #L35e7fa.  if v2 >= v9 then goto L35e838;
  #L35e7fe.  v3:= v10[v2];
  #L35e802.  v3:= (`long`) v3 @kind i2l;
  #L35e804.  v5:= 4294967295L;
  #L35e80e.  v3:= v3 ^& v5 @kind long;
  #L35e810.  v7:= v11[v2];
  #L35e814.  v7:= (`long`) v7 @kind i2l;
  #L35e816.  v7:= v7 ^& v5 @kind long;
  #L35e818.  v3:= v3 + v7 @kind long;
  #L35e81a.  v7:= v12[v2];
  #L35e81e.  v7:= (`long`) v7 @kind i2l;
  #L35e820.  v5:= v5 ^& v7 @kind long;
  #L35e822.  v3:= v3 + v5 @kind long;
  #L35e824.  v0:= v0 + v3 @kind long;
  #L35e826.  v3:= (`int`) v0 @kind l2i;
  #L35e828.  v12[v2]:= v3;
  #L35e82c.  v3:= 32I;
  #L35e830.  v0:= v0 ^>> v3 @kind long;
  #L35e832.  v2:= v2 + 1;
  #L35e836.  goto L35e7fa;
  #L35e838.  v9:= (`int`) v0 @kind l2i;
  #L35e83a.  return v9;
}
procedure `int` `d`(`int` v10 , `int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Ln/a/a/c/g;.d:(I[II[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;

  #L35e84c.  v0:= 0L;
  #L35e850.  v2:= 0I;
  #L35e852.  if v2 >= v10 then goto L35e88e;
  #L35e856.  v3:= v12 + v2 @kind int;
  #L35e85a.  v3:= v11[v3];
  #L35e85e.  v3:= (`long`) v3 @kind i2l;
  #L35e860.  v5:= 4294967295L;
  #L35e86a.  v3:= v3 ^& v5 @kind long;
  #L35e86c.  v7:= v14 + v2 @kind int;
  #L35e870.  v8:= v13[v7];
  #L35e874.  v8:= (`long`) v8 @kind i2l;
  #L35e876.  v5:= v5 ^& v8 @kind long;
  #L35e878.  v3:= v3 + v5 @kind long;
  #L35e87a.  v0:= v0 + v3 @kind long;
  #L35e87c.  v3:= (`int`) v0 @kind l2i;
  #L35e87e.  v13[v7]:= v3;
  #L35e882.  v3:= 32I;
  #L35e886.  v0:= v0 ^>> v3 @kind long;
  #L35e888.  v2:= v2 + 1;
  #L35e88c.  goto L35e852;
  #L35e88e.  v10:= (`int`) v0 @kind l2i;
  #L35e890.  return v10;
}
procedure `int` `e`(`int` v9 , `int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Ln/a/a/c/g;.e:(I[I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L35e8a4.  v0:= 0L;
  #L35e8a8.  v2:= 0I;
  #L35e8aa.  if v2 >= v9 then goto L35e8de;
  #L35e8ae.  v3:= v10[v2];
  #L35e8b2.  v3:= (`long`) v3 @kind i2l;
  #L35e8b4.  v5:= 4294967295L;
  #L35e8be.  v3:= v3 ^& v5 @kind long;
  #L35e8c0.  v7:= v11[v2];
  #L35e8c4.  v7:= (`long`) v7 @kind i2l;
  #L35e8c6.  v5:= v5 ^& v7 @kind long;
  #L35e8c8.  v3:= v3 + v5 @kind long;
  #L35e8ca.  v0:= v0 + v3 @kind long;
  #L35e8cc.  v3:= (`int`) v0 @kind l2i;
  #L35e8ce.  v11[v2]:= v3;
  #L35e8d2.  v3:= 32I;
  #L35e8d6.  v0:= v0 ^>> v3 @kind long;
  #L35e8d8.  v2:= v2 + 1;
  #L35e8dc.  goto L35e8aa;
  #L35e8de.  v9:= (`int`) v0 @kind l2i;
  #L35e8e0.  return v9;
}
procedure `int` `f`(`int` v6 , `int` v7 , `int`[] v8 @kind object, `int` v9 ) @signature `Ln/a/a/c/g;.f:(II[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L35e8f4.  v0:= (`long`) v7 @kind i2l;
  #L35e8f6.  v2:= 4294967295L;
  #L35e900.  v0:= v0 ^& v2 @kind long;
  #L35e902.  v7:= v8[v9];
  #L35e906.  v4:= (`long`) v7 @kind i2l;
  #L35e908.  v2:= v2 ^& v4 @kind long;
  #L35e90a.  v0:= v0 + v2 @kind long;
  #L35e90c.  v7:= (`int`) v0 @kind l2i;
  #L35e90e.  v8[v9]:= v7;
  #L35e912.  v7:= 32I;
  #L35e916.  v0:= v0 ^>> v7 @kind long;
  #L35e918.  v2:= 0L;
  #L35e91c.  v7:= lcmp(v0, v2);
  #L35e920.  if v7 != 0 then goto L35e928;
  #L35e924.  v6:= 0I;
  #L35e926.  goto L35e934;
  #L35e928.  v9:= v9 + 1;
  #L35e92c.  call temp:= `r`(v6, v8, v9) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L35e932.  v6:= temp;
  #L35e934.  return v6;
}
procedure `int` `g`(`int` v6 , `int` v7 , `int`[] v8 @kind object) @signature `Ln/a/a/c/g;.g:(II[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L35e948.  v0:= (`long`) v7 @kind i2l;
  #L35e94a.  v2:= 4294967295L;
  #L35e954.  v0:= v0 ^& v2 @kind long;
  #L35e956.  v7:= 0I;
  #L35e958.  v4:= v8[v7];
  #L35e95c.  v4:= (`long`) v4 @kind i2l;
  #L35e95e.  v2:= v2 ^& v4 @kind long;
  #L35e960.  v0:= v0 + v2 @kind long;
  #L35e962.  v2:= (`int`) v0 @kind l2i;
  #L35e964.  v8[v7]:= v2;
  #L35e968.  v2:= 32I;
  #L35e96c.  v0:= v0 ^>> v2 @kind long;
  #L35e96e.  v2:= 0L;
  #L35e972.  v4:= lcmp(v0, v2);
  #L35e976.  if v4 != 0 then goto L35e97c;
  #L35e97a.  goto L35e986;
  #L35e97c.  v7:= 1I;
  #L35e97e.  call temp:= `r`(v6, v8, v7) @signature `Ln/a/a/c/g;.r:(I[II)I` @kind static;
  #L35e984.  v7:= temp;
  #L35e986.  return v7;
}
procedure `int`[] `h`(`int` v2 , `int`[] v3 @kind object) @signature `Ln/a/a/c/g;.h:(I[I)[I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35ef10.  v0:= new `int`[v2];
  #L35ef14.  v1:= 0I;
  #L35ef16.  call `arraycopy`(v3, v1, v0, v1, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L35ef1c.  return v0 @kind object;
}
procedure `int`[] `i`(`int` v0 ) @signature `Ln/a/a/c/g;.i:(I)[I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L35ef30.  v0:= new `int`[v0];
  #L35ef34.  return v0 @kind object;
}
procedure `int` `j`(`int` v4 , `int`[] v5 @kind object) @signature `Ln/a/a/c/g;.j:(I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35e998.  v0:= 0I;
  #L35e99a.  v1:= 0I;
  #L35e99c.  v2:= -1I;
  #L35e99e.  if v1 >= v4 then goto L35e9ba;
  #L35e9a2.  v3:= v5[v1];
  #L35e9a6.  v3:= v3 + -1;
  #L35e9aa.  v5[v1]:= v3;
  #L35e9ae.  if v3 == v2 then goto L35e9b4;
  #L35e9b2.  return v0;
  #L35e9b4.  v1:= v1 + 1;
  #L35e9b8.  goto L35e99c;
  #L35e9ba.  return v2;
}
procedure `int` `k`(`int` v2 , `int`[] v3 @kind object, `int` v4 ) @signature `Ln/a/a/c/g;.k:(I[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35e9cc.  v0:= -1I;
  #L35e9ce.  if v4 >= v2 then goto L35e9ec;
  #L35e9d2.  v1:= v3[v4];
  #L35e9d6.  v1:= v1 + -1;
  #L35e9da.  v3[v4]:= v1;
  #L35e9de.  if v1 == v0 then goto L35e9e6;
  #L35e9e2.  v2:= 0I;
  #L35e9e4.  return v2;
  #L35e9e6.  v4:= v4 + 1;
  #L35e9ea.  goto L35e9cc;
  #L35e9ec.  return v0;
}
procedure `boolean` `l`(`int` v3 , `int`[] v4 @kind object, `int`[] v5 @kind object) @signature `Ln/a/a/c/g;.l:(I[I[I)Z` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35e664.  v0:= 1I;
  #L35e666.  v3:= v3 - v0 @kind int;
  #L35e668.  if v3 < 0 then goto L35e682;
  #L35e66c.  v1:= v4[v3];
  #L35e670.  v2:= v5[v3];
  #L35e674.  if v1 == v2 then goto L35e67c;
  #L35e678.  v3:= 0I;
  #L35e67a.  return v3;
  #L35e67c.  v3:= v3 + -1;
  #L35e680.  goto L35e668;
  #L35e682.  return v0;
}
procedure `int`[] `m`(`int` v3 , `java.math.BigInteger` v4 @kind object) @signature `Ln/a/a/c/g;.m:(ILjava/math/BigInteger;)[I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35ef48.  call temp:= `signum`(v4) @signature `Ljava/math/BigInteger;.signum:()I` @kind virtual;
  #L35ef4e.  v0:= temp;
  #L35ef50.  if v0 < 0 then goto L35efa0;
  #L35ef54.  call temp:= `bitLength`(v4) @signature `Ljava/math/BigInteger;.bitLength:()I` @kind virtual;
  #L35ef5a.  v0:= temp;
  #L35ef5c.  if v0 > v3 then goto L35efa0;
  #L35ef60.  v3:= v3 + 31;
  #L35ef64.  v3:= v3 ^> 5;
  #L35ef68.  call temp:= `i`(v3) @signature `Ln/a/a/c/g;.i:(I)[I` @kind static;
  #L35ef6e.  v3:= temp @kind object;
  #L35ef70.  v0:= 0I;
  #L35ef72.  call temp:= `signum`(v4) @signature `Ljava/math/BigInteger;.signum:()I` @kind virtual;
  #L35ef78.  v1:= temp;
  #L35ef7a.  if v1 == 0 then goto L35ef9e;
  #L35ef7e.  v1:= v0 + 1;
  #L35ef82.  call temp:= `intValue`(v4) @signature `Ljava/math/BigInteger;.intValue:()I` @kind virtual;
  #L35ef88.  v2:= temp;
  #L35ef8a.  v3[v0]:= v2;
  #L35ef8e.  v0:= 32I;
  #L35ef92.  call temp:= `shiftRight`(v4, v0) @signature `Ljava/math/BigInteger;.shiftRight:(I)Ljava/math/BigInteger;` @kind virtual;
  #L35ef98.  v4:= temp @kind object;
  #L35ef9a.  v0:= v1;
  #L35ef9c.  goto L35ef72;
  #L35ef9e.  return v3 @kind object;
  #L35efa0.  v3:= new `java.lang.IllegalArgumentException`;
  #L35efa4.  call `<init>`(v3) @signature `Ljava/lang/IllegalArgumentException;.<init>:()V` @kind direct;
  #L35efaa.  goto L35efae;
  #L35efac.  throw v3;
  #L35efae.  goto L35efac;
}
procedure `int` `n`(`int`[] v3 @kind object, `int` v4 ) @signature `Ln/a/a/c/g;.n:([II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35ea00.  v0:= 0I;
  #L35ea02.  if v4 != 0 then goto L35ea10;
  #L35ea06.  v3:= v3[v0];
  #L35ea0a.  v3:= v3 ^& 1;
  #L35ea0e.  return v3;
  #L35ea10.  v1:= v4 ^> 5;
  #L35ea14.  if v1 < 0 then goto L35ea2c;
  #L35ea18.  v2:= length @variable v3;
  #L35ea1a.  if v1 < v2 then goto L35ea20;
  #L35ea1e.  goto L35ea2c;
  #L35ea20.  v4:= v4 ^& 31;
  #L35ea24.  v3:= v3[v1];
  #L35ea28.  v3:= v3 ^>> v4 @kind int;
  #L35ea2a.  goto L35ea0a;
  #L35ea2c.  return v0;
}
procedure `boolean` `o`(`int` v4 , `int`[] v5 @kind object, `int`[] v6 @kind object) @signature `Ln/a/a/c/g;.o:(I[I[I)Z` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35e694.  v0:= 1I;
  #L35e696.  v4:= v4 - v0 @kind int;
  #L35e698.  if v4 < 0 then goto L35e6c0;
  #L35e69c.  v1:= v5[v4];
  #L35e6a0.  v2:= -2147483648I;
  #L35e6a4.  v1:= v1 ^~ v2 @kind int;
  #L35e6a6.  v3:= v6[v4];
  #L35e6aa.  v2:= v2 ^~ v3 @kind int;
  #L35e6ac.  if v1 >= v2 then goto L35e6b4;
  #L35e6b0.  v4:= 0I;
  #L35e6b2.  return v4;
  #L35e6b4.  if v1 <= v2 then goto L35e6ba;
  #L35e6b8.  return v0;
  #L35e6ba.  v4:= v4 + -1;
  #L35e6be.  goto L35e698;
  #L35e6c0.  return v0;
}
procedure `int` `p`(`int` v4 , `int`[] v5 @kind object) @signature `Ln/a/a/c/g;.p:(I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35ea40.  v0:= 0I;
  #L35ea42.  v1:= 0I;
  #L35ea44.  v2:= 1I;
  #L35ea46.  if v1 >= v4 then goto L35ea60;
  #L35ea4a.  v3:= v5[v1];
  #L35ea4e.  v3:= v3 + v2 @kind int;
  #L35ea50.  v5[v1]:= v3;
  #L35ea54.  if v3 == 0 then goto L35ea5a;
  #L35ea58.  return v0;
  #L35ea5a.  v1:= v1 + 1;
  #L35ea5e.  goto L35ea44;
  #L35ea60.  return v2;
}
procedure `int` `q`(`int` v4 , `int`[] v5 @kind object, `int`[] v6 @kind object) @signature `Ln/a/a/c/g;.q:(I[I[I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35ea74.  v0:= 0I;
  #L35ea76.  v1:= 0I;
  #L35ea78.  v2:= 1I;
  #L35ea7a.  if v1 >= v4 then goto L35eaa4;
  #L35ea7e.  v3:= v5[v1];
  #L35ea82.  v3:= v3 + v2 @kind int;
  #L35ea84.  v6[v1]:= v3;
  #L35ea88.  v1:= v1 + 1;
  #L35ea8c.  if v3 == 0 then goto L35ea78;
  #L35ea90.  if v1 >= v4 then goto L35eaa2;
  #L35ea94.  v2:= v5[v1];
  #L35ea98.  v6[v1]:= v2;
  #L35ea9c.  v1:= v1 + 1;
  #L35eaa0.  goto L35ea90;
  #L35eaa2.  return v0;
  #L35eaa4.  return v2;
}
procedure `int` `r`(`int` v2 , `int`[] v3 @kind object, `int` v4 ) @signature `Ln/a/a/c/g;.r:(I[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35eab8.  v0:= 1I;
  #L35eaba.  if v4 >= v2 then goto L35ead6;
  #L35eabe.  v1:= v3[v4];
  #L35eac2.  v1:= v1 + v0 @kind int;
  #L35eac4.  v3[v4]:= v1;
  #L35eac8.  if v1 == 0 then goto L35ead0;
  #L35eacc.  v2:= 0I;
  #L35eace.  return v2;
  #L35ead0.  v4:= v4 + 1;
  #L35ead4.  goto L35eab8;
  #L35ead6.  return v0;
}
procedure `int` `s`(`int` v3 , `int`[] v4 @kind object, `int` v5 , `int` v6 ) @signature `Ln/a/a/c/g;.s:(I[III)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35eae8.  v0:= 1I;
  #L35eaea.  if v6 >= v3 then goto L35eb0a;
  #L35eaee.  v1:= v5 + v6 @kind int;
  #L35eaf2.  v2:= v4[v1];
  #L35eaf6.  v2:= v2 + v0 @kind int;
  #L35eaf8.  v4[v1]:= v2;
  #L35eafc.  if v2 == 0 then goto L35eb04;
  #L35eb00.  v3:= 0I;
  #L35eb02.  return v3;
  #L35eb04.  v6:= v6 + 1;
  #L35eb08.  goto L35eae8;
  #L35eb0a.  return v0;
}
procedure `boolean` `t`(`int` v4 , `int`[] v5 @kind object) @signature `Ln/a/a/c/g;.t:(I[I)Z` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35e6d4.  v0:= 0I;
  #L35e6d6.  v1:= v5[v0];
  #L35e6da.  v2:= 1I;
  #L35e6dc.  if v1 == v2 then goto L35e6e2;
  #L35e6e0.  return v0;
  #L35e6e2.  v1:= 1I;
  #L35e6e4.  if v1 >= v4 then goto L35e6f8;
  #L35e6e8.  v3:= v5[v1];
  #L35e6ec.  if v3 == 0 then goto L35e6f2;
  #L35e6f0.  return v0;
  #L35e6f2.  v1:= v1 + 1;
  #L35e6f6.  goto L35e6e4;
  #L35e6f8.  return v2;
}
procedure `boolean` `u`(`int` v3 , `int`[] v4 @kind object) @signature `Ln/a/a/c/g;.u:(I[I)Z` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35e70c.  v0:= 0I;
  #L35e70e.  v1:= 0I;
  #L35e710.  if v1 >= v3 then goto L35e724;
  #L35e714.  v2:= v4[v1];
  #L35e718.  if v2 == 0 then goto L35e71e;
  #L35e71c.  return v0;
  #L35e71e.  v1:= v1 + 1;
  #L35e722.  goto L35e710;
  #L35e724.  v3:= 1I;
  #L35e726.  return v3;
}
procedure `int` `v`(`int` v14 , `int` v15 , `int`[] v16 @kind object, `int` v17 , `int`[] v18 @kind object, `int`[] v19 @kind object, `int` v20 ) @signature `Ln/a/a/c/g;.v:(II[II[I[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;

  #L35eb1c.  v0:= v15;
  #L35eb1e.  v0:= (`long`) v0 @kind i2l;
  #L35eb20.  v2:= 4294967295L;
  #L35eb2a.  v0:= v0 ^& v2 @kind long;
  #L35eb2c.  v4:= v17;
  #L35eb30.  v4:= (`long`) v4 @kind i2l;
  #L35eb32.  v4:= v4 ^& v2 @kind long;
  #L35eb34.  v6:= 0L;
  #L35eb38.  v8:= 0I;
  #L35eb3a.  v9:= v16[v8];
  #L35eb3e.  v9:= (`long`) v9 @kind i2l;
  #L35eb40.  v9:= v9 ^& v2 @kind long;
  #L35eb42.  v9:= v9 * v0 @kind long;
  #L35eb46.  v11:= v18[v8];
  #L35eb4a.  v11:= (`long`) v11 @kind i2l;
  #L35eb4c.  v11:= v11 ^& v2 @kind long;
  #L35eb4e.  v11:= v11 * v4 @kind long;
  #L35eb52.  v9:= v9 + v11 @kind long;
  #L35eb54.  v11:= v20 + v8 @kind int;
  #L35eb58.  v12:= v19[v11];
  #L35eb5c.  v12:= (`long`) v12 @kind i2l;
  #L35eb5e.  v12:= v12 ^& v2 @kind long;
  #L35eb60.  v9:= v9 + v12 @kind long;
  #L35eb62.  v6:= v6 + v9 @kind long;
  #L35eb64.  v9:= (`int`) v6 @kind l2i;
  #L35eb66.  v19[v11]:= v9;
  #L35eb6a.  v9:= 32I;
  #L35eb6e.  v6:= v6 ^>> v9 @kind long;
  #L35eb70.  v8:= v8 + 1;
  #L35eb74.  v9:= v14;
  #L35eb76.  if v8 < v9 then goto L35eb3a;
  #L35eb7a.  v0:= (`int`) v6 @kind l2i;
  #L35eb7c.  return v0;
}
procedure `int` `w`(`int` v12 , `int` v13 , `int`[] v14 @kind object, `int` v15 , `int`[] v16 @kind object, `int` v17 ) @signature `Ln/a/a/c/g;.w:(II[II[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;

  #L35eb90.  v0:= v13;
  #L35eb92.  v0:= (`long`) v0 @kind i2l;
  #L35eb94.  v2:= 4294967295L;
  #L35eb9e.  v0:= v0 ^& v2 @kind long;
  #L35eba0.  v4:= 0L;
  #L35eba4.  v6:= 0I;
  #L35eba6.  v7:= v15 + v6 @kind int;
  #L35ebaa.  v7:= v14[v7];
  #L35ebae.  v7:= (`long`) v7 @kind i2l;
  #L35ebb0.  v7:= v7 ^& v2 @kind long;
  #L35ebb2.  v7:= v7 * v0 @kind long;
  #L35ebb6.  v9:= v17 + v6 @kind int;
  #L35ebba.  v10:= v16[v9];
  #L35ebbe.  v10:= (`long`) v10 @kind i2l;
  #L35ebc0.  v10:= v10 ^& v2 @kind long;
  #L35ebc2.  v7:= v7 + v10 @kind long;
  #L35ebc4.  v4:= v4 + v7 @kind long;
  #L35ebc6.  v7:= (`int`) v4 @kind l2i;
  #L35ebc8.  v16[v9]:= v7;
  #L35ebcc.  v7:= 32I;
  #L35ebd0.  v4:= v4 ^>> v7 @kind long;
  #L35ebd2.  v6:= v6 + 1;
  #L35ebd6.  v7:= v12;
  #L35ebd8.  if v6 < v7 then goto L35eba6;
  #L35ebdc.  v0:= (`int`) v4 @kind l2i;
  #L35ebde.  return v0;
}
procedure `int` `x`(`int` v2 , `int`[] v3 @kind object, `int` v4 ) @signature `Ln/a/a/c/g;.x:(I[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L35ebf0.  v2:= v2 + -1;
  #L35ebf4.  if v2 < 0 then goto L35ec0e;
  #L35ebf8.  v0:= v3[v2];
  #L35ebfc.  v1:= v0 ^>> 1;
  #L35ec00.  v4:= v4 ^< 31;
  #L35ec04.  v4:= v4 ^| v1 @kind int;
  #L35ec06.  v3[v2]:= v4;
  #L35ec0a.  v4:= v0;
  #L35ec0c.  goto L35ebf0;
  #L35ec0e.  v2:= v4 ^< 31;
  #L35ec12.  return v2;
}
procedure `int` `y`(`int` v3 , `int`[] v4 @kind object, `int` v5 , `int` v6 ) @signature `Ln/a/a/c/g;.y:(I[III)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L35ec24.  v3:= v3 + -1;
  #L35ec28.  if v3 < 0 then goto L35ec42;
  #L35ec2c.  v0:= v4[v3];
  #L35ec30.  v1:= v0 ^>> v5 @kind int;
  #L35ec34.  v2:= -v5 @kind int;
  #L35ec36.  v6:= v6 ^< v2 @kind int;
  #L35ec38.  v6:= v6 ^| v1 @kind int;
  #L35ec3a.  v4[v3]:= v6;
  #L35ec3e.  v6:= v0;
  #L35ec40.  goto L35ec24;
  #L35ec42.  v3:= -v5 @kind int;
  #L35ec44.  v3:= v6 ^< v3 @kind int;
  #L35ec48.  return v3;
}
procedure `int` `z`(`int` v4 , `int`[] v5 @kind object, `int` v6 , `int` v7 , `int` v8 , `int`[] v9 @kind object, `int` v10 ) @signature `Ln/a/a/c/g;.z:(I[IIII[II)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L35ec5c.  v4:= v4 + -1;
  #L35ec60.  if v4 < 0 then goto L35ec82;
  #L35ec64.  v0:= v6 + v4 @kind int;
  #L35ec68.  v0:= v5[v0];
  #L35ec6c.  v1:= v10 + v4 @kind int;
  #L35ec70.  v2:= v0 ^>> v7 @kind int;
  #L35ec74.  v3:= -v7 @kind int;
  #L35ec76.  v8:= v8 ^< v3 @kind int;
  #L35ec78.  v8:= v8 ^| v2 @kind int;
  #L35ec7a.  v9[v1]:= v8;
  #L35ec7e.  v8:= v0;
  #L35ec80.  goto L35ec5c;
  #L35ec82.  v4:= -v7 @kind int;
  #L35ec84.  v4:= v8 ^< v4 @kind int;
  #L35ec88.  return v4;
}

record `e.g.o.o` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `e.g.o.h` `@@e.g.o.o.a` @AccessFlag PUBLIC_STATIC_FINAL;
global `e.g.o.h` `@@e.g.o.o.b` @AccessFlag PUBLIC_STATIC_FINAL;
global `e.g.o.h` `@@e.g.o.o.c` @AccessFlag PUBLIC_STATIC_FINAL;
global `e.g.o.h` `@@e.g.o.o.d` @AccessFlag PUBLIC_STATIC_FINAL;
global `e.g.o.h` `@@e.g.o.o.e` @AccessFlag PUBLIC_STATIC_FINAL;
global `e.g.o.h` `@@e.g.o.o.f` @AccessFlag PUBLIC_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Le/g/o/o;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L222798.  v0:= new `e.g.o.m`;
  #L22279c.  v1:= 0I;
  #L22279e.  v2:= 0I;
  #L2227a0.  call `<init>`(v0, v1, v2) @signature `Le/g/o/m;.<init>:(Le/g/o/k;Z)V` @kind direct;
  #L2227a6.  `@@e.g.o.o.a` @type ^`e.g.o.h` := v0 @kind object;
  #L2227aa.  v0:= new `e.g.o.m`;
  #L2227ae.  v3:= 1I;
  #L2227b0.  call `<init>`(v0, v1, v3) @signature `Le/g/o/m;.<init>:(Le/g/o/k;Z)V` @kind direct;
  #L2227b6.  `@@e.g.o.o.b` @type ^`e.g.o.h` := v0 @kind object;
  #L2227ba.  v0:= new `e.g.o.m`;
  #L2227be.  v1:= `@@e.g.o.j.a` @type ^`e.g.o.j` @kind object;
  #L2227c2.  call `<init>`(v0, v1, v2) @signature `Le/g/o/m;.<init>:(Le/g/o/k;Z)V` @kind direct;
  #L2227c8.  `@@e.g.o.o.c` @type ^`e.g.o.h` := v0 @kind object;
  #L2227cc.  v0:= new `e.g.o.m`;
  #L2227d0.  call `<init>`(v0, v1, v3) @signature `Le/g/o/m;.<init>:(Le/g/o/k;Z)V` @kind direct;
  #L2227d6.  `@@e.g.o.o.d` @type ^`e.g.o.h` := v0 @kind object;
  #L2227da.  v0:= new `e.g.o.m`;
  #L2227de.  v1:= `@@e.g.o.i.a` @type ^`e.g.o.i` @kind object;
  #L2227e2.  call `<init>`(v0, v1, v2) @signature `Le/g/o/m;.<init>:(Le/g/o/k;Z)V` @kind direct;
  #L2227e8.  `@@e.g.o.o.e` @type ^`e.g.o.h` := v0 @kind object;
  #L2227ec.  v0:= `@@e.g.o.n.b` @type ^`e.g.o.n` @kind object;
  #L2227f0.  `@@e.g.o.o.f` @type ^`e.g.o.h` := v0 @kind object;
  #L2227f4.  return @kind void;
}
procedure `int` `a`(`int` v1 ) @signature `Le/g/o/o;.a:(I)I` @AccessFlag STATIC {
    temp;
    v0;

  #L222728.  v0:= 1I;
  #L22272a.  if v1 == 0 then goto L22273e;
  #L22272e.  if v1 == v0 then goto L22273a;
  #L222732.  v0:= 2I;
  #L222734.  if v1 == v0 then goto L22273a;
  #L222738.  return v0;
  #L22273a.  v1:= 0I;
  #L22273c.  return v1;
  #L22273e.  return v0;
}
procedure `int` `b`(`int` v2 ) @signature `Le/g/o/o;.b:(I)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L222750.  v0:= 1I;
  #L222752.  if v2 == 0 then goto L22276c;
  #L222756.  if v2 == v0 then goto L222768;
  #L22275a.  v1:= 2I;
  #L22275c.  if v2 == v1 then goto L222768;
  #L222760.  goto L222770;
  #L222766.  return v1;
  #L222768.  v2:= 0I;
  #L22276a.  return v2;
  #L22276c.  return v0;
  #L22276e.  
  #L222770.  switch v2
                  | 14 => goto L22276c
                  | 15 => goto L22276c
                  | 16 => goto L222768
                  | 17 => goto L222768
                  | else => goto L222766;
}

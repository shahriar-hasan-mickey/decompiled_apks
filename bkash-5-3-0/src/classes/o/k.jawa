record `o.k` @kind class @AccessFlag PUBLIC extends `o.m` @kind interface {
  `double` `o.k.a` @AccessFlag ;
  `double` `o.k.b` @AccessFlag PRIVATE;
  `double` `o.k.c` @AccessFlag PRIVATE;
  `float` `o.k.d` @AccessFlag PRIVATE;
  `float` `o.k.e` @AccessFlag PRIVATE;
  `float` `o.k.f` @AccessFlag PRIVATE;
  `float` `o.k.g` @AccessFlag PRIVATE;
  `float` `o.k.h` @AccessFlag PRIVATE;
  `int` `o.k.i` @AccessFlag PRIVATE;
}
procedure `void` `<init>`(`o.k` v2 @kind this) @signature `Lo/k;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L541dd0.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L541dd6.  v0:= 0.5D;
  #L541dda.  v2.`o.k.a` @type ^`double` := v0 @kind wide;
  #L541dde.  v0:= 0I;
  #L541de0.  v2.`o.k.i` @type ^`int` := v0;
  #L541de4.  return @kind void;
}
procedure `void` `c`(`o.k` v24 @kind this, `double` v25 ) @signature `Lo/k;.c:(D)V` @AccessFlag PRIVATE {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;
    v23;

  #L541df8.  v0:= v24 @kind object;
  #L541dfc.  v1:= v0.`o.k.b` @type ^`double` @kind wide;
  #L541e00.  v3:= v0.`o.k.a` @type ^`double` @kind wide;
  #L541e04.  v5:= v0.`o.k.g` @type ^`float`;
  #L541e08.  v5:= (`double`) v5 @kind f2d;
  #L541e0a.  v5:= v1 / v5 @kind double;
  #L541e0e.  call temp:= `sqrt`(v5) @signature `Ljava/lang/Math;.sqrt:(D)D` @kind static;
  #L541e14.  v5:= temp @kind wide;
  #L541e16.  v5:= v5 * v25 @kind double;
  #L541e1a.  v7:= 4.0D;
  #L541e1e.  v5:= v5 * v7 @kind double;
  #L541e22.  v7:= 9.0D;
  #L541e26.  v7:= v7 / v5 @kind double;
  #L541e28.  v5:= 1.0D;
  #L541e2c.  v7:= v7 + v5 @kind double;
  #L541e2e.  v5:= (`int`) v7 @kind d2i;
  #L541e30.  v6:= (`double`) v5 @kind i2d;
  #L541e32.  v6:= v25 / v6 @kind double;
  #L541e36.  v8:= 0I;
  #L541e38.  if v8 >= v5 then goto L541f22;
  #L541e3c.  v9:= v0.`o.k.e` @type ^`float`;
  #L541e40.  v10:= (`double`) v9 @kind f2d;
  #L541e42.  v12:= v0.`o.k.c` @type ^`double` @kind wide;
  #L541e46.  v10:= v10 - v12 @kind double;
  #L541e48.  v14:= -v1 @kind double;
  #L541e4a.  v14:= v14 * v10 @kind double;
  #L541e4e.  v10:= v0.`o.k.f` @type ^`float`;
  #L541e52.  v16:= v1 @kind wide;
  #L541e56.  v1:= (`double`) v10 @kind f2d;
  #L541e58.  v1:= v1 * v3 @kind double;
  #L541e5c.  v14:= v14 - v1 @kind double;
  #L541e5e.  v1:= v0.`o.k.g` @type ^`float`;
  #L541e62.  v18:= v3 @kind wide;
  #L541e66.  v2:= (`double`) v1 @kind f2d;
  #L541e68.  v14:= v14 / v2 @kind double;
  #L541e6a.  v2:= (`double`) v10 @kind f2d;
  #L541e6c.  v14:= v14 * v6 @kind double;
  #L541e70.  v20:= 2.0D;
  #L541e74.  v14:= v14 / v20 @kind double;
  #L541e78.  v2:= v2 + v14 @kind double;
  #L541e7a.  v14:= (`double`) v9 @kind f2d;
  #L541e7c.  v22:= v6 * v2 @kind double;
  #L541e80.  v22:= v22 / v20 @kind double;
  #L541e84.  v14:= v14 + v22 @kind double;
  #L541e88.  v14:= v14 - v12 @kind double;
  #L541e8a.  v11:= -v14 @kind double;
  #L541e8c.  v11:= v11 * v16 @kind double;
  #L541e90.  v2:= v2 * v18 @kind double;
  #L541e94.  v11:= v11 - v2 @kind double;
  #L541e96.  v1:= (`double`) v1 @kind f2d;
  #L541e98.  v11:= v11 / v1 @kind double;
  #L541e9a.  v11:= v11 * v6 @kind double;
  #L541e9e.  v1:= (`double`) v10 @kind f2d;
  #L541ea0.  v3:= v11 / v20 @kind double;
  #L541ea4.  v1:= v1 + v3 @kind double;
  #L541ea6.  v3:= (`double`) v10 @kind f2d;
  #L541ea8.  v3:= v3 + v11 @kind double;
  #L541eaa.  v3:= (`float`) v3 @kind d2f;
  #L541eac.  v0.`o.k.f` @type ^`float` := v3;
  #L541eb0.  v9:= (`double`) v9 @kind f2d;
  #L541eb2.  v1:= v1 * v6 @kind double;
  #L541eb6.  v9:= v9 + v1 @kind double;
  #L541eb8.  v1:= (`float`) v9 @kind d2f;
  #L541eba.  v0.`o.k.e` @type ^`float` := v1;
  #L541ebe.  v2:= v0.`o.k.i` @type ^`int`;
  #L541ec2.  if v2 <= 0 then goto L541f14;
  #L541ec6.  v4:= 0I;
  #L541ec8.  v4:= fcmpg(v1, v4);
  #L541ecc.  if v4 >= 0 then goto L541ee6;
  #L541ed0.  v4:= v2 ^& 1;
  #L541ed4.  v9:= 1I;
  #L541ed6.  if v4 != v9 then goto L541ee6;
  #L541eda.  v1:= -v1 @kind float;
  #L541edc.  v0.`o.k.e` @type ^`float` := v1;
  #L541ee0.  v1:= -v3 @kind float;
  #L541ee2.  v0.`o.k.f` @type ^`float` := v1;
  #L541ee6.  v1:= v0.`o.k.e` @type ^`float`;
  #L541eea.  v3:= 1.0F;
  #L541eee.  v3:= fcmpl(v1, v3);
  #L541ef2.  if v3 <= 0 then goto L541f14;
  #L541ef6.  v2:= v2 ^& 2;
  #L541efa.  v3:= 2I;
  #L541efc.  if v2 != v3 then goto L541f14;
  #L541f00.  v2:= 2.0F;
  #L541f04.  v2:= v2 - v1 @kind float;
  #L541f06.  v0.`o.k.e` @type ^`float` := v2;
  #L541f0a.  v1:= v0.`o.k.f` @type ^`float`;
  #L541f0e.  v1:= -v1 @kind float;
  #L541f10.  v0.`o.k.f` @type ^`float` := v1;
  #L541f14.  v8:= v8 + 1;
  #L541f18.  v1:= v16 @kind wide;
  #L541f1c.  v3:= v18 @kind wide;
  #L541f20.  goto L541e38;
  #L541f22.  return @kind void;
}
procedure `boolean` `a`(`o.k` v8 @kind this) @signature `Lo/k;.a:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;

  #L541d30.  v0:= v8.`o.k.e` @type ^`float`;
  #L541d34.  v0:= (`double`) v0 @kind f2d;
  #L541d36.  v2:= v8.`o.k.c` @type ^`double` @kind wide;
  #L541d3a.  v0:= v0 - v2 @kind double;
  #L541d3c.  v2:= v8.`o.k.b` @type ^`double` @kind wide;
  #L541d40.  v4:= v8.`o.k.f` @type ^`float`;
  #L541d44.  v4:= (`double`) v4 @kind f2d;
  #L541d46.  v6:= v8.`o.k.g` @type ^`float`;
  #L541d4a.  v6:= (`double`) v6 @kind f2d;
  #L541d4c.  v4:= v4 * v4 @kind double;
  #L541d50.  v4:= v4 * v6 @kind double;
  #L541d54.  v6:= v2 * v0 @kind double;
  #L541d58.  v6:= v6 * v0 @kind double;
  #L541d5c.  v4:= v4 + v6 @kind double;
  #L541d5e.  v4:= v4 / v2 @kind double;
  #L541d60.  call temp:= `sqrt`(v4) @signature `Ljava/lang/Math;.sqrt:(D)D` @kind static;
  #L541d66.  v0:= temp @kind wide;
  #L541d68.  v2:= v8.`o.k.h` @type ^`float`;
  #L541d6c.  v2:= (`double`) v2 @kind f2d;
  #L541d6e.  v4:= dcmpg(v0, v2);
  #L541d72.  if v4 > 0 then goto L541d7a;
  #L541d76.  v0:= 1I;
  #L541d78.  goto L541d7c;
  #L541d7a.  v0:= 0I;
  #L541d7c.  return v0;
}
procedure `float` `b`(`o.k` v1 @kind this) @signature `Lo/k;.b:()F` @AccessFlag PUBLIC {
    temp;
    v0;

  #L541dbc.  v0:= 0I;
  #L541dbe.  return v0;
}
procedure `void` `d`(`o.k` v0 @kind this, `float` v1 , `float` v2 , `float` v3 , `float` v4 , `float` v5 , `float` v6 , `float` v7 , `int` v8 ) @signature `Lo/k;.d:(FFFFFFFI)V` @AccessFlag PUBLIC {
    temp;

  #L541f34.  v2:= (`double`) v2 @kind f2d;
  #L541f36.  v0.`o.k.c` @type ^`double` := v2 @kind wide;
  #L541f3a.  v2:= (`double`) v6 @kind f2d;
  #L541f3c.  v0.`o.k.a` @type ^`double` := v2 @kind wide;
  #L541f40.  v0.`o.k.e` @type ^`float` := v1;
  #L541f44.  v1:= (`double`) v5 @kind f2d;
  #L541f46.  v0.`o.k.b` @type ^`double` := v1 @kind wide;
  #L541f4a.  v0.`o.k.g` @type ^`float` := v4;
  #L541f4e.  v0.`o.k.h` @type ^`float` := v7;
  #L541f52.  v0.`o.k.i` @type ^`int` := v8;
  #L541f56.  v1:= 0I;
  #L541f58.  v0.`o.k.d` @type ^`float` := v1;
  #L541f5c.  return @kind void;
}
procedure `float` `getInterpolation`(`o.k` v2 @kind this, `float` v3 ) @signature `Lo/k;.getInterpolation:(F)F` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L541d90.  v0:= v2.`o.k.d` @type ^`float`;
  #L541d94.  v0:= v3 - v0 @kind float;
  #L541d98.  v0:= (`double`) v0 @kind f2d;
  #L541d9a.  call `c`(v2, v0) @signature `Lo/k;.c:(D)V` @kind direct;
  #L541da0.  v2.`o.k.d` @type ^`float` := v3;
  #L541da4.  v3:= v2.`o.k.e` @type ^`float`;
  #L541da8.  return v3;
}

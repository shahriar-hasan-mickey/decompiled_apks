record `org.spongycastle.math.raw.Mod` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
procedure `void` `<init>`(`org.spongycastle.math.raw.Mod` v0 @kind this) @signature `Lorg/spongycastle/math/raw/Mod;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {

  # return;
}
procedure `void` `add`(`int`[] v1 @kind object, `int`[] v2 @kind object, `int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Mod;.add:([I[I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `getTrailingZeroes`(`int` v2 ) @signature `Lorg/spongycastle/math/raw/Mod;.getTrailingZeroes:(I)I` @AccessFlag PRIVATE_STATIC {

  # return;
}
procedure `int` `inverse32`(`int` v2 ) @signature `Lorg/spongycastle/math/raw/Mod;.inverse32:(I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `inversionResult`(`int`[] v0 @kind object, `int` v1 , `int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Mod;.inversionResult:([II[I[I)V` @AccessFlag PRIVATE_STATIC {

  # return;
}
procedure `int` `inversionStep`(`int`[] v4 @kind object, `int`[] v5 @kind object, `int` v6 , `int`[] v7 @kind object, `int` v8 ) @signature `Lorg/spongycastle/math/raw/Mod;.inversionStep:([I[II[II)I` @AccessFlag PRIVATE_STATIC {

  # return;
}
procedure `void` `invert`(`int`[] v9 @kind object, `int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Mod;.invert:([I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `random`(`int`[] v7 @kind object) @signature `Lorg/spongycastle/math/raw/Mod;.random:([I)[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `subtract`(`int`[] v1 @kind object, `int`[] v2 @kind object, `int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Mod;.subtract:([I[I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}

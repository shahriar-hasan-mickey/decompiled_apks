record `org.spongycastle.math.raw.Nat160` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `long` `@@org.spongycastle.math.raw.Nat160.M` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<init>`(`org.spongycastle.math.raw.Nat160` v0 @kind this) @signature `Lorg/spongycastle/math/raw/Nat160;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {

  # return;
}
procedure `int` `add`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.add:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addBothTo`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.addBothTo:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addTo`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat160;.addTo:([II[III)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addTo`(`int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.addTo:([I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addToEachOther`(`int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat160;.addToEachOther:([II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `copy`(`int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.copy:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `create`() @signature `Lorg/spongycastle/math/raw/Nat160;.create:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `createExt`() @signature `Lorg/spongycastle/math/raw/Nat160;.createExt:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `diff`(`int`[] v7 @kind object, `int` v8 , `int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 ) @signature `Lorg/spongycastle/math/raw/Nat160;.diff:([II[II[II)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `eq`(`int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.eq:([I[I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `fromBigInteger`(`java.math.BigInteger` v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.fromBigInteger:(Ljava/math/BigInteger;)[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `getBit`(`int`[] v3 @kind object, `int` v4 ) @signature `Lorg/spongycastle/math/raw/Nat160;.getBit:([II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `gte`(`int`[] v5 @kind object, `int` v6 , `int`[] v7 @kind object, `int` v8 ) @signature `Lorg/spongycastle/math/raw/Nat160;.gte:([II[II)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `gte`(`int`[] v5 @kind object, `int`[] v6 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.gte:([I[I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isOne`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.isOne:([I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isZero`(`int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.isZero:([I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `mul`(`int`[] v27 @kind object, `int` v28 , `int`[] v29 @kind object, `int` v30 , `int`[] v31 @kind object, `int` v32 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mul:([II[II[II)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `mul`(`int`[] v27 @kind object, `int`[] v28 @kind object, `int`[] v29 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.mul:([I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long` `mul33Add`(`int` v13 , `int`[] v14 @kind object, `int` v15 , `int`[] v16 @kind object, `int` v17 , `int`[] v18 @kind object, `int` v19 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mul33Add:(I[II[II[II)J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mul33DWordAdd`(`int` v15 , `long` v16 , `int`[] v18 @kind object, `int` v19 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mul33DWordAdd:(IJ[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mul33WordAdd`(`int` v10 , `int` v11 , `int`[] v12 @kind object, `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mul33WordAdd:(II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulAddTo`(`int`[] v29 @kind object, `int` v30 , `int`[] v31 @kind object, `int` v32 , `int`[] v33 @kind object, `int` v34 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mulAddTo:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulAddTo`(`int`[] v30 @kind object, `int`[] v31 @kind object, `int`[] v32 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.mulAddTo:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWord`(`int` v8 , `int`[] v9 @kind object, `int`[] v10 @kind object, `int` v11 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mulWord:(I[I[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordAddExt`(`int` v11 , `int`[] v12 @kind object, `int` v13 , `int`[] v14 @kind object, `int` v15 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mulWordAddExt:(I[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordDwordAdd`(`int` v10 , `long` v11 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mulWordDwordAdd:(IJ[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordsAdd`(`int` v8 , `int` v9 , `int`[] v10 @kind object, `int` v11 ) @signature `Lorg/spongycastle/math/raw/Nat160;.mulWordsAdd:(II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `square`(`int`[] v30 @kind object, `int` v31 , `int`[] v32 @kind object, `int` v33 ) @signature `Lorg/spongycastle/math/raw/Nat160;.square:([II[II)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `square`(`int`[] v29 @kind object, `int`[] v30 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.square:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `sub`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat160;.sub:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `sub`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.sub:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subBothFrom`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.subBothFrom:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subFrom`(`int`[] v10 @kind object, `int` v11 , `int`[] v12 @kind object, `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat160;.subFrom:([II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subFrom`(`int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.subFrom:([I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `java.math.BigInteger` `toBigInteger`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.toBigInteger:([I)Ljava/math/BigInteger;` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `zero`(`int`[] v2 @kind object) @signature `Lorg/spongycastle/math/raw/Nat160;.zero:([I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}

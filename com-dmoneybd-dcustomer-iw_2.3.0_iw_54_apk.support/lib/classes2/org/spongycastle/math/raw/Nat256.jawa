record `org.spongycastle.math.raw.Nat256` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `long` `@@org.spongycastle.math.raw.Nat256.M` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<init>`(`org.spongycastle.math.raw.Nat256` v0 @kind this) @signature `Lorg/spongycastle/math/raw/Nat256;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {

  # return;
}
procedure `int` `add`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat256;.add:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `add`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.add:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addBothTo`(`int`[] v10 @kind object, `int` v11 , `int`[] v12 @kind object, `int` v13 , `int`[] v14 @kind object, `int` v15 ) @signature `Lorg/spongycastle/math/raw/Nat256;.addBothTo:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addBothTo`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.addBothTo:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addTo`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat256;.addTo:([II[III)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addTo`(`int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.addTo:([I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addToEachOther`(`int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat256;.addToEachOther:([II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `copy`(`int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.copy:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `copy64`(`long`[] v3 @kind object, `long`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.copy64:([J[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `create`() @signature `Lorg/spongycastle/math/raw/Nat256;.create:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `create64`() @signature `Lorg/spongycastle/math/raw/Nat256;.create64:()[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `createExt`() @signature `Lorg/spongycastle/math/raw/Nat256;.createExt:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `createExt64`() @signature `Lorg/spongycastle/math/raw/Nat256;.createExt64:()[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `diff`(`int`[] v7 @kind object, `int` v8 , `int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 ) @signature `Lorg/spongycastle/math/raw/Nat256;.diff:([II[II[II)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `eq`(`int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.eq:([I[I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `eq64`(`long`[] v6 @kind object, `long`[] v7 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.eq64:([J[J)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `fromBigInteger`(`java.math.BigInteger` v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.fromBigInteger:(Ljava/math/BigInteger;)[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `fromBigInteger64`(`java.math.BigInteger` v5 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.fromBigInteger64:(Ljava/math/BigInteger;)[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `getBit`(`int`[] v2 @kind object, `int` v3 ) @signature `Lorg/spongycastle/math/raw/Nat256;.getBit:([II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `gte`(`int`[] v5 @kind object, `int` v6 , `int`[] v7 @kind object, `int` v8 ) @signature `Lorg/spongycastle/math/raw/Nat256;.gte:([II[II)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `gte`(`int`[] v5 @kind object, `int`[] v6 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.gte:([I[I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isOne`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.isOne:([I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isOne64`(`long`[] v8 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.isOne64:([J)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isZero`(`int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.isZero:([I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isZero64`(`long`[] v7 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.isZero64:([J)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `mul`(`int`[] v34 @kind object, `int` v35 , `int`[] v36 @kind object, `int` v37 , `int`[] v38 @kind object, `int` v39 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mul:([II[II[II)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `mul`(`int`[] v35 @kind object, `int`[] v36 @kind object, `int`[] v37 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.mul:([I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long` `mul33Add`(`int` v13 , `int`[] v14 @kind object, `int` v15 , `int`[] v16 @kind object, `int` v17 , `int`[] v18 @kind object, `int` v19 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mul33Add:(I[II[II[II)J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mul33DWordAdd`(`int` v15 , `long` v16 , `int`[] v18 @kind object, `int` v19 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mul33DWordAdd:(IJ[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mul33WordAdd`(`int` v10 , `int` v11 , `int`[] v12 @kind object, `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mul33WordAdd:(II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulAddTo`(`int`[] v35 @kind object, `int` v36 , `int`[] v37 @kind object, `int` v38 , `int`[] v39 @kind object, `int` v40 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mulAddTo:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulAddTo`(`int`[] v34 @kind object, `int`[] v35 @kind object, `int`[] v36 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.mulAddTo:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulByWord`(`int` v9 , `int`[] v10 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.mulByWord:(I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulByWordAddTo`(`int` v11 , `int`[] v12 @kind object, `int`[] v13 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.mulByWordAddTo:(I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWord`(`int` v8 , `int`[] v9 @kind object, `int`[] v10 @kind object, `int` v11 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mulWord:(I[I[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordAddTo`(`int` v11 , `int`[] v12 @kind object, `int` v13 , `int`[] v14 @kind object, `int` v15 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mulWordAddTo:(I[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordDwordAdd`(`int` v10 , `long` v11 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat256;.mulWordDwordAdd:(IJ[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `square`(`int`[] v46 @kind object, `int` v47 , `int`[] v48 @kind object, `int` v49 ) @signature `Lorg/spongycastle/math/raw/Nat256;.square:([II[II)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `square`(`int`[] v46 @kind object, `int`[] v47 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.square:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `sub`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat256;.sub:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `sub`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.sub:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subBothFrom`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.subBothFrom:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subFrom`(`int`[] v10 @kind object, `int` v11 , `int`[] v12 @kind object, `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat256;.subFrom:([II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subFrom`(`int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.subFrom:([I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `java.math.BigInteger` `toBigInteger`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.toBigInteger:([I)Ljava/math/BigInteger;` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `java.math.BigInteger` `toBigInteger64`(`long`[] v7 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.toBigInteger64:([J)Ljava/math/BigInteger;` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `zero`(`int`[] v2 @kind object) @signature `Lorg/spongycastle/math/raw/Nat256;.zero:([I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}

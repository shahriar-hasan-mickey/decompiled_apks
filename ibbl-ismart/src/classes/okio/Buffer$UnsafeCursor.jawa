record `okio.Buffer$UnsafeCursor` @kind class @AccessFlag PUBLIC_FINAL extends `java.io.Closeable` @kind interface {
  `okio.Buffer` `okio.Buffer$UnsafeCursor.buffer` @AccessFlag PUBLIC;
  `byte`[] `okio.Buffer$UnsafeCursor.data` @AccessFlag PUBLIC;
  `int` `okio.Buffer$UnsafeCursor.end` @AccessFlag PUBLIC;
  `long` `okio.Buffer$UnsafeCursor.offset` @AccessFlag PUBLIC;
  `boolean` `okio.Buffer$UnsafeCursor.readWrite` @AccessFlag PUBLIC;
  `okio.Segment` `okio.Buffer$UnsafeCursor.segment` @AccessFlag PRIVATE;
  `int` `okio.Buffer$UnsafeCursor.start` @AccessFlag PUBLIC;
}
procedure `void` `<init>`(`okio.Buffer$UnsafeCursor` v2 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L24c184.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L24c18a.  v0:= -1L;
  #L24c18e.  v2.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L24c192.  v0:= -1I;
  #L24c194.  v2.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L24c198.  v2.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L24c19c.  return @kind void;
}
procedure `void` `close`(`okio.Buffer$UnsafeCursor` v3 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.close:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L24c1b0.  v0:= v3.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24c1b4.  if v0 == 0 then goto L24c1da;
  #L24c1b8.  v0:= 0I;
  #L24c1ba.  v3.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` := v0 @kind object;
  #L24c1be.  v3.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v0 @kind object;
  #L24c1c2.  v1:= -1L;
  #L24c1c6.  v3.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v1 @kind wide;
  #L24c1ca.  v3.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L24c1ce.  v0:= -1I;
  #L24c1d0.  v3.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L24c1d4.  v3.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L24c1d8.  return @kind void;
  #L24c1da.  v0:= new `java.lang.IllegalStateException`;
  #L24c1de.  v1:= "not attached to a buffer" @kind object;
  #L24c1e2.  call `<init>`(v0, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24c1e8.  throw v0;
}
procedure `long` `expandBuffer`(`okio.Buffer$UnsafeCursor` v9 @kind this, `int` v10 ) @signature `Lokio/Buffer$UnsafeCursor;.expandBuffer:(I)J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L24bf24.  if v10 <= 0 then goto L24bfd6;
  #L24bf28.  v0:= 8192I;
  #L24bf2c.  if v10 > v0 then goto L24bfa8;
  #L24bf30.  v1:= v9.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bf34.  if v1 == 0 then goto L24bf98;
  #L24bf38.  v2:= v9.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L24bf3c.  if v2 == 0 then goto L24bf88;
  #L24bf40.  v1:= v1.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24bf44.  v3:= v9.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bf48.  call temp:= `writableSegment`(v3, v10) @signature `Lokio/Buffer;.writableSegment:(I)Lokio/Segment;` @kind virtual;
  #L24bf4e.  v10:= temp @kind object;
  #L24bf50.  v3:= v10.`okio.Segment.limit` @type ^`int`;
  #L24bf54.  v3:= v3 - 8192;
  #L24bf58.  v10.`okio.Segment.limit` @type ^`int` := v0;
  #L24bf5c.  v4:= v9.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bf60.  v5:= (`long`) v3 @kind i2l;
  #L24bf62.  v7:= v1 + v5 @kind long;
  #L24bf66.  v4.`okio.Buffer.size` @type ^`long` := v7 @kind wide;
  #L24bf6a.  v9.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v10 @kind object;
  #L24bf6e.  v9.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v1 @kind wide;
  #L24bf72.  v10:= v10.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L24bf76.  v9.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v10 @kind object;
  #L24bf7a.  v10:= v3 - 8192;
  #L24bf7e.  v9.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v10;
  #L24bf82.  v9.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L24bf86.  return v5 @kind wide;
  #L24bf88.  v10:= new `java.lang.IllegalStateException`;
  #L24bf8c.  v0:= "expandBuffer() only permitted for read/write buffers" @kind object;
  #L24bf90.  call `<init>`(v10, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24bf96.  throw v10;
  #L24bf98.  v10:= new `java.lang.IllegalStateException`;
  #L24bf9c.  v0:= "not attached to a buffer" @kind object;
  #L24bfa0.  call `<init>`(v10, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24bfa6.  throw v10;
  #L24bfa8.  v0:= new `java.lang.IllegalArgumentException`;
  #L24bfac.  v1:= new `java.lang.StringBuilder`;
  #L24bfb0.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L24bfb6.  v2:= "minByteCount > Segment.SIZE: " @kind object;
  #L24bfba.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L24bfc0.  call temp:= `append`(v1, v10) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L24bfc6.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L24bfcc.  v10:= temp @kind object;
  #L24bfce.  call `<init>`(v0, v10) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24bfd4.  throw v0;
  #L24bfd6.  v0:= new `java.lang.IllegalArgumentException`;
  #L24bfda.  v1:= new `java.lang.StringBuilder`;
  #L24bfde.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L24bfe4.  v2:= "minByteCount <= 0: " @kind object;
  #L24bfe8.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L24bfee.  call temp:= `append`(v1, v10) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L24bff4.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L24bffa.  v10:= temp @kind object;
  #L24bffc.  call `<init>`(v0, v10) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24c002.  throw v0;
}
procedure `int` `next`(`okio.Buffer$UnsafeCursor` v5 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.next:()I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L24bd00.  v0:= v5.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L24bd04.  v2:= v5.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bd08.  v2:= v2.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24bd0c.  v4:= lcmp(v0, v2);
  #L24bd10.  if v4 == 0 then goto L24bd4a;
  #L24bd14.  v0:= v5.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L24bd18.  v2:= -1L;
  #L24bd1c.  v4:= lcmp(v0, v2);
  #L24bd20.  if v4 != 0 then goto L24bd32;
  #L24bd24.  v0:= 0L;
  #L24bd28.  call temp:= `seek`(v5, v0) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @kind virtual;
  #L24bd2e.  v0:= temp;
  #L24bd30.  return v0;
  #L24bd32.  v2:= v5.`okio.Buffer$UnsafeCursor.end` @type ^`int`;
  #L24bd36.  v3:= v5.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L24bd3a.  v2:= v2 - v3 @kind int;
  #L24bd3c.  v2:= (`long`) v2 @kind i2l;
  #L24bd3e.  v0:= v0 + v2 @kind long;
  #L24bd40.  call temp:= `seek`(v5, v0) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @kind virtual;
  #L24bd46.  v0:= temp;
  #L24bd48.  return v0;
  #L24bd4a.  v0:= new `java.lang.IllegalStateException`;
  #L24bd4e.  call `<init>`(v0) @signature `Ljava/lang/IllegalStateException;.<init>:()V` @kind direct;
  #L24bd54.  throw v0;
}
procedure `long` `resizeBuffer`(`okio.Buffer$UnsafeCursor` v12 @kind this, `long` v13 ) @signature `Lokio/Buffer$UnsafeCursor;.resizeBuffer:(J)J` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;

  #L24c014.  v0:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24c018.  if v0 == 0 then goto L24c162;
  #L24c01c.  v1:= v12.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L24c020.  if v1 == 0 then goto L24c152;
  #L24c024.  v0:= v0.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24c028.  v2:= 0L;
  #L24c02c.  v4:= lcmp(v13, v0);
  #L24c030.  if v4 > 0 then goto L24c0d8;
  #L24c034.  v4:= lcmp(v13, v2);
  #L24c038.  if v4 < 0 then goto L24c0aa;
  #L24c03c.  v4:= v0 - v13 @kind long;
  #L24c040.  v6:= lcmp(v4, v2);
  #L24c044.  if v6 <= 0 then goto L24c090;
  #L24c048.  v6:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24c04c.  v6:= v6.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L24c050.  v6:= v6.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L24c054.  v7:= v6.`okio.Segment.limit` @type ^`int`;
  #L24c058.  v8:= v6.`okio.Segment.pos` @type ^`int`;
  #L24c05c.  v7:= v7 - v8 @kind int;
  #L24c05e.  v7:= (`long`) v7 @kind i2l;
  #L24c060.  v9:= lcmp(v7, v4);
  #L24c064.  if v9 > 0 then goto L24c082;
  #L24c068.  v9:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24c06c.  call temp:= `pop`(v6) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L24c072.  v10:= temp @kind object;
  #L24c074.  v9.`okio.Buffer.head` @type ^`okio.Segment` := v10 @kind object;
  #L24c078.  call `recycle`(v6) @signature `Lokio/SegmentPool;.recycle:(Lokio/Segment;)V` @kind static;
  #L24c07e.  v4:= v4 - v7 @kind long;
  #L24c080.  goto L24c040;
  #L24c082.  v2:= v6.`okio.Segment.limit` @type ^`int`;
  #L24c086.  v2:= (`long`) v2 @kind i2l;
  #L24c088.  v2:= v2 - v4 @kind long;
  #L24c08a.  v2:= (`int`) v2 @kind l2i;
  #L24c08c.  v6.`okio.Segment.limit` @type ^`int` := v2;
  #L24c090.  v2:= 0I;
  #L24c092.  v12.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v2 @kind object;
  #L24c096.  v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v13 @kind wide;
  #L24c09a.  v12.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v2 @kind object;
  #L24c09e.  v2:= -1I;
  #L24c0a0.  v12.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v2;
  #L24c0a4.  v12.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v2;
  #L24c0a8.  goto L24c148;
  #L24c0aa.  v0:= new `java.lang.IllegalArgumentException`;
  #L24c0ae.  v1:= new `java.lang.StringBuilder`;
  #L24c0b2.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L24c0b8.  v2:= "newSize < 0: " @kind object;
  #L24c0bc.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L24c0c2.  call temp:= `append`(v1, v13) @signature `Ljava/lang/StringBuilder;.append:(J)Ljava/lang/StringBuilder;` @kind virtual;
  #L24c0c8.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L24c0ce.  v13:= temp @kind object;
  #L24c0d0.  call `<init>`(v0, v13) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24c0d6.  throw v0;
  #L24c0d8.  v4:= lcmp(v13, v0);
  #L24c0dc.  if v4 <= 0 then goto L24c148;
  #L24c0e0.  v4:= v13 - v0 @kind long;
  #L24c0e4.  v6:= 1I;
  #L24c0e6.  v7:= 1I;
  #L24c0e8.  v8:= lcmp(v4, v2);
  #L24c0ec.  if v8 <= 0 then goto L24c148;
  #L24c0f0.  v8:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24c0f4.  call temp:= `writableSegment`(v8, v6) @signature `Lokio/Buffer;.writableSegment:(I)Lokio/Segment;` @kind virtual;
  #L24c0fa.  v8:= temp @kind object;
  #L24c0fc.  v9:= v8.`okio.Segment.limit` @type ^`int`;
  #L24c100.  v9:= v9 - 8192;
  #L24c104.  v9:= (`long`) v9 @kind i2l;
  #L24c106.  call temp:= `min`(v4, v9) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L24c10c.  v9:= temp @kind wide;
  #L24c10e.  v9:= (`int`) v9 @kind l2i;
  #L24c110.  v10:= v8.`okio.Segment.limit` @type ^`int`;
  #L24c114.  v10:= v10 + v9 @kind int;
  #L24c116.  v8.`okio.Segment.limit` @type ^`int` := v10;
  #L24c11a.  v10:= (`long`) v9 @kind i2l;
  #L24c11c.  v4:= v4 - v10 @kind long;
  #L24c11e.  if v7 == 0 then goto L24c0e8;
  #L24c122.  v12.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v8 @kind object;
  #L24c126.  v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L24c12a.  v7:= v8.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L24c12e.  v12.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v7 @kind object;
  #L24c132.  v7:= v8.`okio.Segment.limit` @type ^`int`;
  #L24c136.  v7:= v7 - v9 @kind int;
  #L24c138.  v12.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v7;
  #L24c13c.  v7:= v8.`okio.Segment.limit` @type ^`int`;
  #L24c140.  v12.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v7;
  #L24c144.  v7:= 0I;
  #L24c146.  goto L24c0e8;
  #L24c148.  v2:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24c14c.  v2.`okio.Buffer.size` @type ^`long` := v13 @kind wide;
  #L24c150.  return v0 @kind wide;
  #L24c152.  v13:= new `java.lang.IllegalStateException`;
  #L24c156.  v14:= "resizeBuffer() only permitted for read/write buffers" @kind object;
  #L24c15a.  call `<init>`(v13, v14) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24c160.  throw v13;
  #L24c162.  v13:= new `java.lang.IllegalStateException`;
  #L24c166.  v14:= "not attached to a buffer" @kind object;
  #L24c16a.  call `<init>`(v13, v14) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24c170.  throw v13;
  #L24c172.  return @kind void;
}
procedure `int` `seek`(`okio.Buffer$UnsafeCursor` v11 @kind this, `long` v12 ) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;

  #L24bd68.  v0:= -1L;
  #L24bd6c.  v2:= lcmp(v12, v0);
  #L24bd70.  if v2 < 0 then goto L24bed0;
  #L24bd74.  v2:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bd78.  v2:= v2.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24bd7c.  v4:= lcmp(v12, v2);
  #L24bd80.  if v4 > 0 then goto L24bed0;
  #L24bd84.  v2:= lcmp(v12, v0);
  #L24bd88.  if v2 == 0 then goto L24beb6;
  #L24bd8c.  v0:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bd90.  v0:= v0.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24bd94.  v2:= lcmp(v12, v0);
  #L24bd98.  if v2 != 0 then goto L24bda0;
  #L24bd9c.  goto L24beb6;
  #L24bda0.  v0:= 0L;
  #L24bda4.  v2:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bda8.  v2:= v2.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24bdac.  v4:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bdb0.  v4:= v4.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L24bdb4.  v5:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24bdb8.  v5:= v5.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L24bdbc.  v6:= v11.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L24bdc0.  if v6 == 0 then goto L24bdec;
  #L24bdc4.  v7:= v11.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L24bdc8.  v9:= v11.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L24bdcc.  v6:= v6.`okio.Segment.pos` @type ^`int`;
  #L24bdd0.  v9:= v9 - v6 @kind int;
  #L24bdd2.  v9:= (`long`) v9 @kind i2l;
  #L24bdd4.  v7:= v7 - v9 @kind long;
  #L24bdd6.  v6:= lcmp(v7, v12);
  #L24bdda.  if v6 <= 0 then goto L24bde6;
  #L24bdde.  v5:= v11.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L24bde2.  v2:= v7 @kind wide;
  #L24bde4.  goto L24bdec;
  #L24bde6.  v4:= v11.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L24bdea.  v0:= v7 @kind wide;
  #L24bdec.  v6:= v2 - v12 @kind long;
  #L24bdf0.  v8:= v12 - v0 @kind long;
  #L24bdf4.  v10:= lcmp(v6, v8);
  #L24bdf8.  if v10 <= 0 then goto L24be26;
  #L24bdfc.  v2:= v4.`okio.Segment.limit` @type ^`int`;
  #L24be00.  v3:= v4.`okio.Segment.pos` @type ^`int`;
  #L24be04.  v2:= v2 - v3 @kind int;
  #L24be06.  v2:= (`long`) v2 @kind i2l;
  #L24be08.  v2:= v2 + v0 @kind long;
  #L24be0a.  v5:= lcmp(v12, v2);
  #L24be0e.  if v5 < 0 then goto L24be46;
  #L24be12.  v2:= v4.`okio.Segment.limit` @type ^`int`;
  #L24be16.  v3:= v4.`okio.Segment.pos` @type ^`int`;
  #L24be1a.  v2:= v2 - v3 @kind int;
  #L24be1c.  v2:= (`long`) v2 @kind i2l;
  #L24be1e.  v0:= v0 + v2 @kind long;
  #L24be20.  v4:= v4.`okio.Segment.next` @type ^`okio.Segment` @kind object;
  #L24be24.  goto L24bdfc;
  #L24be26.  v0:= v2 @kind wide;
  #L24be28.  v4:= v5 @kind object;
  #L24be2a.  v2:= lcmp(v0, v12);
  #L24be2e.  if v2 <= 0 then goto L24be46;
  #L24be32.  v4:= v4.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L24be36.  v2:= v4.`okio.Segment.limit` @type ^`int`;
  #L24be3a.  v3:= v4.`okio.Segment.pos` @type ^`int`;
  #L24be3e.  v2:= v2 - v3 @kind int;
  #L24be40.  v2:= (`long`) v2 @kind i2l;
  #L24be42.  v0:= v0 - v2 @kind long;
  #L24be44.  goto L24be2a;
  #L24be46.  v2:= v11.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L24be4a.  if v2 == 0 then goto L24be84;
  #L24be4e.  v2:= v4.`okio.Segment.shared` @type ^`boolean` @kind boolean;
  #L24be52.  if v2 == 0 then goto L24be84;
  #L24be56.  call temp:= `unsharedCopy`(v4) @signature `Lokio/Segment;.unsharedCopy:()Lokio/Segment;` @kind virtual;
  #L24be5c.  v2:= temp @kind object;
  #L24be5e.  v3:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24be62.  v3:= v3.`okio.Buffer.head` @type ^`okio.Segment` @kind object;
  #L24be66.  if v3 != v4 then goto L24be72;
  #L24be6a.  v3:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24be6e.  v3.`okio.Buffer.head` @type ^`okio.Segment` := v2 @kind object;
  #L24be72.  call temp:= `push`(v4, v2) @signature `Lokio/Segment;.push:(Lokio/Segment;)Lokio/Segment;` @kind virtual;
  #L24be78.  v4:= temp @kind object;
  #L24be7a.  v2:= v4.`okio.Segment.prev` @type ^`okio.Segment` @kind object;
  #L24be7e.  call temp:= `pop`(v2) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L24be84.  v11.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v4 @kind object;
  #L24be88.  v11.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v12 @kind wide;
  #L24be8c.  v2:= v4.`okio.Segment.data` @type ^`byte`[] @kind object;
  #L24be90.  v11.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v2 @kind object;
  #L24be94.  v2:= v4.`okio.Segment.pos` @type ^`int`;
  #L24be98.  v12:= v12 - v0 @kind long;
  #L24be9a.  v12:= (`int`) v12 @kind l2i;
  #L24be9c.  v2:= v2 + v12 @kind int;
  #L24be9e.  v11.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v2;
  #L24bea2.  v12:= v4.`okio.Segment.limit` @type ^`int`;
  #L24bea6.  v11.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v12;
  #L24beaa.  v12:= v11.`okio.Buffer$UnsafeCursor.end` @type ^`int`;
  #L24beae.  v13:= v11.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L24beb2.  v12:= v12 - v13 @kind int;
  #L24beb4.  return v12;
  #L24beb6.  v0:= 0I;
  #L24beb8.  v11.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v0 @kind object;
  #L24bebc.  v11.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v12 @kind wide;
  #L24bec0.  v11.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L24bec4.  v12:= -1I;
  #L24bec6.  v11.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v12;
  #L24beca.  v11.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v12;
  #L24bece.  return v12;
  #L24bed0.  v0:= new `java.lang.ArrayIndexOutOfBoundsException`;
  #L24bed4.  v1:= 2I;
  #L24bed6.  v1:= new `java.lang.Object`[v1];
  #L24beda.  v2:= 0I;
  #L24bedc.  call temp:= `valueOf`(v12) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L24bee2.  v12:= temp @kind object;
  #L24bee4.  v1[v2]:= v12 @kind object;
  #L24bee8.  v12:= 1I;
  #L24beea.  v13:= v11.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L24beee.  v2:= v13.`okio.Buffer.size` @type ^`long` @kind wide;
  #L24bef2.  call temp:= `valueOf`(v2) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L24bef8.  v13:= temp @kind object;
  #L24befa.  v1[v12]:= v13 @kind object;
  #L24befe.  v12:= "offset=%s > size=%s" @kind object;
  #L24bf02.  call temp:= `format`(v12, v1) @signature `Ljava/lang/String;.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;` @kind static;
  #L24bf08.  v12:= temp @kind object;
  #L24bf0a.  call `<init>`(v0, v12) @signature `Ljava/lang/ArrayIndexOutOfBoundsException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L24bf10.  throw v0;
  #L24bf12.  return @kind void;
}

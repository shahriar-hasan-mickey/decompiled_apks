record `d.o` @kind class @AccessFlag FINAL {
  `byte`[] `d.o.a` @AccessFlag FINAL;
  `int` `d.o.b` @AccessFlag ;
  `int` `d.o.c` @AccessFlag ;
  `boolean` `d.o.d` @AccessFlag ;
  `boolean` `d.o.e` @AccessFlag ;
  `d.o` `d.o.f` @AccessFlag ;
  `d.o` `d.o.g` @AccessFlag ;
}
procedure `void` `<init>`(`d.o` v1 @kind this) @signature `Ld/o;.<init>:()V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L3d7dd0.  call `<init>`(v1) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L3d7dd6.  v0:= 8192I;
  #L3d7dda.  v0:= new `byte`[v0];
  #L3d7dde.  v1.`d.o.a` @type ^`byte`[] := v0 @kind object;
  #L3d7de2.  v0:= 1I;
  #L3d7de4.  v1.`d.o.e` @type ^`boolean` := v0 @kind boolean;
  #L3d7de8.  v0:= 0I;
  #L3d7dea.  v1.`d.o.d` @type ^`boolean` := v0 @kind boolean;
  #L3d7dee.  return @kind void;
}
procedure `void` `<init>`(`d.o` v0 @kind this, `byte`[] v1 @kind object, `int` v2 , `int` v3 , `boolean` v4 , `boolean` v5 ) @signature `Ld/o;.<init>:([BIIZZ)V` @AccessFlag CONSTRUCTOR {
    temp;

  #L3d7e00.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L3d7e06.  v0.`d.o.a` @type ^`byte`[] := v1 @kind object;
  #L3d7e0a.  v0.`d.o.b` @type ^`int` := v2;
  #L3d7e0e.  v0.`d.o.c` @type ^`int` := v3;
  #L3d7e12.  v0.`d.o.d` @type ^`boolean` := v4 @kind boolean;
  #L3d7e16.  v0.`d.o.e` @type ^`boolean` := v5 @kind boolean;
  #L3d7e1a.  return @kind void;
}
procedure `d.o` `a`(`d.o` v7 @kind this) @signature `Ld/o;.a:()Ld/o;` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L3d7cac.  v0:= 1I;
  #L3d7cae.  v7.`d.o.d` @type ^`boolean` := v0 @kind boolean;
  #L3d7cb2.  v0:= new `d.o`;
  #L3d7cb6.  v2:= v7.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7cba.  v3:= v7.`d.o.b` @type ^`int`;
  #L3d7cbe.  v4:= v7.`d.o.c` @type ^`int`;
  #L3d7cc2.  v5:= 1I;
  #L3d7cc4.  v6:= 0I;
  #L3d7cc6.  v1:= v0 @kind object;
  #L3d7cc8.  call `<init>`(v1, v2, v3, v4, v5, v6) @signature `Ld/o;.<init>:([BIIZZ)V` @kind direct;
  #L3d7cce.  return v0 @kind object;
}
procedure `d.o` `a`(`d.o` v5 @kind this, `int` v6 ) @signature `Ld/o;.a:(I)Ld/o;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L3d7d0c.  if v6 <= 0 then goto L3d7d6e;
  #L3d7d10.  v0:= v5.`d.o.c` @type ^`int`;
  #L3d7d14.  v1:= v5.`d.o.b` @type ^`int`;
  #L3d7d18.  v0:= v0 - v1 @kind int;
  #L3d7d1a.  if v6 <= v0 then goto L3d7d20;
  #L3d7d1e.  goto L3d7d6e;
  #L3d7d20.  v0:= 1024I;
  #L3d7d24.  if v6 < v0 then goto L3d7d32;
  #L3d7d28.  call temp:= `a`(v5) @signature `Ld/o;.a:()Ld/o;` @kind virtual;
  #L3d7d2e.  v0:= temp @kind object;
  #L3d7d30.  goto L3d7d4e;
  #L3d7d32.  call temp:= `a`() @signature `Ld/p;.a:()Ld/o;` @kind static;
  #L3d7d38.  v0:= temp @kind object;
  #L3d7d3a.  v1:= v5.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7d3e.  v2:= v5.`d.o.b` @type ^`int`;
  #L3d7d42.  v3:= v0.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7d46.  v4:= 0I;
  #L3d7d48.  call `arraycopy`(v1, v2, v3, v4, v6) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L3d7d4e.  v1:= v0.`d.o.b` @type ^`int`;
  #L3d7d52.  v1:= v1 + v6 @kind int;
  #L3d7d54.  v0.`d.o.c` @type ^`int` := v1;
  #L3d7d58.  v1:= v5.`d.o.b` @type ^`int`;
  #L3d7d5c.  v1:= v1 + v6 @kind int;
  #L3d7d5e.  v5.`d.o.b` @type ^`int` := v1;
  #L3d7d62.  v6:= v5.`d.o.g` @type ^`d.o` @kind object;
  #L3d7d66.  call temp:= `a`(v6, v0) @signature `Ld/o;.a:(Ld/o;)Ld/o;` @kind virtual;
  #L3d7d6c.  return v0 @kind object;
  #L3d7d6e.  v6:= new `java.lang.IllegalArgumentException`;
  #L3d7d72.  call `<init>`(v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:()V` @kind direct;
  #L3d7d78.  throw v6;
}
procedure `d.o` `a`(`d.o` v1 @kind this, `d.o` v2 @kind object) @signature `Ld/o;.a:(Ld/o;)Ld/o;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L3d7ce0.  v2.`d.o.g` @type ^`d.o` := v1 @kind object;
  #L3d7ce4.  v0:= v1.`d.o.f` @type ^`d.o` @kind object;
  #L3d7ce8.  v2.`d.o.f` @type ^`d.o` := v0 @kind object;
  #L3d7cec.  v0:= v1.`d.o.f` @type ^`d.o` @kind object;
  #L3d7cf0.  v0.`d.o.g` @type ^`d.o` := v2 @kind object;
  #L3d7cf4.  v1.`d.o.f` @type ^`d.o` := v2 @kind object;
  #L3d7cf8.  return v2 @kind object;
}
procedure `void` `a`(`d.o` v5 @kind this, `d.o` v6 @kind object, `int` v7 ) @signature `Ld/o;.a:(Ld/o;I)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L3d7e2c.  v0:= v6.`d.o.e` @type ^`boolean` @kind boolean;
  #L3d7e30.  if v0 != 0 then goto L3d7e40;
  #L3d7e34.  v6:= new `java.lang.IllegalArgumentException`;
  #L3d7e38.  call `<init>`(v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:()V` @kind direct;
  #L3d7e3e.  throw v6;
  #L3d7e40.  v0:= v6.`d.o.c` @type ^`int`;
  #L3d7e44.  v0:= v0 + v7 @kind int;
  #L3d7e46.  v1:= 8192I;
  #L3d7e4a.  if v0 <= v1 then goto L3d7eae;
  #L3d7e4e.  v0:= v6.`d.o.d` @type ^`boolean` @kind boolean;
  #L3d7e52.  if v0 == 0 then goto L3d7e62;
  #L3d7e56.  v6:= new `java.lang.IllegalArgumentException`;
  #L3d7e5a.  call `<init>`(v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:()V` @kind direct;
  #L3d7e60.  throw v6;
  #L3d7e62.  v0:= v6.`d.o.c` @type ^`int`;
  #L3d7e66.  v0:= v0 + v7 @kind int;
  #L3d7e68.  v2:= v6.`d.o.b` @type ^`int`;
  #L3d7e6c.  v0:= v0 - v2 @kind int;
  #L3d7e6e.  if v0 <= v1 then goto L3d7e7e;
  #L3d7e72.  v6:= new `java.lang.IllegalArgumentException`;
  #L3d7e76.  call `<init>`(v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:()V` @kind direct;
  #L3d7e7c.  throw v6;
  #L3d7e7e.  v0:= v6.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7e82.  v1:= v6.`d.o.b` @type ^`int`;
  #L3d7e86.  v2:= v6.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7e8a.  v3:= v6.`d.o.c` @type ^`int`;
  #L3d7e8e.  v4:= v6.`d.o.b` @type ^`int`;
  #L3d7e92.  v3:= v3 - v4 @kind int;
  #L3d7e94.  v4:= 0I;
  #L3d7e96.  call `arraycopy`(v0, v1, v2, v4, v3) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L3d7e9c.  v0:= v6.`d.o.c` @type ^`int`;
  #L3d7ea0.  v1:= v6.`d.o.b` @type ^`int`;
  #L3d7ea4.  v0:= v0 - v1 @kind int;
  #L3d7ea6.  v6.`d.o.c` @type ^`int` := v0;
  #L3d7eaa.  v6.`d.o.b` @type ^`int` := v4;
  #L3d7eae.  v0:= v5.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7eb2.  v1:= v5.`d.o.b` @type ^`int`;
  #L3d7eb6.  v2:= v6.`d.o.a` @type ^`byte`[] @kind object;
  #L3d7eba.  v3:= v6.`d.o.c` @type ^`int`;
  #L3d7ebe.  call `arraycopy`(v0, v1, v2, v3, v7) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L3d7ec4.  v0:= v6.`d.o.c` @type ^`int`;
  #L3d7ec8.  v0:= v0 + v7 @kind int;
  #L3d7eca.  v6.`d.o.c` @type ^`int` := v0;
  #L3d7ece.  v6:= v5.`d.o.b` @type ^`int`;
  #L3d7ed2.  v6:= v6 + v7 @kind int;
  #L3d7ed4.  v5.`d.o.b` @type ^`int` := v6;
  #L3d7ed8.  return @kind void;
}
procedure `d.o` `b`(`d.o` v4 @kind this) @signature `Ld/o;.b:()Ld/o;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L3d7d8c.  v0:= v4.`d.o.f` @type ^`d.o` @kind object;
  #L3d7d90.  v1:= 0I;
  #L3d7d92.  if v0 == v4 then goto L3d7d9c;
  #L3d7d96.  v0:= v4.`d.o.f` @type ^`d.o` @kind object;
  #L3d7d9a.  goto L3d7d9e;
  #L3d7d9c.  v0:= v1 @kind object;
  #L3d7d9e.  v2:= v4.`d.o.g` @type ^`d.o` @kind object;
  #L3d7da2.  v3:= v4.`d.o.f` @type ^`d.o` @kind object;
  #L3d7da6.  v2.`d.o.f` @type ^`d.o` := v3 @kind object;
  #L3d7daa.  v2:= v4.`d.o.f` @type ^`d.o` @kind object;
  #L3d7dae.  v3:= v4.`d.o.g` @type ^`d.o` @kind object;
  #L3d7db2.  v2.`d.o.g` @type ^`d.o` := v3 @kind object;
  #L3d7db6.  v4.`d.o.f` @type ^`d.o` := v1 @kind object;
  #L3d7dba.  v4.`d.o.g` @type ^`d.o` := v1 @kind object;
  #L3d7dbe.  return v0 @kind object;
}
procedure `void` `c`(`d.o` v3 @kind this) @signature `Ld/o;.c:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L3d7eec.  v0:= v3.`d.o.g` @type ^`d.o` @kind object;
  #L3d7ef0.  if v0 != v3 then goto L3d7f00;
  #L3d7ef4.  v0:= new `java.lang.IllegalStateException`;
  #L3d7ef8.  call `<init>`(v0) @signature `Ljava/lang/IllegalStateException;.<init>:()V` @kind direct;
  #L3d7efe.  throw v0;
  #L3d7f00.  v0:= v3.`d.o.g` @type ^`d.o` @kind object;
  #L3d7f04.  v0:= v0.`d.o.e` @type ^`boolean` @kind boolean;
  #L3d7f08.  if v0 != 0 then goto L3d7f0e;
  #L3d7f0c.  return @kind void;
  #L3d7f0e.  v0:= v3.`d.o.c` @type ^`int`;
  #L3d7f12.  v1:= v3.`d.o.b` @type ^`int`;
  #L3d7f16.  v0:= v0 - v1 @kind int;
  #L3d7f18.  v1:= v3.`d.o.g` @type ^`d.o` @kind object;
  #L3d7f1c.  v1:= v1.`d.o.c` @type ^`int`;
  #L3d7f20.  v1:= v1 - 8192;
  #L3d7f24.  v2:= v3.`d.o.g` @type ^`d.o` @kind object;
  #L3d7f28.  v2:= v2.`d.o.d` @type ^`boolean` @kind boolean;
  #L3d7f2c.  if v2 == 0 then goto L3d7f34;
  #L3d7f30.  v2:= 0I;
  #L3d7f32.  goto L3d7f3c;
  #L3d7f34.  v2:= v3.`d.o.g` @type ^`d.o` @kind object;
  #L3d7f38.  v2:= v2.`d.o.b` @type ^`int`;
  #L3d7f3c.  v1:= v1 + v2 @kind int;
  #L3d7f3e.  if v0 <= v1 then goto L3d7f44;
  #L3d7f42.  return @kind void;
  #L3d7f44.  v1:= v3.`d.o.g` @type ^`d.o` @kind object;
  #L3d7f48.  call `a`(v3, v1, v0) @signature `Ld/o;.a:(Ld/o;I)V` @kind virtual;
  #L3d7f4e.  call temp:= `b`(v3) @signature `Ld/o;.b:()Ld/o;` @kind virtual;
  #L3d7f54.  call `a`(v3) @signature `Ld/p;.a:(Ld/o;)V` @kind static;
  #L3d7f5a.  return @kind void;
}

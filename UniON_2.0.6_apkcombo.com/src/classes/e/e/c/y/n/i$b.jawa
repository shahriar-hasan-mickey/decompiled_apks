record `e.e.c.y.n.i$b` @kind class @AccessFlag PUBLIC_FINAL extends `e.e.c.v` @kind class {
  `e.e.c.y.i` `e.e.c.y.n.i$b.a` @AccessFlag PRIVATE_FINAL;
  `java.util.Map` `e.e.c.y.n.i$b.b` @AccessFlag PRIVATE_FINAL;
}
procedure `void` `<init>`(`e.e.c.y.n.i$b` v0 @kind this, `e.e.c.y.i` v1 @kind object, `java.util.Map` v2 @kind object) @signature `Le/e/c/y/n/i$b;.<init>:(Le/e/c/y/i;Ljava/util/Map;)V` @AccessFlag CONSTRUCTOR {
    temp;

  #L3796d8.  call `<init>`(v0) @signature `Le/e/c/v;.<init>:()V` @kind direct;
  #L3796de.  v0.`e.e.c.y.n.i$b.a` @type ^`e.e.c.y.i` := v1 @kind object;
  #L3796e2.  v0.`e.e.c.y.n.i$b.b` @type ^`java.util.Map` := v2 @kind object;
  #L3796e6.  return @kind void;
}
procedure `java.lang.Object` `a`(`e.e.c.y.n.i$b` v3 @kind this, `e.e.c.a0.a` v4 @kind object) @signature `Le/e/c/y/n/i$b;.a:(Le/e/c/a0/a;)Ljava/lang/Object;` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L379624.  call temp:= `A`(v4) @signature `Le/e/c/a0/a;.A:()Le/e/c/a0/b;` @kind virtual;
  #L37962a.  v0:= temp @kind object;
  #L37962c.  v1:= `@@e.e.c.a0.b.j` @type ^`e.e.c.a0.b` @kind object;
  #L379630.  if v0 != v1 then goto L37963e;
  #L379634.  call `y`(v4) @signature `Le/e/c/a0/a;.y:()V` @kind virtual;
  #L37963a.  v4:= 0I;
  #L37963c.  return v4 @kind object;
  #L37963e.  v0:= v3.`e.e.c.y.n.i$b.a` @type ^`e.e.c.y.i` @kind object;
  #L379642.  call temp:= `a`(v0) @signature `Le/e/c/y/i;.a:()Ljava/lang/Object;` @kind interface;
  #L379648.  v0:= temp @kind object;
  #L37964a.  call `l`(v4) @signature `Le/e/c/a0/a;.l:()V` @kind virtual;
  #L379650.  call temp:= `q`(v4) @signature `Le/e/c/a0/a;.q:()Z` @kind virtual;
  #L379656.  v1:= temp;
  #L379658.  if v1 == 0 then goto L379692;
  #L37965c.  call temp:= `x`(v4) @signature `Le/e/c/a0/a;.x:()Ljava/lang/String;` @kind virtual;
  #L379662.  v1:= temp @kind object;
  #L379664.  v2:= v3.`e.e.c.y.n.i$b.b` @type ^`java.util.Map` @kind object;
  #L379668.  call temp:= `get`(v2, v1) @signature `Ljava/util/Map;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L37966e.  v1:= temp @kind object;
  #L379670.  v1:= (`e.e.c.y.n.i$c`) v1 @kind object;
  #L379674.  if v1 == 0 then goto L37968a;
  #L379678.  v2:= v1.`e.e.c.y.n.i$c.c` @type ^`boolean` @kind boolean;
  #L37967c.  if v2 != 0 then goto L379682;
  #L379680.  goto L37968a;
  #L379682.  call `a`(v1, v4, v0) @signature `Le/e/c/y/n/i$c;.a:(Le/e/c/a0/a;Ljava/lang/Object;)V` @kind virtual;
  #L379688.  goto L379650;
  #L37968a.  call `B`(v4) @signature `Le/e/c/a0/a;.B:()V` @kind virtual;
  #L379690.  goto L379650;
  #L379692.  call `o`(v4) @signature `Le/e/c/a0/a;.o:()V` @kind virtual;
  #L379698.  return v0 @kind object;
  #L37969a.  v4:= Exception @type ^`java.lang.IllegalAccessException` @kind object;
  #L37969c.  v0:= new `java.lang.AssertionError`;
  #L3796a0.  call `<init>`(v0, v4) @signature `Ljava/lang/AssertionError;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L3796a6.  throw v0;
  #L3796a8.  v4:= Exception @type ^`java.lang.IllegalStateException` @kind object;
  #L3796aa.  v0:= new `e.e.c.t`;
  #L3796ae.  call `<init>`(v0, v4) @signature `Le/e/c/t;.<init>:(Ljava/lang/Throwable;)V` @kind direct;
  #L3796b4.  throw v0;
  catch `java.lang.IllegalStateException` @[L37964a..L379690] goto L3796a8;
  catch `java.lang.IllegalAccessException` @[L37964a..L379690] goto L37969a;
}
procedure `void` `a`(`e.e.c.y.n.i$b` v3 @kind this, `e.e.c.a0.c` v4 @kind object, `java.lang.Object` v5 @kind object) @signature `Le/e/c/y/n/i$b;.a:(Le/e/c/a0/c;Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L3796f8.  if v5 != 0 then goto L379704;
  #L3796fc.  call temp:= `r`(v4) @signature `Le/e/c/a0/c;.r:()Le/e/c/a0/c;` @kind virtual;
  #L379702.  return @kind void;
  #L379704.  call temp:= `l`(v4) @signature `Le/e/c/a0/c;.l:()Le/e/c/a0/c;` @kind virtual;
  #L37970a.  v0:= v3.`e.e.c.y.n.i$b.b` @type ^`java.util.Map` @kind object;
  #L37970e.  call temp:= `values`(v0) @signature `Ljava/util/Map;.values:()Ljava/util/Collection;` @kind interface;
  #L379714.  v0:= temp @kind object;
  #L379716.  call temp:= `iterator`(v0) @signature `Ljava/util/Collection;.iterator:()Ljava/util/Iterator;` @kind interface;
  #L37971c.  v0:= temp @kind object;
  #L37971e.  call temp:= `hasNext`(v0) @signature `Ljava/util/Iterator;.hasNext:()Z` @kind interface;
  #L379724.  v1:= temp;
  #L379726.  if v1 == 0 then goto L379754;
  #L37972a.  call temp:= `next`(v0) @signature `Ljava/util/Iterator;.next:()Ljava/lang/Object;` @kind interface;
  #L379730.  v1:= temp @kind object;
  #L379732.  v1:= (`e.e.c.y.n.i$c`) v1 @kind object;
  #L379736.  call temp:= `a`(v1, v5) @signature `Le/e/c/y/n/i$c;.a:(Ljava/lang/Object;)Z` @kind virtual;
  #L37973c.  v2:= temp;
  #L37973e.  if v2 == 0 then goto L37971e;
  #L379742.  v2:= v1.`e.e.c.y.n.i$c.a` @type ^`java.lang.String` @kind object;
  #L379746.  call temp:= `b`(v4, v2) @signature `Le/e/c/a0/c;.b:(Ljava/lang/String;)Le/e/c/a0/c;` @kind virtual;
  #L37974c.  call `a`(v1, v4, v5) @signature `Le/e/c/y/n/i$c;.a:(Le/e/c/a0/c;Ljava/lang/Object;)V` @kind virtual;
  #L379752.  goto L37971e;
  #L379754.  call temp:= `n`(v4) @signature `Le/e/c/a0/c;.n:()Le/e/c/a0/c;` @kind virtual;
  #L37975a.  return @kind void;
  #L37975c.  v4:= Exception @type ^`java.lang.IllegalAccessException` @kind object;
  #L37975e.  v5:= new `java.lang.AssertionError`;
  #L379762.  call `<init>`(v5, v4) @signature `Ljava/lang/AssertionError;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L379768.  throw v5;
  catch `java.lang.IllegalAccessException` @[L37970a..L379752] goto L37975c;
}

record `e.e.a.b.f.b.v` @kind class @AccessFlag FINAL {
}
procedure `int` `a`(`int` v2 , `byte`[] v3 @kind object, `int` v4 , `int` v5 , `e.e.a.b.f.b.k1` v6 @kind object, `e.e.a.b.f.b.w` v7 @kind object) @signature `Le/e/a/b/f/b/v;.a:(I[BIILe/e/a/b/f/b/k1;Le/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L1f9ba8.  v6:= (`e.e.a.b.f.b.g1`) v6 @kind object;
  #L1f9bac.  call temp:= `a`(v3, v4, v7) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9bb2.  v4:= temp;
  #L1f9bb4.  v0:= v7.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9bb8.  call `i`(v6, v0) @signature `Le/e/a/b/f/b/g1;.i:(I)V` @kind virtual;
  #L1f9bbe.  if v4 >= v5 then goto L1f9bdc;
  #L1f9bc2.  call temp:= `a`(v3, v4, v7) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9bc8.  v0:= temp;
  #L1f9bca.  v1:= v7.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9bce.  if v2 != v1 then goto L1f9bdc;
  #L1f9bd2.  call temp:= `a`(v3, v0, v7) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9bd8.  v4:= temp;
  #L1f9bda.  goto L1f9bb4;
  #L1f9bdc.  return v4;
}
procedure `int` `a`(`int` v9 , `byte`[] v10 @kind object, `int` v11 , `int` v12 , `e.e.a.b.f.b.u3` v13 @kind object, `e.e.a.b.f.b.w` v14 @kind object) @signature `Le/e/a/b/f/b/v;.a:(I[BIILe/e/a/b/f/b/u3;Le/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L1f9bf0.  v0:= v9 ^>> 3;
  #L1f9bf4.  if v0 == 0 then goto L1f9cfa;
  #L1f9bf8.  v0:= v9 ^& 7;
  #L1f9bfc.  if v0 == 0 then goto L1f9cde;
  #L1f9c00.  v1:= 1I;
  #L1f9c02.  if v0 == v1 then goto L1f9cc2;
  #L1f9c06.  v1:= 2I;
  #L1f9c08.  if v0 == v1 then goto L1f9c9a;
  #L1f9c0c.  v1:= 3I;
  #L1f9c0e.  if v0 == v1 then goto L1f9c3e;
  #L1f9c12.  v12:= 5I;
  #L1f9c14.  if v0 != v12 then goto L1f9c34;
  #L1f9c18.  call temp:= `a`(v10, v11) @signature `Le/e/a/b/f/b/v;.a:([BI)I` @kind static;
  #L1f9c1e.  v10:= temp;
  #L1f9c20.  call temp:= `valueOf`(v10) @signature `Ljava/lang/Integer;.valueOf:(I)Ljava/lang/Integer;` @kind static;
  #L1f9c26.  v10:= temp @kind object;
  #L1f9c28.  call `a`(v13, v9, v10) @signature `Le/e/a/b/f/b/u3;.a:(ILjava/lang/Object;)V` @kind virtual;
  #L1f9c2e.  v11:= v11 + 4;
  #L1f9c32.  return v11;
  #L1f9c34.  call temp:= `b`() @signature `Le/e/a/b/f/b/l1;.b:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9c3a.  v9:= temp @kind object;
  #L1f9c3c.  throw v9;
  #L1f9c3e.  call temp:= `e`() @signature `Le/e/a/b/f/b/u3;.e:()Le/e/a/b/f/b/u3;` @kind static;
  #L1f9c44.  v6:= temp @kind object;
  #L1f9c46.  v0:= v9 ^& -8;
  #L1f9c4a.  v7:= v0 ^| 4;
  #L1f9c4e.  v0:= 0I;
  #L1f9c50.  if v11 >= v12 then goto L1f9c80;
  #L1f9c54.  call temp:= `a`(v10, v11, v14) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9c5a.  v2:= temp;
  #L1f9c5c.  v11:= v14.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9c60.  v0:= v11;
  #L1f9c62.  if v11 == v7 then goto L1f9c7e;
  #L1f9c66.  v1:= v10 @kind object;
  #L1f9c68.  v3:= v12;
  #L1f9c6a.  v4:= v6 @kind object;
  #L1f9c6c.  v5:= v14 @kind object;
  #L1f9c6e.  call temp:= `a`(v0, v1, v2, v3, v4, v5) @signature `Le/e/a/b/f/b/v;.a:(I[BIILe/e/a/b/f/b/u3;Le/e/a/b/f/b/w;)I` @kind static;
  #L1f9c74.  v0:= temp;
  #L1f9c76.  v8:= v0;
  #L1f9c78.  v0:= v11;
  #L1f9c7a.  v11:= v8;
  #L1f9c7c.  goto L1f9c50;
  #L1f9c7e.  v11:= v2;
  #L1f9c80.  if v11 > v12 then goto L1f9c90;
  #L1f9c84.  if v0 != v7 then goto L1f9c90;
  #L1f9c88.  call `a`(v13, v9, v6) @signature `Le/e/a/b/f/b/u3;.a:(ILjava/lang/Object;)V` @kind virtual;
  #L1f9c8e.  return v11;
  #L1f9c90.  call temp:= `d`() @signature `Le/e/a/b/f/b/l1;.d:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9c96.  v9:= temp @kind object;
  #L1f9c98.  throw v9;
  #L1f9c9a.  call temp:= `a`(v10, v11, v14) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9ca0.  v11:= temp;
  #L1f9ca2.  v12:= v14.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9ca6.  if v12 != 0 then goto L1f9cb0;
  #L1f9caa.  v10:= `@@e.e.a.b.f.b.a0.c` @type ^`e.e.a.b.f.b.a0` @kind object;
  #L1f9cae.  goto L1f9cb8;
  #L1f9cb0.  call temp:= `a`(v10, v11, v12) @signature `Le/e/a/b/f/b/a0;.a:([BII)Le/e/a/b/f/b/a0;` @kind static;
  #L1f9cb6.  v10:= temp @kind object;
  #L1f9cb8.  call `a`(v13, v9, v10) @signature `Le/e/a/b/f/b/u3;.a:(ILjava/lang/Object;)V` @kind virtual;
  #L1f9cbe.  v11:= v11 + v12 @kind int;
  #L1f9cc0.  return v11;
  #L1f9cc2.  call temp:= `b`(v10, v11) @signature `Le/e/a/b/f/b/v;.b:([BI)J` @kind static;
  #L1f9cc8.  v0:= temp @kind wide;
  #L1f9cca.  call temp:= `valueOf`(v0) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L1f9cd0.  v10:= temp @kind object;
  #L1f9cd2.  call `a`(v13, v9, v10) @signature `Le/e/a/b/f/b/u3;.a:(ILjava/lang/Object;)V` @kind virtual;
  #L1f9cd8.  v11:= v11 + 8;
  #L1f9cdc.  return v11;
  #L1f9cde.  call temp:= `b`(v10, v11, v14) @signature `Le/e/a/b/f/b/v;.b:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9ce4.  v10:= temp;
  #L1f9ce6.  v11:= v14.`e.e.a.b.f.b.w.b` @type ^`long` @kind wide;
  #L1f9cea.  call temp:= `valueOf`(v11) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L1f9cf0.  v11:= temp @kind object;
  #L1f9cf2.  call `a`(v13, v9, v11) @signature `Le/e/a/b/f/b/u3;.a:(ILjava/lang/Object;)V` @kind virtual;
  #L1f9cf8.  return v10;
  #L1f9cfa.  call temp:= `b`() @signature `Le/e/a/b/f/b/l1;.b:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9d00.  v9:= temp @kind object;
  #L1f9d02.  throw v9;
}
procedure `int` `a`(`int` v2 , `byte`[] v3 @kind object, `int` v4 , `int` v5 , `e.e.a.b.f.b.w` v6 @kind object) @signature `Le/e/a/b/f/b/v;.a:(I[BIILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L1f9af8.  v0:= v2 ^>> 3;
  #L1f9afc.  if v0 == 0 then goto L1f9b8c;
  #L1f9b00.  v0:= v2 ^& 7;
  #L1f9b04.  if v0 == 0 then goto L1f9b82;
  #L1f9b08.  v1:= 1I;
  #L1f9b0a.  if v0 == v1 then goto L1f9b7c;
  #L1f9b0e.  v1:= 2I;
  #L1f9b10.  if v0 == v1 then goto L1f9b6c;
  #L1f9b14.  v1:= 3I;
  #L1f9b16.  if v0 == v1 then goto L1f9b30;
  #L1f9b1a.  v2:= 5I;
  #L1f9b1c.  if v0 != v2 then goto L1f9b26;
  #L1f9b20.  v4:= v4 + 4;
  #L1f9b24.  return v4;
  #L1f9b26.  call temp:= `b`() @signature `Le/e/a/b/f/b/l1;.b:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9b2c.  v2:= temp @kind object;
  #L1f9b2e.  throw v2;
  #L1f9b30.  v2:= v2 ^& -8;
  #L1f9b34.  v2:= v2 ^| 4;
  #L1f9b38.  v0:= 0I;
  #L1f9b3a.  if v4 >= v5 then goto L1f9b58;
  #L1f9b3e.  call temp:= `a`(v3, v4, v6) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9b44.  v4:= temp;
  #L1f9b46.  v0:= v6.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9b4a.  if v0 == v2 then goto L1f9b58;
  #L1f9b4e.  call temp:= `a`(v0, v3, v4, v5, v6) @signature `Le/e/a/b/f/b/v;.a:(I[BIILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9b54.  v4:= temp;
  #L1f9b56.  goto L1f9b3a;
  #L1f9b58.  if v4 > v5 then goto L1f9b62;
  #L1f9b5c.  if v0 != v2 then goto L1f9b62;
  #L1f9b60.  return v4;
  #L1f9b62.  call temp:= `d`() @signature `Le/e/a/b/f/b/l1;.d:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9b68.  v2:= temp @kind object;
  #L1f9b6a.  throw v2;
  #L1f9b6c.  call temp:= `a`(v3, v4, v6) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9b72.  v2:= temp;
  #L1f9b74.  v3:= v6.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9b78.  v2:= v2 + v3 @kind int;
  #L1f9b7a.  return v2;
  #L1f9b7c.  v4:= v4 + 8;
  #L1f9b80.  return v4;
  #L1f9b82.  call temp:= `b`(v3, v4, v6) @signature `Le/e/a/b/f/b/v;.b:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9b88.  v2:= temp;
  #L1f9b8a.  return v2;
  #L1f9b8c.  call temp:= `b`() @signature `Le/e/a/b/f/b/l1;.b:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9b92.  v2:= temp @kind object;
  #L1f9b94.  throw v2;
}
procedure `int` `a`(`int` v1 , `byte`[] v2 @kind object, `int` v3 , `e.e.a.b.f.b.w` v4 @kind object) @signature `Le/e/a/b/f/b/v;.a:(I[BILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;

  #L1f9a50.  v1:= v1 ^& 127;
  #L1f9a54.  v0:= v3 + 1;
  #L1f9a58.  v3:= v2[v3] @kind byte;
  #L1f9a5c.  if v3 < 0 then goto L1f9a6c;
  #L1f9a60.  v2:= v3 ^< 7;
  #L1f9a64.  v1:= v1 ^| v2 @kind int;
  #L1f9a66.  v4.`e.e.a.b.f.b.w.a` @type ^`int` := v1;
  #L1f9a6a.  return v0;
  #L1f9a6c.  v3:= v3 ^& 127;
  #L1f9a70.  v3:= v3 ^< 7;
  #L1f9a74.  v1:= v1 ^| v3 @kind int;
  #L1f9a76.  v3:= v0 + 1;
  #L1f9a7a.  v0:= v2[v0] @kind byte;
  #L1f9a7e.  if v0 < 0 then goto L1f9a8e;
  #L1f9a82.  v2:= v0 ^< 14;
  #L1f9a86.  v1:= v1 ^| v2 @kind int;
  #L1f9a88.  v4.`e.e.a.b.f.b.w.a` @type ^`int` := v1;
  #L1f9a8c.  return v3;
  #L1f9a8e.  v0:= v0 ^& 127;
  #L1f9a92.  v0:= v0 ^< 14;
  #L1f9a96.  v1:= v1 ^| v0 @kind int;
  #L1f9a98.  v0:= v3 + 1;
  #L1f9a9c.  v3:= v2[v3] @kind byte;
  #L1f9aa0.  if v3 < 0 then goto L1f9aaa;
  #L1f9aa4.  v2:= v3 ^< 21;
  #L1f9aa8.  goto L1f9a64;
  #L1f9aaa.  v3:= v3 ^& 127;
  #L1f9aae.  v3:= v3 ^< 21;
  #L1f9ab2.  v1:= v1 ^| v3 @kind int;
  #L1f9ab4.  v3:= v0 + 1;
  #L1f9ab8.  v0:= v2[v0] @kind byte;
  #L1f9abc.  if v0 < 0 then goto L1f9ac6;
  #L1f9ac0.  v2:= v0 ^< 28;
  #L1f9ac4.  goto L1f9a86;
  #L1f9ac6.  v0:= v0 ^& 127;
  #L1f9aca.  v0:= v0 ^< 28;
  #L1f9ace.  v1:= v1 ^| v0 @kind int;
  #L1f9ad0.  v0:= v3 + 1;
  #L1f9ad4.  v3:= v2[v3] @kind byte;
  #L1f9ad8.  if v3 < 0 then goto L1f9ae2;
  #L1f9adc.  v4.`e.e.a.b.f.b.w.a` @type ^`int` := v1;
  #L1f9ae0.  return v0;
  #L1f9ae2.  v3:= v0;
  #L1f9ae4.  goto L1f9ad0;
}
procedure `int` `a`(`byte`[] v2 @kind object, `int` v3 ) @signature `Le/e/a/b/f/b/v;.a:([BI)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L1f9d84.  v0:= v2[v3] @kind byte;
  #L1f9d88.  v0:= v0 ^& 255;
  #L1f9d8c.  v1:= v3 + 1;
  #L1f9d90.  v1:= v2[v1] @kind byte;
  #L1f9d94.  v1:= v1 ^& 255;
  #L1f9d98.  v1:= v1 ^< 8;
  #L1f9d9c.  v0:= v0 ^| v1 @kind int;
  #L1f9d9e.  v1:= v3 + 2;
  #L1f9da2.  v1:= v2[v1] @kind byte;
  #L1f9da6.  v1:= v1 ^& 255;
  #L1f9daa.  v1:= v1 ^< 16;
  #L1f9dae.  v0:= v0 ^| v1 @kind int;
  #L1f9db0.  v3:= v3 + 3;
  #L1f9db4.  v2:= v2[v3] @kind byte;
  #L1f9db8.  v2:= v2 ^& 255;
  #L1f9dbc.  v2:= v2 ^< 24;
  #L1f9dc0.  v2:= v2 ^| v0 @kind int;
  #L1f9dc2.  return v2;
}
procedure `int` `a`(`byte`[] v2 @kind object, `int` v3 , `e.e.a.b.f.b.k1` v4 @kind object, `e.e.a.b.f.b.w` v5 @kind object) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/k1;Le/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L1f9a04.  v4:= (`e.e.a.b.f.b.g1`) v4 @kind object;
  #L1f9a08.  call temp:= `a`(v2, v3, v5) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9a0e.  v3:= temp;
  #L1f9a10.  v0:= v5.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9a14.  v0:= v0 + v3 @kind int;
  #L1f9a16.  if v3 >= v0 then goto L1f9a2e;
  #L1f9a1a.  call temp:= `a`(v2, v3, v5) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9a20.  v3:= temp;
  #L1f9a22.  v1:= v5.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9a26.  call `i`(v4, v1) @signature `Le/e/a/b/f/b/g1;.i:(I)V` @kind virtual;
  #L1f9a2c.  goto L1f9a16;
  #L1f9a2e.  if v3 != v0 then goto L1f9a34;
  #L1f9a32.  return v3;
  #L1f9a34.  call temp:= `a`() @signature `Le/e/a/b/f/b/l1;.a:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9a3a.  v2:= temp @kind object;
  #L1f9a3c.  throw v2;
}
procedure `int` `a`(`byte`[] v1 @kind object, `int` v2 , `e.e.a.b.f.b.w` v3 @kind object) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;

  #L1f99d8.  v0:= v2 + 1;
  #L1f99dc.  v2:= v1[v2] @kind byte;
  #L1f99e0.  if v2 < 0 then goto L1f99ea;
  #L1f99e4.  v3.`e.e.a.b.f.b.w.a` @type ^`int` := v2;
  #L1f99e8.  return v0;
  #L1f99ea.  call temp:= `a`(v2, v1, v0, v3) @signature `Le/e/a/b/f/b/v;.a:(I[BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f99f0.  v1:= temp;
  #L1f99f2.  return v1;
}
procedure `int` `b`(`byte`[] v9 @kind object, `int` v10 , `e.e.a.b.f.b.w` v11 @kind object) @signature `Le/e/a/b/f/b/v;.b:([BILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L1f9d14.  v0:= v10 + 1;
  #L1f9d18.  v10:= v9[v10] @kind byte;
  #L1f9d1c.  v1:= (`long`) v10 @kind i2l;
  #L1f9d1e.  v3:= 0L;
  #L1f9d22.  v10:= lcmp(v1, v3);
  #L1f9d26.  if v10 < 0 then goto L1f9d30;
  #L1f9d2a.  v11.`e.e.a.b.f.b.w.b` @type ^`long` := v1 @kind wide;
  #L1f9d2e.  return v0;
  #L1f9d30.  v3:= 127L;
  #L1f9d34.  v1:= v1 ^& v3 @kind long;
  #L1f9d36.  v10:= v0 + 1;
  #L1f9d3a.  v0:= v9[v0] @kind byte;
  #L1f9d3e.  v3:= v0 ^& 127;
  #L1f9d42.  v3:= (`long`) v3 @kind i2l;
  #L1f9d44.  v5:= 7I;
  #L1f9d46.  v3:= v3 ^< v5 @kind long;
  #L1f9d48.  v1:= v1 ^| v3 @kind long;
  #L1f9d4a.  v3:= 7I;
  #L1f9d4c.  if v0 >= 0 then goto L1f9d6c;
  #L1f9d50.  v0:= v10 + 1;
  #L1f9d54.  v10:= v9[v10] @kind byte;
  #L1f9d58.  v3:= v3 + v5 @kind int;
  #L1f9d5a.  v4:= v10 ^& 127;
  #L1f9d5e.  v6:= (`long`) v4 @kind i2l;
  #L1f9d60.  v6:= v6 ^< v3 @kind long;
  #L1f9d62.  v1:= v1 ^| v6 @kind long;
  #L1f9d64.  v8:= v0;
  #L1f9d66.  v0:= v10;
  #L1f9d68.  v10:= v8;
  #L1f9d6a.  goto L1f9d4c;
  #L1f9d6c.  v11.`e.e.a.b.f.b.w.b` @type ^`long` := v1 @kind wide;
  #L1f9d70.  return v10;
}
procedure `long` `b`(`byte`[] v7 @kind object, `int` v8 ) @signature `Le/e/a/b/f/b/v;.b:([BI)J` @AccessFlag STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L1f9ea8.  v0:= v7[v8] @kind byte;
  #L1f9eac.  v0:= (`long`) v0 @kind i2l;
  #L1f9eae.  v2:= 255L;
  #L1f9eb2.  v0:= v0 ^& v2 @kind long;
  #L1f9eb4.  v4:= v8 + 1;
  #L1f9eb8.  v4:= v7[v4] @kind byte;
  #L1f9ebc.  v4:= (`long`) v4 @kind i2l;
  #L1f9ebe.  v4:= v4 ^& v2 @kind long;
  #L1f9ec0.  v6:= 8I;
  #L1f9ec4.  v4:= v4 ^< v6 @kind long;
  #L1f9ec6.  v0:= v0 ^| v4 @kind long;
  #L1f9ec8.  v4:= v8 + 2;
  #L1f9ecc.  v4:= v7[v4] @kind byte;
  #L1f9ed0.  v4:= (`long`) v4 @kind i2l;
  #L1f9ed2.  v4:= v4 ^& v2 @kind long;
  #L1f9ed4.  v6:= 16I;
  #L1f9ed8.  v4:= v4 ^< v6 @kind long;
  #L1f9eda.  v0:= v0 ^| v4 @kind long;
  #L1f9edc.  v4:= v8 + 3;
  #L1f9ee0.  v4:= v7[v4] @kind byte;
  #L1f9ee4.  v4:= (`long`) v4 @kind i2l;
  #L1f9ee6.  v4:= v4 ^& v2 @kind long;
  #L1f9ee8.  v6:= 24I;
  #L1f9eec.  v4:= v4 ^< v6 @kind long;
  #L1f9eee.  v0:= v0 ^| v4 @kind long;
  #L1f9ef0.  v4:= v8 + 4;
  #L1f9ef4.  v4:= v7[v4] @kind byte;
  #L1f9ef8.  v4:= (`long`) v4 @kind i2l;
  #L1f9efa.  v4:= v4 ^& v2 @kind long;
  #L1f9efc.  v6:= 32I;
  #L1f9f00.  v4:= v4 ^< v6 @kind long;
  #L1f9f02.  v0:= v0 ^| v4 @kind long;
  #L1f9f04.  v4:= v8 + 5;
  #L1f9f08.  v4:= v7[v4] @kind byte;
  #L1f9f0c.  v4:= (`long`) v4 @kind i2l;
  #L1f9f0e.  v4:= v4 ^& v2 @kind long;
  #L1f9f10.  v6:= 40I;
  #L1f9f14.  v4:= v4 ^< v6 @kind long;
  #L1f9f16.  v0:= v0 ^| v4 @kind long;
  #L1f9f18.  v4:= v8 + 6;
  #L1f9f1c.  v4:= v7[v4] @kind byte;
  #L1f9f20.  v4:= (`long`) v4 @kind i2l;
  #L1f9f22.  v4:= v4 ^& v2 @kind long;
  #L1f9f24.  v6:= 48I;
  #L1f9f28.  v4:= v4 ^< v6 @kind long;
  #L1f9f2a.  v0:= v0 ^| v4 @kind long;
  #L1f9f2c.  v8:= v8 + 7;
  #L1f9f30.  v7:= v7[v8] @kind byte;
  #L1f9f34.  v7:= (`long`) v7 @kind i2l;
  #L1f9f36.  v7:= v7 ^& v2 @kind long;
  #L1f9f38.  v2:= 56I;
  #L1f9f3c.  v7:= v7 ^< v2 @kind long;
  #L1f9f3e.  v7:= v7 ^| v0 @kind long;
  #L1f9f40.  return v7 @kind wide;
}
procedure `double` `c`(`byte`[] v0 @kind object, `int` v1 ) @signature `Le/e/a/b/f/b/v;.c:([BI)D` @AccessFlag STATIC {
    temp;

  #L1f9990.  call temp:= `b`(v0, v1) @signature `Le/e/a/b/f/b/v;.b:([BI)J` @kind static;
  #L1f9996.  v0:= temp @kind wide;
  #L1f9998.  call temp:= `longBitsToDouble`(v0) @signature `Ljava/lang/Double;.longBitsToDouble:(J)D` @kind static;
  #L1f999e.  v0:= temp @kind wide;
  #L1f99a0.  return v0 @kind wide;
}
procedure `int` `c`(`byte`[] v3 @kind object, `int` v4 , `e.e.a.b.f.b.w` v5 @kind object) @signature `Le/e/a/b/f/b/v;.c:([BILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;
    v2;

  #L1f9dd4.  call temp:= `a`(v3, v4, v5) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9dda.  v4:= temp;
  #L1f9ddc.  v0:= v5.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9de0.  if v0 != 0 then goto L1f9dee;
  #L1f9de4.  v3:= "" @kind object;
  #L1f9de8.  v5.`e.e.a.b.f.b.w.c` @type ^`java.lang.Object` := v3 @kind object;
  #L1f9dec.  return v4;
  #L1f9dee.  v1:= new `java.lang.String`;
  #L1f9df2.  v2:= `@@e.e.a.b.f.b.h1.a` @type ^`java.nio.charset.Charset` @kind object;
  #L1f9df6.  call `<init>`(v1, v3, v4, v0, v2) @signature `Ljava/lang/String;.<init>:([BIILjava/nio/charset/Charset;)V` @kind direct;
  #L1f9dfc.  v5.`e.e.a.b.f.b.w.c` @type ^`java.lang.Object` := v1 @kind object;
  #L1f9e00.  v4:= v4 + v0 @kind int;
  #L1f9e02.  return v4;
}
procedure `float` `d`(`byte`[] v0 @kind object, `int` v1 ) @signature `Le/e/a/b/f/b/v;.d:([BI)F` @AccessFlag STATIC {
    temp;

  #L1f99b4.  call temp:= `a`(v0, v1) @signature `Le/e/a/b/f/b/v;.a:([BI)I` @kind static;
  #L1f99ba.  v0:= temp;
  #L1f99bc.  call temp:= `intBitsToFloat`(v0) @signature `Ljava/lang/Float;.intBitsToFloat:(I)F` @kind static;
  #L1f99c2.  v0:= temp;
  #L1f99c4.  return v0;
}
procedure `int` `d`(`byte`[] v4 @kind object, `int` v5 , `e.e.a.b.f.b.w` v6 @kind object) @signature `Le/e/a/b/f/b/v;.d:([BILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L1f9e14.  call temp:= `a`(v4, v5, v6) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9e1a.  v5:= temp;
  #L1f9e1c.  v0:= v6.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9e20.  if v0 != 0 then goto L1f9e2e;
  #L1f9e24.  v4:= "" @kind object;
  #L1f9e28.  v6.`e.e.a.b.f.b.w.c` @type ^`java.lang.Object` := v4 @kind object;
  #L1f9e2c.  return v5;
  #L1f9e2e.  v1:= v5 + v0 @kind int;
  #L1f9e32.  call temp:= `a`(v4, v5, v1) @signature `Le/e/a/b/f/b/c4;.a:([BII)Z` @kind static;
  #L1f9e38.  v2:= temp;
  #L1f9e3a.  if v2 == 0 then goto L1f9e52;
  #L1f9e3e.  v2:= new `java.lang.String`;
  #L1f9e42.  v3:= `@@e.e.a.b.f.b.h1.a` @type ^`java.nio.charset.Charset` @kind object;
  #L1f9e46.  call `<init>`(v2, v4, v5, v0, v3) @signature `Ljava/lang/String;.<init>:([BIILjava/nio/charset/Charset;)V` @kind direct;
  #L1f9e4c.  v6.`e.e.a.b.f.b.w.c` @type ^`java.lang.Object` := v2 @kind object;
  #L1f9e50.  return v1;
  #L1f9e52.  call temp:= `e`() @signature `Le/e/a/b/f/b/l1;.e:()Le/e/a/b/f/b/l1;` @kind static;
  #L1f9e58.  v4:= temp @kind object;
  #L1f9e5a.  throw v4;
}
procedure `int` `e`(`byte`[] v1 @kind object, `int` v2 , `e.e.a.b.f.b.w` v3 @kind object) @signature `Le/e/a/b/f/b/v;.e:([BILe/e/a/b/f/b/w;)I` @AccessFlag STATIC {
    temp;
    v0;

  #L1f9e6c.  call temp:= `a`(v1, v2, v3) @signature `Le/e/a/b/f/b/v;.a:([BILe/e/a/b/f/b/w;)I` @kind static;
  #L1f9e72.  v2:= temp;
  #L1f9e74.  v0:= v3.`e.e.a.b.f.b.w.a` @type ^`int`;
  #L1f9e78.  if v0 != 0 then goto L1f9e86;
  #L1f9e7c.  v1:= `@@e.e.a.b.f.b.a0.c` @type ^`e.e.a.b.f.b.a0` @kind object;
  #L1f9e80.  v3.`e.e.a.b.f.b.w.c` @type ^`java.lang.Object` := v1 @kind object;
  #L1f9e84.  return v2;
  #L1f9e86.  call temp:= `a`(v1, v2, v0) @signature `Le/e/a/b/f/b/a0;.a:([BII)Le/e/a/b/f/b/a0;` @kind static;
  #L1f9e8c.  v1:= temp @kind object;
  #L1f9e8e.  v3.`e.e.a.b.f.b.w.c` @type ^`java.lang.Object` := v1 @kind object;
  #L1f9e92.  v2:= v2 + v0 @kind int;
  #L1f9e94.  return v2;
}

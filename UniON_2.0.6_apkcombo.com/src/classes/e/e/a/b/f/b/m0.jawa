record `e.e.a.b.f.b.m0` @kind class @AccessFlag PUBLIC_ABSTRACT extends `e.e.a.b.f.b.z` @kind class {
  `e.e.a.b.f.b.o0` `e.e.a.b.f.b.m0.a` @AccessFlag ;
}
global `java.util.logging.Logger` `@@e.e.a.b.f.b.m0.b` @AccessFlag PRIVATE_STATIC_FINAL;
global `boolean` `@@e.e.a.b.f.b.m0.c` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Le/e/a/b/f/b/m0;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;

  #L1fd0a4.  v0:= constclass @type ^`e.e.a.b.f.b.m0` @kind object;
  #L1fd0a8.  call temp:= `getName`(v0) @signature `Ljava/lang/Class;.getName:()Ljava/lang/String;` @kind virtual;
  #L1fd0ae.  v0:= temp @kind object;
  #L1fd0b0.  call temp:= `getLogger`(v0) @signature `Ljava/util/logging/Logger;.getLogger:(Ljava/lang/String;)Ljava/util/logging/Logger;` @kind static;
  #L1fd0b6.  v0:= temp @kind object;
  #L1fd0b8.  `@@e.e.a.b.f.b.m0.b` @type ^`java.util.logging.Logger` := v0 @kind object;
  #L1fd0bc.  call temp:= `b`() @signature `Le/e/a/b/f/b/a4;.b:()Z` @kind static;
  #L1fd0c2.  v0:= temp;
  #L1fd0c4.  `@@e.e.a.b.f.b.m0.c` @type ^`boolean` := v0 @kind boolean;
  #L1fd0c8.  return @kind void;
}
procedure `void` `<init>`(`e.e.a.b.f.b.m0` v0 @kind this) @signature `Le/e/a/b/f/b/m0;.<init>:()V` @AccessFlag PRIVATE_CONSTRUCTOR {
    temp;

  #L1fd0dc.  call `<init>`(v0) @signature `Le/e/a/b/f/b/z;.<init>:()V` @kind direct;
  #L1fd0e2.  return @kind void;
}
procedure `void` `<init>`(`e.e.a.b.f.b.m0` v0 @kind this, `e.e.a.b.f.b.n0` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.<init>:(Le/e/a/b/f/b/n0;)V` @AccessFlag SYNTHETIC_CONSTRUCTOR {
    temp;

  #L1fd0f4.  call `<init>`(v0) @signature `Le/e/a/b/f/b/m0;.<init>:()V` @kind direct;
  #L1fd0fa.  return @kind void;
}
procedure `int` `a`(`int` v1 , `e.e.a.b.f.b.s1` v2 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(ILe/e/a/b/f/b/s1;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fc980.  call temp:= `e`(v1) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fc986.  v1:= temp;
  #L1fc988.  call temp:= `a`(v2) @signature `Le/e/a/b/f/b/s1;.a:()I` @kind virtual;
  #L1fc98e.  v2:= temp;
  #L1fc990.  call temp:= `g`(v2) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fc996.  v0:= temp;
  #L1fc998.  v0:= v0 + v2 @kind int;
  #L1fc99a.  v1:= v1 + v0 @kind int;
  #L1fc99c.  return v1;
}
procedure `int` `a`(`e.e.a.b.f.b.a0` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Le/e/a/b/f/b/a0;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fc9c4.  call temp:= `size`(v1) @signature `Le/e/a/b/f/b/a0;.size:()I` @kind virtual;
  #L1fc9ca.  v1:= temp;
  #L1fc9cc.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fc9d2.  v0:= temp;
  #L1fc9d4.  v0:= v0 + v1 @kind int;
  #L1fc9d6.  return v0;
}
procedure `int` `a`(`e.e.a.b.f.b.k2` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Le/e/a/b/f/b/k2;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fcb10.  call temp:= `q`(v1) @signature `Le/e/a/b/f/b/k2;.q:()I` @kind interface;
  #L1fcb16.  v1:= temp;
  #L1fcb18.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcb1e.  v0:= temp;
  #L1fcb20.  v0:= v0 + v1 @kind int;
  #L1fcb22.  return v0;
}
procedure `int` `a`(`e.e.a.b.f.b.k2` v2 @kind object, `e.e.a.b.f.b.b3` v3 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Le/e/a/b/f/b/k2;Le/e/a/b/f/b/b3;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L1fc9e8.  v2:= (`e.e.a.b.f.b.q`) v2 @kind object;
  #L1fc9ec.  call temp:= `c`(v2) @signature `Le/e/a/b/f/b/q;.c:()I` @kind virtual;
  #L1fc9f2.  v0:= temp;
  #L1fc9f4.  v1:= -1I;
  #L1fc9f6.  if v0 != v1 then goto L1fca08;
  #L1fc9fa.  call temp:= `d`(v3, v2) @signature `Le/e/a/b/f/b/b3;.d:(Ljava/lang/Object;)I` @kind interface;
  #L1fca00.  v0:= temp;
  #L1fca02.  call `a`(v2, v0) @signature `Le/e/a/b/f/b/q;.a:(I)V` @kind virtual;
  #L1fca08.  call temp:= `g`(v0) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fca0e.  v2:= temp;
  #L1fca10.  v2:= v2 + v0 @kind int;
  #L1fca12.  return v2;
}
procedure `int` `a`(`e.e.a.b.f.b.s1` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Le/e/a/b/f/b/s1;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fc95c.  call temp:= `a`(v1) @signature `Le/e/a/b/f/b/s1;.a:()I` @kind virtual;
  #L1fc962.  v1:= temp;
  #L1fc964.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fc96a.  v0:= temp;
  #L1fc96c.  v0:= v0 + v1 @kind int;
  #L1fc96e.  return v0;
}
procedure `int` `a`(`java.lang.String` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Ljava/lang/String;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fce54.  call temp:= `a`(v1) @signature `Le/e/a/b/f/b/c4;.a:(Ljava/lang/CharSequence;)I` @kind static;
  #L1fce5a.  v1:= temp;
  #L1fce5c.  goto L1fce6c;
  #L1fce5e.  v0:= `@@e.e.a.b.f.b.h1.a` @type ^`java.nio.charset.Charset` @kind object;
  #L1fce62.  call temp:= `getBytes`(v1, v0) @signature `Ljava/lang/String;.getBytes:(Ljava/nio/charset/Charset;)[B` @kind virtual;
  #L1fce68.  v1:= temp @kind object;
  #L1fce6a.  v1:= length @variable v1;
  #L1fce6c.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fce72.  v0:= temp;
  #L1fce74.  v0:= v0 + v1 @kind int;
  #L1fce76.  return v0;
  catch `e.e.a.b.f.b.f4` @[L1fce54..L1fce5c] goto L1fce5e;
}
procedure `e.e.a.b.f.b.m0` `a`(`java.nio.ByteBuffer` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Ljava/nio/ByteBuffer;)Le/e/a/b/f/b/m0;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fc8c8.  call temp:= `hasArray`(v1) @signature `Ljava/nio/ByteBuffer;.hasArray:()Z` @kind virtual;
  #L1fc8ce.  v0:= temp;
  #L1fc8d0.  if v0 == 0 then goto L1fc8e0;
  #L1fc8d4.  v0:= new `e.e.a.b.f.b.m0$b`;
  #L1fc8d8.  call `<init>`(v0, v1) @signature `Le/e/a/b/f/b/m0$b;.<init>:(Ljava/nio/ByteBuffer;)V` @kind direct;
  #L1fc8de.  return v0 @kind object;
  #L1fc8e0.  call temp:= `isDirect`(v1) @signature `Ljava/nio/ByteBuffer;.isDirect:()Z` @kind virtual;
  #L1fc8e6.  v0:= temp;
  #L1fc8e8.  if v0 == 0 then goto L1fc91c;
  #L1fc8ec.  call temp:= `isReadOnly`(v1) @signature `Ljava/nio/ByteBuffer;.isReadOnly:()Z` @kind virtual;
  #L1fc8f2.  v0:= temp;
  #L1fc8f4.  if v0 != 0 then goto L1fc91c;
  #L1fc8f8.  call temp:= `c`() @signature `Le/e/a/b/f/b/a4;.c:()Z` @kind static;
  #L1fc8fe.  v0:= temp;
  #L1fc900.  if v0 == 0 then goto L1fc910;
  #L1fc904.  v0:= new `e.e.a.b.f.b.m0$e`;
  #L1fc908.  call `<init>`(v0, v1) @signature `Le/e/a/b/f/b/m0$e;.<init>:(Ljava/nio/ByteBuffer;)V` @kind direct;
  #L1fc90e.  return v0 @kind object;
  #L1fc910.  v0:= new `e.e.a.b.f.b.m0$d`;
  #L1fc914.  call `<init>`(v0, v1) @signature `Le/e/a/b/f/b/m0$d;.<init>:(Ljava/nio/ByteBuffer;)V` @kind direct;
  #L1fc91a.  return v0 @kind object;
  #L1fc91c.  v1:= new `java.lang.IllegalArgumentException`;
  #L1fc920.  v0:= "ByteBuffer is read-only" @kind object;
  #L1fc924.  call `<init>`(v1, v0) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L1fc92a.  throw v1;
}
procedure `e.e.a.b.f.b.m0` `a`(`byte`[] v3 @kind object) @signature `Le/e/a/b/f/b/m0;.a:([B)Le/e/a/b/f/b/m0;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L1fc93c.  v0:= length @variable v3;
  #L1fc93e.  v1:= new `e.e.a.b.f.b.m0$a`;
  #L1fc942.  v2:= 0I;
  #L1fc944.  call `<init>`(v1, v3, v2, v0) @signature `Le/e/a/b/f/b/m0$a;.<init>:([BII)V` @kind direct;
  #L1fc94a.  return v1 @kind object;
}
procedure `int` `b`(`double` v0 ) @signature `Le/e/a/b/f/b/m0;.b:(D)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fca24.  v0:= 8I;
  #L1fca28.  return v0;
}
procedure `int` `b`(`float` v0 ) @signature `Le/e/a/b/f/b/m0;.b:(F)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fca3c.  v0:= 4I;
  #L1fca3e.  return v0;
}
procedure `int` `b`(`int` v0 , `double` v1 ) @signature `Le/e/a/b/f/b/m0;.b:(ID)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcaac.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcab2.  v0:= temp;
  #L1fcab4.  v0:= v0 + 8;
  #L1fcab8.  return v0;
}
procedure `int` `b`(`int` v0 , `float` v1 ) @signature `Le/e/a/b/f/b/m0;.b:(IF)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcacc.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcad2.  v0:= temp;
  #L1fcad4.  v0:= v0 + 4;
  #L1fcad8.  return v0;
}
procedure `int` `b`(`int` v0 , `e.e.a.b.f.b.k2` v1 @kind object, `e.e.a.b.f.b.b3` v2 @kind object) @signature `Le/e/a/b/f/b/m0;.b:(ILe/e/a/b/f/b/k2;Le/e/a/b/f/b/b3;)I` @AccessFlag STATIC {
    temp;

  #L1fca88.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fca8e.  v0:= temp;
  #L1fca90.  call temp:= `a`(v1, v2) @signature `Le/e/a/b/f/b/m0;.a:(Le/e/a/b/f/b/k2;Le/e/a/b/f/b/b3;)I` @kind static;
  #L1fca96.  v1:= temp;
  #L1fca98.  v0:= v0 + v1 @kind int;
  #L1fca9a.  return v0;
}
procedure `int` `b`(`int` v2 , `e.e.a.b.f.b.s1` v3 @kind object) @signature `Le/e/a/b/f/b/m0;.b:(ILe/e/a/b/f/b/s1;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L1fca50.  v0:= 1I;
  #L1fca52.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fca58.  v1:= temp;
  #L1fca5a.  v0:= v1 ^< 1;
  #L1fca5e.  v1:= 2I;
  #L1fca60.  call temp:= `g`(v1, v2) @signature `Le/e/a/b/f/b/m0;.g:(II)I` @kind static;
  #L1fca66.  v2:= temp;
  #L1fca68.  v0:= v0 + v2 @kind int;
  #L1fca6a.  v2:= 3I;
  #L1fca6c.  call temp:= `a`(v2, v3) @signature `Le/e/a/b/f/b/m0;.a:(ILe/e/a/b/f/b/s1;)I` @kind static;
  #L1fca72.  v2:= temp;
  #L1fca74.  v0:= v0 + v2 @kind int;
  #L1fca76.  return v0;
}
procedure `int` `b`(`int` v0 , `java.lang.String` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.b:(ILjava/lang/String;)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcaec.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcaf2.  v0:= temp;
  #L1fcaf4.  call temp:= `a`(v1) @signature `Le/e/a/b/f/b/m0;.a:(Ljava/lang/String;)I` @kind static;
  #L1fcafa.  v1:= temp;
  #L1fcafc.  v0:= v0 + v1 @kind int;
  #L1fcafe.  return v0;
}
procedure `int` `b`(`int` v0 , `boolean` v1 ) @signature `Le/e/a/b/f/b/m0;.b:(IZ)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcb34.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcb3a.  v0:= temp;
  #L1fcb3c.  v0:= v0 + 1;
  #L1fcb40.  return v0;
}
procedure `int` `b`(`e.e.a.b.f.b.k2` v0 @kind object) @signature `Le/e/a/b/f/b/m0;.b:(Le/e/a/b/f/b/k2;)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcc08.  call temp:= `q`(v0) @signature `Le/e/a/b/f/b/k2;.q:()I` @kind interface;
  #L1fcc0e.  v0:= temp;
  #L1fcc10.  return v0;
}
procedure `int` `b`(`boolean` v0 ) @signature `Le/e/a/b/f/b/m0;.b:(Z)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fc9b0.  v0:= 1I;
  #L1fc9b2.  return v0;
}
procedure `int` `b`(`byte`[] v1 @kind object) @signature `Le/e/a/b/f/b/m0;.b:([B)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fcbe8.  v1:= length @variable v1;
  #L1fcbea.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcbf0.  v0:= temp;
  #L1fcbf2.  v0:= v0 + v1 @kind int;
  #L1fcbf4.  return v0;
}
procedure `int` `c`(`int` v1 , `e.e.a.b.f.b.a0` v2 @kind object) @signature `Le/e/a/b/f/b/m0;.c:(ILe/e/a/b/f/b/a0;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fcb54.  call temp:= `e`(v1) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcb5a.  v1:= temp;
  #L1fcb5c.  call temp:= `size`(v2) @signature `Le/e/a/b/f/b/a0;.size:()I` @kind virtual;
  #L1fcb62.  v2:= temp;
  #L1fcb64.  call temp:= `g`(v2) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcb6a.  v0:= temp;
  #L1fcb6c.  v0:= v0 + v2 @kind int;
  #L1fcb6e.  v1:= v1 + v0 @kind int;
  #L1fcb70.  return v1;
}
procedure `int` `c`(`int` v0 , `e.e.a.b.f.b.k2` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.c:(ILe/e/a/b/f/b/k2;)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcb84.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcb8a.  v0:= temp;
  #L1fcb8c.  call temp:= `a`(v1) @signature `Le/e/a/b/f/b/m0;.a:(Le/e/a/b/f/b/k2;)I` @kind static;
  #L1fcb92.  v1:= temp;
  #L1fcb94.  v0:= v0 + v1 @kind int;
  #L1fcb96.  return v0;
}
procedure `int` `c`(`int` v2 , `e.e.a.b.f.b.k2` v3 @kind object, `e.e.a.b.f.b.b3` v4 @kind object) @signature `Le/e/a/b/f/b/m0;.c:(ILe/e/a/b/f/b/k2;Le/e/a/b/f/b/b3;)I` @AccessFlag STATIC {
    temp;
    v0;
    v1;

  #L1fcba8.  call temp:= `e`(v2) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcbae.  v2:= temp;
  #L1fcbb0.  v2:= v2 ^< 1;
  #L1fcbb4.  v3:= (`e.e.a.b.f.b.q`) v3 @kind object;
  #L1fcbb8.  call temp:= `c`(v3) @signature `Le/e/a/b/f/b/q;.c:()I` @kind virtual;
  #L1fcbbe.  v0:= temp;
  #L1fcbc0.  v1:= -1I;
  #L1fcbc2.  if v0 != v1 then goto L1fcbd4;
  #L1fcbc6.  call temp:= `d`(v4, v3) @signature `Le/e/a/b/f/b/b3;.d:(Ljava/lang/Object;)I` @kind interface;
  #L1fcbcc.  v0:= temp;
  #L1fcbce.  call `a`(v3, v0) @signature `Le/e/a/b/f/b/q;.a:(I)V` @kind virtual;
  #L1fcbd4.  v2:= v2 + v0 @kind int;
  #L1fcbd6.  return v2;
}
procedure `boolean` `c`() @signature `Le/e/a/b/f/b/m0;.c:()Z` @AccessFlag STATIC_SYNTHETIC {
    temp;
    v0;

  #L1fc8b0.  v0:= `@@e.e.a.b.f.b.m0.c` @type ^`boolean` @kind boolean;
  #L1fc8b4.  return v0;
}
procedure `int` `d`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.d:(IJ)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcc94.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcc9a.  v0:= temp;
  #L1fcc9c.  call temp:= `e`(v1) @signature `Le/e/a/b/f/b/m0;.e:(J)I` @kind static;
  #L1fcca2.  v1:= temp;
  #L1fcca4.  v0:= v0 + v1 @kind int;
  #L1fcca6.  return v0;
}
procedure `int` `d`(`int` v2 , `e.e.a.b.f.b.a0` v3 @kind object) @signature `Le/e/a/b/f/b/m0;.d:(ILe/e/a/b/f/b/a0;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L1fcc24.  v0:= 1I;
  #L1fcc26.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcc2c.  v1:= temp;
  #L1fcc2e.  v0:= v1 ^< 1;
  #L1fcc32.  v1:= 2I;
  #L1fcc34.  call temp:= `g`(v1, v2) @signature `Le/e/a/b/f/b/m0;.g:(II)I` @kind static;
  #L1fcc3a.  v2:= temp;
  #L1fcc3c.  v0:= v0 + v2 @kind int;
  #L1fcc3e.  v2:= 3I;
  #L1fcc40.  call temp:= `c`(v2, v3) @signature `Le/e/a/b/f/b/m0;.c:(ILe/e/a/b/f/b/a0;)I` @kind static;
  #L1fcc46.  v2:= temp;
  #L1fcc48.  v0:= v0 + v2 @kind int;
  #L1fcc4a.  return v0;
}
procedure `int` `d`(`int` v2 , `e.e.a.b.f.b.k2` v3 @kind object) @signature `Le/e/a/b/f/b/m0;.d:(ILe/e/a/b/f/b/k2;)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;

  #L1fcc5c.  v0:= 1I;
  #L1fcc5e.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcc64.  v1:= temp;
  #L1fcc66.  v0:= v1 ^< 1;
  #L1fcc6a.  v1:= 2I;
  #L1fcc6c.  call temp:= `g`(v1, v2) @signature `Le/e/a/b/f/b/m0;.g:(II)I` @kind static;
  #L1fcc72.  v2:= temp;
  #L1fcc74.  v0:= v0 + v2 @kind int;
  #L1fcc76.  v2:= 3I;
  #L1fcc78.  call temp:= `c`(v2, v3) @signature `Le/e/a/b/f/b/m0;.c:(ILe/e/a/b/f/b/k2;)I` @kind static;
  #L1fcc7e.  v2:= temp;
  #L1fcc80.  v0:= v0 + v2 @kind int;
  #L1fcc82.  return v0;
}
procedure `int` `d`(`long` v0 ) @signature `Le/e/a/b/f/b/m0;.d:(J)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fccdc.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(J)I` @kind static;
  #L1fcce2.  v0:= temp;
  #L1fcce4.  return v0;
}
procedure `int` `e`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcf58.  v0:= v0 ^< 3;
  #L1fcf5c.  call temp:= `g`(v0) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcf62.  v0:= temp;
  #L1fcf64.  return v0;
}
procedure `int` `e`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.e:(IJ)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fccb8.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fccbe.  v0:= temp;
  #L1fccc0.  call temp:= `e`(v1) @signature `Le/e/a/b/f/b/m0;.e:(J)I` @kind static;
  #L1fccc6.  v1:= temp;
  #L1fccc8.  v0:= v0 + v1 @kind int;
  #L1fccca.  return v0;
}
procedure `int` `e`(`long` v6 ) @signature `Le/e/a/b/f/b/m0;.e:(J)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L1fcd24.  v0:= -128L;
  #L1fcd28.  v0:= v0 ^& v6 @kind long;
  #L1fcd2a.  v2:= 0L;
  #L1fcd2e.  v4:= lcmp(v0, v2);
  #L1fcd32.  if v4 != 0 then goto L1fcd3a;
  #L1fcd36.  v6:= 1I;
  #L1fcd38.  return v6;
  #L1fcd3a.  v0:= lcmp(v6, v2);
  #L1fcd3e.  if v0 >= 0 then goto L1fcd48;
  #L1fcd42.  v6:= 10I;
  #L1fcd46.  return v6;
  #L1fcd48.  v0:= -34359738368L;
  #L1fcd52.  v0:= v0 ^& v6 @kind long;
  #L1fcd54.  v4:= lcmp(v0, v2);
  #L1fcd58.  if v4 == 0 then goto L1fcd66;
  #L1fcd5c.  v0:= 6I;
  #L1fcd5e.  v1:= 28I;
  #L1fcd62.  v6:= v6 ^>> v1 @kind long;
  #L1fcd64.  goto L1fcd68;
  #L1fcd66.  v0:= 2I;
  #L1fcd68.  v4:= -2097152L;
  #L1fcd6e.  v4:= v4 ^& v6 @kind long;
  #L1fcd70.  v1:= lcmp(v4, v2);
  #L1fcd74.  if v1 == 0 then goto L1fcd82;
  #L1fcd78.  v0:= v0 + 2;
  #L1fcd7c.  v1:= 14I;
  #L1fcd80.  v6:= v6 ^>> v1 @kind long;
  #L1fcd82.  v4:= -16384L;
  #L1fcd86.  v6:= v6 ^& v4 @kind long;
  #L1fcd88.  v1:= lcmp(v6, v2);
  #L1fcd8c.  if v1 == 0 then goto L1fcd94;
  #L1fcd90.  v0:= v0 + 1;
  #L1fcd94.  return v0;
}
procedure `int` `f`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.f:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcf78.  if v0 < 0 then goto L1fcf86;
  #L1fcf7c.  call temp:= `g`(v0) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcf82.  v0:= temp;
  #L1fcf84.  return v0;
  #L1fcf86.  v0:= 10I;
  #L1fcf8a.  return v0;
}
procedure `int` `f`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.f:(II)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcda8.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcdae.  v0:= temp;
  #L1fcdb0.  call temp:= `f`(v1) @signature `Le/e/a/b/f/b/m0;.f:(I)I` @kind static;
  #L1fcdb6.  v1:= temp;
  #L1fcdb8.  v0:= v0 + v1 @kind int;
  #L1fcdba.  return v0;
}
procedure `int` `f`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.f:(IJ)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fccf8.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fccfe.  v0:= temp;
  #L1fcd00.  call temp:= `i`(v1) @signature `Le/e/a/b/f/b/m0;.i:(J)J` @kind static;
  #L1fcd06.  v1:= temp @kind wide;
  #L1fcd08.  call temp:= `e`(v1) @signature `Le/e/a/b/f/b/m0;.e:(J)I` @kind static;
  #L1fcd0e.  v1:= temp;
  #L1fcd10.  v0:= v0 + v1 @kind int;
  #L1fcd12.  return v0;
}
procedure `int` `f`(`long` v0 ) @signature `Le/e/a/b/f/b/m0;.f:(J)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcdec.  call temp:= `i`(v0) @signature `Le/e/a/b/f/b/m0;.i:(J)J` @kind static;
  #L1fcdf2.  v0:= temp @kind wide;
  #L1fcdf4.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(J)I` @kind static;
  #L1fcdfa.  v0:= temp;
  #L1fcdfc.  return v0;
}
procedure `int` `g`(`int` v1 ) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L1fcf9c.  v0:= v1 ^& -128;
  #L1fcfa0.  if v0 != 0 then goto L1fcfa8;
  #L1fcfa4.  v1:= 1I;
  #L1fcfa6.  return v1;
  #L1fcfa8.  v0:= v1 ^& -16384;
  #L1fcfac.  if v0 != 0 then goto L1fcfb4;
  #L1fcfb0.  v1:= 2I;
  #L1fcfb2.  return v1;
  #L1fcfb4.  v0:= -2097152I;
  #L1fcfb8.  v0:= v0 ^& v1 @kind int;
  #L1fcfba.  if v0 != 0 then goto L1fcfc2;
  #L1fcfbe.  v1:= 3I;
  #L1fcfc0.  return v1;
  #L1fcfc2.  v0:= -268435456I;
  #L1fcfc6.  v1:= v1 ^& v0 @kind int;
  #L1fcfc8.  if v1 != 0 then goto L1fcfd0;
  #L1fcfcc.  v1:= 4I;
  #L1fcfce.  return v1;
  #L1fcfd0.  v1:= 5I;
  #L1fcfd2.  return v1;
}
procedure `int` `g`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.g:(II)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fce10.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fce16.  v0:= temp;
  #L1fce18.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fce1e.  v1:= temp;
  #L1fce20.  v0:= v0 + v1 @kind int;
  #L1fce22.  return v0;
}
procedure `int` `g`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.g:(IJ)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcdcc.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcdd2.  v0:= temp;
  #L1fcdd4.  v0:= v0 + 8;
  #L1fcdd8.  return v0;
}
procedure `int` `g`(`long` v0 ) @signature `Le/e/a/b/f/b/m0;.g:(J)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fce98.  v0:= 8I;
  #L1fce9c.  return v0;
}
procedure `int` `h`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.h:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcfe4.  call temp:= `l`(v0) @signature `Le/e/a/b/f/b/m0;.l:(I)I` @kind static;
  #L1fcfea.  v0:= temp;
  #L1fcfec.  call temp:= `g`(v0) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcff2.  v0:= temp;
  #L1fcff4.  return v0;
}
procedure `int` `h`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.h:(II)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fceb0.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fceb6.  v0:= temp;
  #L1fceb8.  call temp:= `l`(v1) @signature `Le/e/a/b/f/b/m0;.l:(I)I` @kind static;
  #L1fcebe.  v1:= temp;
  #L1fcec0.  call temp:= `g`(v1) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fcec6.  v1:= temp;
  #L1fcec8.  v0:= v0 + v1 @kind int;
  #L1fceca.  return v0;
}
procedure `int` `h`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.h:(IJ)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fce34.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fce3a.  v0:= temp;
  #L1fce3c.  v0:= v0 + 8;
  #L1fce40.  return v0;
}
procedure `int` `h`(`long` v0 ) @signature `Le/e/a/b/f/b/m0;.h:(J)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcedc.  v0:= 8I;
  #L1fcee0.  return v0;
}
procedure `int` `i`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.i:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fd008.  v0:= 4I;
  #L1fd00a.  return v0;
}
procedure `int` `i`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.i:(II)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcef4.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcefa.  v0:= temp;
  #L1fcefc.  v0:= v0 + 4;
  #L1fcf00.  return v0;
}
procedure `long` `i`(`long` v3 ) @signature `Le/e/a/b/f/b/m0;.i:(J)J` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;
    v1;
    v2;

  #L1fd084.  v0:= 1I;
  #L1fd086.  v0:= v3 ^< v0 @kind long;
  #L1fd08a.  v2:= 63I;
  #L1fd08e.  v3:= v3 ^> v2 @kind long;
  #L1fd090.  v3:= v3 ^~ v0 @kind long;
  #L1fd092.  return v3 @kind wide;
}
procedure `int` `j`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.j:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fd01c.  v0:= 4I;
  #L1fd01e.  return v0;
}
procedure `int` `j`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.j:(II)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcf14.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcf1a.  v0:= temp;
  #L1fcf1c.  v0:= v0 + 4;
  #L1fcf20.  return v0;
}
procedure `int` `k`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.k:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fd030.  call temp:= `f`(v0) @signature `Le/e/a/b/f/b/m0;.f:(I)I` @kind static;
  #L1fd036.  v0:= temp;
  #L1fd038.  return v0;
}
procedure `int` `k`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.k:(II)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fcf34.  call temp:= `e`(v0) @signature `Le/e/a/b/f/b/m0;.e:(I)I` @kind static;
  #L1fcf3a.  v0:= temp;
  #L1fcf3c.  call temp:= `f`(v1) @signature `Le/e/a/b/f/b/m0;.f:(I)I` @kind static;
  #L1fcf42.  v1:= temp;
  #L1fcf44.  v0:= v0 + v1 @kind int;
  #L1fcf46.  return v0;
}
procedure `int` `l`(`int` v1 ) @signature `Le/e/a/b/f/b/m0;.l:(I)I` @AccessFlag PRIVATE_STATIC {
    temp;
    v0;

  #L1fd04c.  v0:= v1 ^< 1;
  #L1fd050.  v1:= v1 ^> 31;
  #L1fd054.  v1:= v1 ^~ v0 @kind int;
  #L1fd056.  return v1;
}
procedure `int` `m`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.m:(I)I` @AccessFlag PUBLIC_STATIC {
    temp;

  #L1fd068.  call temp:= `g`(v0) @signature `Le/e/a/b/f/b/m0;.g:(I)I` @kind static;
  #L1fd06e.  v0:= temp;
  #L1fd070.  return v0;
}
procedure `void` `a`() @signature `Le/e/a/b/f/b/m0;.a:()V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`byte` v0 ) @signature `Le/e/a/b/f/b/m0;.a:(B)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`e.e.a.b.f.b.m0` v0 @kind this, `double` v1 ) @signature `Le/e/a/b/f/b/m0;.a:(D)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd128.  call temp:= `doubleToRawLongBits`(v1) @signature `Ljava/lang/Double;.doubleToRawLongBits:(D)J` @kind static;
  #L1fd12e.  v1:= temp @kind wide;
  #L1fd130.  call `c`(v0, v1) @signature `Le/e/a/b/f/b/m0;.c:(J)V` @kind virtual;
  #L1fd136.  return @kind void;
}
procedure `void` `a`(`e.e.a.b.f.b.m0` v0 @kind this, `float` v1 ) @signature `Le/e/a/b/f/b/m0;.a:(F)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd148.  call temp:= `floatToRawIntBits`(v1) @signature `Ljava/lang/Float;.floatToRawIntBits:(F)I` @kind static;
  #L1fd14e.  v1:= temp;
  #L1fd150.  call `d`(v0, v1) @signature `Le/e/a/b/f/b/m0;.d:(I)V` @kind virtual;
  #L1fd156.  return @kind void;
}
procedure `void` `a`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.a:(I)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`e.e.a.b.f.b.m0` v0 @kind this, `int` v1 , `double` v2 ) @signature `Le/e/a/b/f/b/m0;.a:(ID)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd168.  call temp:= `doubleToRawLongBits`(v2) @signature `Ljava/lang/Double;.doubleToRawLongBits:(D)J` @kind static;
  #L1fd16e.  v2:= temp @kind wide;
  #L1fd170.  call `c`(v0, v1, v2) @signature `Le/e/a/b/f/b/m0;.c:(IJ)V` @kind virtual;
  #L1fd176.  return @kind void;
}
procedure `void` `a`(`e.e.a.b.f.b.m0` v0 @kind this, `int` v1 , `float` v2 ) @signature `Le/e/a/b/f/b/m0;.a:(IF)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd188.  call temp:= `floatToRawIntBits`(v2) @signature `Ljava/lang/Float;.floatToRawIntBits:(F)I` @kind static;
  #L1fd18e.  v2:= temp;
  #L1fd190.  call `e`(v0, v1, v2) @signature `Le/e/a/b/f/b/m0;.e:(II)V` @kind virtual;
  #L1fd196.  return @kind void;
}
procedure `void` `a`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.a:(II)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.a:(IJ)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`int` v0 , `e.e.a.b.f.b.a0` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(ILe/e/a/b/f/b/a0;)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`int` v0 , `e.e.a.b.f.b.k2` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(ILe/e/a/b/f/b/k2;)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`int` v0 , `e.e.a.b.f.b.k2` v1 @kind object, `e.e.a.b.f.b.b3` v2 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(ILe/e/a/b/f/b/k2;Le/e/a/b/f/b/b3;)V` @AccessFlag ABSTRACT {

  # return;
}
procedure `void` `a`(`int` v0 , `java.lang.String` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(ILjava/lang/String;)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`int` v0 , `boolean` v1 ) @signature `Le/e/a/b/f/b/m0;.a:(IZ)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`long` v0 ) @signature `Le/e/a/b/f/b/m0;.a:(J)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `a`(`e.e.a.b.f.b.m0` v6 @kind this, `java.lang.String` v7 @kind object, `e.e.a.b.f.b.f4` v8 @kind object) @signature `Le/e/a/b/f/b/m0;.a:(Ljava/lang/String;Le/e/a/b/f/b/f4;)V` @AccessFlag FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L1fd1a8.  v0:= `@@e.e.a.b.f.b.m0.b` @type ^`java.util.logging.Logger` @kind object;
  #L1fd1ac.  v1:= `@@java.util.logging.Level.WARNING` @type ^`java.util.logging.Level` @kind object;
  #L1fd1b0.  v2:= "com.google.protobuf.CodedOutputStream" @kind object;
  #L1fd1b4.  v3:= "inefficientWriteStringNoTag" @kind object;
  #L1fd1b8.  v4:= "Converting ill-formed UTF-16. Your Protocol Buffer will not round trip correctly!" @kind object;
  #L1fd1bc.  v5:= v8 @kind object;
  #L1fd1be.  call `logp`(v0, v1, v2, v3, v4, v5) @signature `Ljava/util/logging/Logger;.logp:(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V` @kind virtual;
  #L1fd1c4.  v8:= `@@e.e.a.b.f.b.h1.a` @type ^`java.nio.charset.Charset` @kind object;
  #L1fd1c8.  call temp:= `getBytes`(v7, v8) @signature `Ljava/lang/String;.getBytes:(Ljava/nio/charset/Charset;)[B` @kind virtual;
  #L1fd1ce.  v7:= temp @kind object;
  #L1fd1d0.  v8:= length @variable v7;
  #L1fd1d2.  call `b`(v6, v8) @signature `Le/e/a/b/f/b/m0;.b:(I)V` @kind virtual;
  #L1fd1d8.  v8:= 0I;
  #L1fd1da.  v0:= length @variable v7;
  #L1fd1dc.  call `a`(v6, v7, v8, v0) @signature `Le/e/a/b/f/b/z;.a:([BII)V` @kind virtual;
  #L1fd1e2.  return @kind void;
  #L1fd1e4.  v7:= Exception @type ^`e.e.a.b.f.b.m0$c` @kind object;
  #L1fd1e6.  throw v7;
  #L1fd1e8.  v7:= Exception @type ^`java.lang.IndexOutOfBoundsException` @kind object;
  #L1fd1ea.  v8:= new `e.e.a.b.f.b.m0$c`;
  #L1fd1ee.  call `<init>`(v8, v7) @signature `Le/e/a/b/f/b/m0$c;.<init>:(Ljava/lang/Throwable;)V` @kind direct;
  #L1fd1f4.  throw v8;
  catch `java.lang.IndexOutOfBoundsException` @[L1fd1d0..L1fd1e2] goto L1fd1e8;
  catch `e.e.a.b.f.b.m0$c` @[L1fd1d0..L1fd1e2] goto L1fd1e4;
}
procedure `void` `a`(`e.e.a.b.f.b.m0` v0 @kind this, `boolean` v1 ) @signature `Le/e/a/b/f/b/m0;.a:(Z)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd10c.  v1:= (`byte`) v1 @kind i2b;
  #L1fd10e.  call `a`(v0, v1) @signature `Le/e/a/b/f/b/m0;.a:(B)V` @kind virtual;
  #L1fd114.  return @kind void;
}
procedure `int` `b`() @signature `Le/e/a/b/f/b/m0;.b:()I` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `b`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.b:(I)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `b`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.b:(II)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `b`(`e.e.a.b.f.b.m0` v0 @kind this, `int` v1 , `long` v2 ) @signature `Le/e/a/b/f/b/m0;.b:(IJ)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd218.  call temp:= `i`(v2) @signature `Le/e/a/b/f/b/m0;.i:(J)J` @kind static;
  #L1fd21e.  v2:= temp @kind wide;
  #L1fd220.  call `a`(v0, v1, v2) @signature `Le/e/a/b/f/b/m0;.a:(IJ)V` @kind virtual;
  #L1fd226.  return @kind void;
}
procedure `void` `b`(`int` v0 , `e.e.a.b.f.b.a0` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.b:(ILe/e/a/b/f/b/a0;)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `b`(`int` v0 , `e.e.a.b.f.b.k2` v1 @kind object) @signature `Le/e/a/b/f/b/m0;.b:(ILe/e/a/b/f/b/k2;)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `b`(`e.e.a.b.f.b.m0` v0 @kind this, `long` v1 ) @signature `Le/e/a/b/f/b/m0;.b:(J)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd238.  call temp:= `i`(v1) @signature `Le/e/a/b/f/b/m0;.i:(J)J` @kind static;
  #L1fd23e.  v1:= temp @kind wide;
  #L1fd240.  call `a`(v0, v1) @signature `Le/e/a/b/f/b/m0;.a:(J)V` @kind virtual;
  #L1fd246.  return @kind void;
}
procedure `void` `b`(`byte`[] v0 @kind object, `int` v1 , `int` v2 ) @signature `Le/e/a/b/f/b/m0;.b:([BII)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `c`(`e.e.a.b.f.b.m0` v0 @kind this, `int` v1 ) @signature `Le/e/a/b/f/b/m0;.c:(I)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd278.  call temp:= `l`(v1) @signature `Le/e/a/b/f/b/m0;.l:(I)I` @kind static;
  #L1fd27e.  v1:= temp;
  #L1fd280.  call `b`(v0, v1) @signature `Le/e/a/b/f/b/m0;.b:(I)V` @kind virtual;
  #L1fd286.  return @kind void;
}
procedure `void` `c`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.c:(II)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `c`(`int` v0 , `long` v1 ) @signature `Le/e/a/b/f/b/m0;.c:(IJ)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `c`(`long` v0 ) @signature `Le/e/a/b/f/b/m0;.c:(J)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `d`(`int` v0 ) @signature `Le/e/a/b/f/b/m0;.d:(I)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}
procedure `void` `d`(`e.e.a.b.f.b.m0` v0 @kind this, `int` v1 , `int` v2 ) @signature `Le/e/a/b/f/b/m0;.d:(II)V` @AccessFlag PUBLIC_FINAL {
    temp;

  #L1fd258.  call temp:= `l`(v2) @signature `Le/e/a/b/f/b/m0;.l:(I)I` @kind static;
  #L1fd25e.  v2:= temp;
  #L1fd260.  call `c`(v0, v1, v2) @signature `Le/e/a/b/f/b/m0;.c:(II)V` @kind virtual;
  #L1fd266.  return @kind void;
}
procedure `void` `e`(`int` v0 , `int` v1 ) @signature `Le/e/a/b/f/b/m0;.e:(II)V` @AccessFlag PUBLIC_ABSTRACT {

  # return;
}

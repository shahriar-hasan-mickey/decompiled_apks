record `n.b.a.s.p` @kind class @AccessFlag PUBLIC_FINAL extends `n.b.a.s.f` @kind class {
}
global `n.b.a.s.p` `@@n.b.a.s.p.k0` @AccessFlag PRIVATE_STATIC_FINAL;
global `java.util.concurrent.ConcurrentHashMap` `@@n.b.a.s.p.l0` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Ln/b/a/s/p;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;

  #L3fcfd0.  v0:= new `java.util.concurrent.ConcurrentHashMap`;
  #L3fcfd4.  call `<init>`(v0) @signature `Ljava/util/concurrent/ConcurrentHashMap;.<init>:()V` @kind direct;
  #L3fcfda.  `@@n.b.a.s.p.l0` @type ^`java.util.concurrent.ConcurrentHashMap` := v0 @kind object;
  #L3fcfde.  v0:= `@@n.b.a.f.c` @type ^`n.b.a.f` @kind object;
  #L3fcfe2.  call temp:= `b`(v0) @signature `Ln/b/a/s/p;.b:(Ln/b/a/f;)Ln/b/a/s/p;` @kind static;
  #L3fcfe8.  v0:= temp @kind object;
  #L3fcfea.  `@@n.b.a.s.p.k0` @type ^`n.b.a.s.p` := v0 @kind object;
  #L3fcfee.  return @kind void;
}
procedure `void` `<init>`(`n.b.a.s.p` v0 @kind this, `n.b.a.a` v1 @kind object, `java.lang.Object` v2 @kind object, `int` v3 ) @signature `Ln/b/a/s/p;.<init>:(Ln/b/a/a;Ljava/lang/Object;I)V` @AccessFlag PRIVATE_CONSTRUCTOR {
    temp;

  #L3fd000.  call `<init>`(v0, v1, v2, v3) @signature `Ln/b/a/s/f;.<init>:(Ln/b/a/a;Ljava/lang/Object;I)V` @kind direct;
  #L3fd006.  return @kind void;
}
procedure `n.b.a.s.p` `Z`() @signature `Ln/b/a/s/p;.Z:()Ln/b/a/s/p;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L3fcfb8.  v0:= `@@n.b.a.s.p.k0` @type ^`n.b.a.s.p` @kind object;
  #L3fcfbc.  return v0 @kind object;
}
procedure `n.b.a.s.p` `a`(`n.b.a.f` v5 @kind object, `int` v6 ) @signature `Ln/b/a/s/p;.a:(Ln/b/a/f;I)Ln/b/a/s/p;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L3fcec8.  if v5 != 0 then goto L3fced4;
  #L3fcecc.  call temp:= `d`() @signature `Ln/b/a/f;.d:()Ln/b/a/f;` @kind static;
  #L3fced2.  v5:= temp @kind object;
  #L3fced4.  v0:= `@@n.b.a.s.p.l0` @type ^`java.util.concurrent.ConcurrentHashMap` @kind object;
  #L3fced8.  call temp:= `get`(v0, v5) @signature `Ljava/util/concurrent/ConcurrentHashMap;.get:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L3fcede.  v0:= temp @kind object;
  #L3fcee0.  v0:= (`n.b.a.s.p`[]) v0 @kind object;
  #L3fcee4.  if v0 != 0 then goto L3fcf04;
  #L3fcee8.  v0:= 7I;
  #L3fceea.  v0:= new `n.b.a.s.p`[v0];
  #L3fceee.  v1:= `@@n.b.a.s.p.l0` @type ^`java.util.concurrent.ConcurrentHashMap` @kind object;
  #L3fcef2.  call temp:= `putIfAbsent`(v1, v5, v0) @signature `Ljava/util/concurrent/ConcurrentHashMap;.putIfAbsent:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L3fcef8.  v1:= temp @kind object;
  #L3fcefa.  v1:= (`n.b.a.s.p`[]) v1 @kind object;
  #L3fcefe.  if v1 == 0 then goto L3fcf04;
  #L3fcf02.  v0:= v1 @kind object;
  #L3fcf04.  v1:= v6 + -1;
  #L3fcf08.  v2:= v0[v1] @kind object;
  #L3fcf0c.  if v2 != 0 then goto L3fcf60;
  #L3fcf10.  @monitorenter v0
  #L3fcf12.  v2:= v0[v1] @kind object;
  #L3fcf16.  if v2 != 0 then goto L3fcf56;
  #L3fcf1a.  v2:= `@@n.b.a.f.c` @type ^`n.b.a.f` @kind object;
  #L3fcf1e.  v3:= 0I;
  #L3fcf20.  if v5 != v2 then goto L3fcf30;
  #L3fcf24.  v5:= new `n.b.a.s.p`;
  #L3fcf28.  call `<init>`(v5, v3, v3, v6) @signature `Ln/b/a/s/p;.<init>:(Ln/b/a/a;Ljava/lang/Object;I)V` @kind direct;
  #L3fcf2e.  goto L3fcf50;
  #L3fcf30.  v2:= `@@n.b.a.f.c` @type ^`n.b.a.f` @kind object;
  #L3fcf34.  call temp:= `a`(v2, v6) @signature `Ln/b/a/s/p;.a:(Ln/b/a/f;I)Ln/b/a/s/p;` @kind static;
  #L3fcf3a.  v2:= temp @kind object;
  #L3fcf3c.  v4:= new `n.b.a.s.p`;
  #L3fcf40.  call temp:= `a`(v2, v5) @signature `Ln/b/a/s/s;.a:(Ln/b/a/a;Ln/b/a/f;)Ln/b/a/s/s;` @kind static;
  #L3fcf46.  v5:= temp @kind object;
  #L3fcf48.  call `<init>`(v4, v5, v3, v6) @signature `Ln/b/a/s/p;.<init>:(Ln/b/a/a;Ljava/lang/Object;I)V` @kind direct;
  #L3fcf4e.  v5:= v4 @kind object;
  #L3fcf50.  v0[v1]:= v5 @kind object;
  #L3fcf54.  v2:= v5 @kind object;
  #L3fcf56.  @monitorexit v0
  #L3fcf58.  goto L3fcf60;
  #L3fcf5a.  v5:= Exception @type ^`java.lang.Throwable` @kind object;
  #L3fcf5c.  @monitorexit v0
  #L3fcf5e.  throw v5;
  #L3fcf60.  return v2 @kind object;
  #L3fcf62.  v5:= new `java.lang.IllegalArgumentException`;
  #L3fcf66.  v0:= new `java.lang.StringBuilder`;
  #L3fcf6a.  call `<init>`(v0) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L3fcf70.  v1:= "Invalid min days in first week: " @kind object;
  #L3fcf74.  call temp:= `append`(v0, v1) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L3fcf7a.  call temp:= `append`(v0, v6) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L3fcf80.  call temp:= `toString`(v0) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L3fcf86.  v6:= temp @kind object;
  #L3fcf88.  call `<init>`(v5, v6) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L3fcf8e.  throw v5;
  catch `java.lang.ArrayIndexOutOfBoundsException` @[L3fcf08..L3fcf0c] goto L3fcf62;
  catch `java.lang.Throwable` @[L3fcf12..L3fcf5e] goto L3fcf5a;
}
procedure `n.b.a.s.p` `b`(`n.b.a.f` v1 @kind object) @signature `Ln/b/a/s/p;.b:(Ln/b/a/f;)Ln/b/a/s/p;` @AccessFlag PUBLIC_STATIC {
    temp;
    v0;

  #L3fceac.  v0:= 4I;
  #L3fceae.  call temp:= `a`(v1, v0) @signature `Ln/b/a/s/p;.a:(Ln/b/a/f;I)Ln/b/a/s/p;` @kind static;
  #L3fceb4.  v1:= temp @kind object;
  #L3fceb6.  return v1 @kind object;
}
procedure `n.b.a.a` `G`(`n.b.a.s.p` v1 @kind this) @signature `Ln/b/a/s/p;.G:()Ln/b/a/a;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L3fce60.  v0:= `@@n.b.a.s.p.k0` @type ^`n.b.a.s.p` @kind object;
  #L3fce64.  return v0 @kind object;
}
procedure `long` `N`(`n.b.a.s.p` v2 @kind this) @signature `Ln/b/a/s/p;.N:()J` @AccessFlag  {
    temp;
    v0;
    v1;

  #L3fcdf0.  v0:= 31083597720000L;
  #L3fcdfa.  return v0 @kind wide;
}
procedure `long` `O`(`n.b.a.s.p` v2 @kind this) @signature `Ln/b/a/s/p;.O:()J` @AccessFlag  {
    temp;
    v0;
    v1;

  #L3fce0c.  v0:= 2629746000L;
  #L3fce16.  return v0 @kind wide;
}
procedure `long` `P`(`n.b.a.s.p` v2 @kind this) @signature `Ln/b/a/s/p;.P:()J` @AccessFlag  {
    temp;
    v0;
    v1;

  #L3fce28.  v0:= 31556952000L;
  #L3fce32.  return v0 @kind wide;
}
procedure `long` `Q`(`n.b.a.s.p` v2 @kind this) @signature `Ln/b/a/s/p;.Q:()J` @AccessFlag  {
    temp;
    v0;
    v1;

  #L3fce44.  v0:= 15778476000L;
  #L3fce4e.  return v0 @kind wide;
}
procedure `int` `U`(`n.b.a.s.p` v1 @kind this) @signature `Ln/b/a/s/p;.U:()I` @AccessFlag  {
    temp;
    v0;

  #L3fcd50.  v0:= 292278993I;
  #L3fcd56.  return v0;
}
procedure `int` `V`(`n.b.a.s.p` v1 @kind this) @signature `Ln/b/a/s/p;.V:()I` @AccessFlag  {
    temp;
    v0;

  #L3fcd68.  v0:= -292275054I;
  #L3fcd6e.  return v0;
}
procedure `long` `a`(`n.b.a.s.p` v6 @kind this, `int` v7 ) @signature `Ln/b/a/s/p;.a:(I)J` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L3fcd80.  v0:= v7 / 100;
  #L3fcd84.  if v7 >= 0 then goto L3fcda2;
  #L3fcd88.  v1:= v7 + 3;
  #L3fcd8c.  v1:= v1 ^> 2;
  #L3fcd90.  v1:= v1 - v0 @kind int;
  #L3fcd92.  v0:= v0 + 3;
  #L3fcd96.  v0:= v0 ^> 2;
  #L3fcd9a.  v1:= v1 + v0 @kind int;
  #L3fcd9c.  v1:= v1 + -1;
  #L3fcda0.  goto L3fcdbe;
  #L3fcda2.  v1:= v7 ^> 2;
  #L3fcda6.  v1:= v1 - v0 @kind int;
  #L3fcda8.  v0:= v0 ^> 2;
  #L3fcdac.  v1:= v1 + v0 @kind int;
  #L3fcdae.  call temp:= `f`(v6, v7) @signature `Ln/b/a/s/p;.f:(I)Z` @kind virtual;
  #L3fcdb4.  v0:= temp;
  #L3fcdb6.  if v0 == 0 then goto L3fcdbe;
  #L3fcdba.  v1:= v1 + -1;
  #L3fcdbe.  v2:= (`long`) v7 @kind i2l;
  #L3fcdc0.  v4:= 365L;
  #L3fcdc4.  v2:= v2 * v4 @kind long;
  #L3fcdc8.  v7:= 719527I;
  #L3fcdce.  v1:= v1 - v7 @kind int;
  #L3fcdd0.  v0:= (`long`) v1 @kind i2l;
  #L3fcdd2.  v2:= v2 + v0 @kind long;
  #L3fcdd4.  v0:= 86400000L;
  #L3fcdda.  v2:= v2 * v0 @kind long;
  #L3fcdde.  return v2 @kind wide;
}
procedure `n.b.a.a` `a`(`n.b.a.s.p` v1 @kind this, `n.b.a.f` v2 @kind object) @signature `Ln/b/a/s/p;.a:(Ln/b/a/f;)Ln/b/a/a;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L3fce78.  if v2 != 0 then goto L3fce84;
  #L3fce7c.  call temp:= `d`() @signature `Ln/b/a/f;.d:()Ln/b/a/f;` @kind static;
  #L3fce82.  v2:= temp @kind object;
  #L3fce84.  call temp:= `k`(v1) @signature `Ln/b/a/s/p;.k:()Ln/b/a/f;` @kind virtual;
  #L3fce8a.  v0:= temp @kind object;
  #L3fce8c.  if v2 != v0 then goto L3fce92;
  #L3fce90.  return v1 @kind object;
  #L3fce92.  call temp:= `b`(v2) @signature `Ln/b/a/s/p;.b:(Ln/b/a/f;)Ln/b/a/s/p;` @kind static;
  #L3fce98.  v2:= temp @kind object;
  #L3fce9a.  return v2 @kind object;
}
procedure `void` `a`(`n.b.a.s.p` v1 @kind this, `n.b.a.s.a$a` v2 @kind object) @signature `Ln/b/a/s/p;.a:(Ln/b/a/s/a$a;)V` @AccessFlag PROTECTED {
    temp;
    v0;

  #L3fd018.  call temp:= `L`(v1) @signature `Ln/b/a/s/a;.L:()Ln/b/a/a;` @kind virtual;
  #L3fd01e.  v0:= temp @kind object;
  #L3fd020.  if v0 != 0 then goto L3fd02a;
  #L3fd024.  call `a`(v1, v2) @signature `Ln/b/a/s/c;.a:(Ln/b/a/s/a$a;)V` @kind super;
  #L3fd02a.  return @kind void;
}
procedure `boolean` `f`(`n.b.a.s.p` v1 @kind this, `int` v2 ) @signature `Ln/b/a/s/p;.f:(I)Z` @AccessFlag  {
    temp;
    v0;

  #L3fcd20.  v0:= v2 ^& 3;
  #L3fcd24.  if v0 != 0 then goto L3fcd3c;
  #L3fcd28.  v0:= v2 %% 100;
  #L3fcd2c.  if v0 != 0 then goto L3fcd38;
  #L3fcd30.  v2:= v2 %% 400;
  #L3fcd34.  if v2 != 0 then goto L3fcd3c;
  #L3fcd38.  v2:= 1I;
  #L3fcd3a.  goto L3fcd3e;
  #L3fcd3c.  v2:= 0I;
  #L3fcd3e.  return v2;
}

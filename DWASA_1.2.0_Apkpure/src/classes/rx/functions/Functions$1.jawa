record `rx.functions.Functions$1` @kind class @AccessFlag FINAL extends `rx.functions.FuncN` @kind interface {
  `rx.functions.Func0` `rx.functions.Functions$1.val$f` @AccessFlag FINAL_SYNTHETIC;
}
procedure `void` `<init>`(`rx.functions.Functions$1` v0 @kind this, `rx.functions.Func0` v1 @kind object) @signature `Lrx/functions/Functions$1;.<init>:(Lrx/functions/Func0;)V` @AccessFlag CONSTRUCTOR {
    temp;

  #L4920e8.  v0.`rx.functions.Functions$1.val$f` @type ^`rx.functions.Func0` := v1 @kind object;
  #L4920ec.  call `<init>`(v0) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L4920f2.  return @kind void;
}
procedure `java.lang.Object` `call`(`rx.functions.Functions$1` v1 @kind this, `java.lang.Object`[] v2 @kind object) @signature `Lrx/functions/Functions$1;.call:([Ljava/lang/Object;)Ljava/lang/Object;` @AccessFlag PUBLIC {
    temp;
    v0;

  #L4920b4.  v2:= length @variable v2;
  #L4920b6.  if v2 != 0 then goto L4920c8;
  #L4920ba.  v2:= v1.`rx.functions.Functions$1.val$f` @type ^`rx.functions.Func0` @kind object;
  #L4920be.  call temp:= `call`(v2) @signature `Lrx/functions/Func0;.call:()Ljava/lang/Object;` @kind interface;
  #L4920c4.  v2:= temp @kind object;
  #L4920c6.  return v2 @kind object;
  #L4920c8.  v2:= new `java.lang.IllegalArgumentException`;
  #L4920cc.  v0:= "Func0 expecting 0 arguments." @kind object;
  #L4920d0.  call `<init>`(v2, v0) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L4920d6.  throw v2;
}

record `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.disposables.Disposable` @kind interface, `io.reactivex.Observer` @kind interface {
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.delayErrors` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @AccessFlag VOLATILE;
  `io.reactivex.Observer` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @AccessFlag ;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @AccessFlag ;
  `io.reactivex.functions.Function` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.mapper` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @AccessFlag FINAL;
  `io.reactivex.internal.fuseable.SimplePlainQueue` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @AccessFlag VOLATILE;
  `java.util.Queue` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @AccessFlag ;
  `long` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.uniqueId` @AccessFlag ;
  `io.reactivex.disposables.Disposable` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @AccessFlag ;
  `int` `io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @AccessFlag ;
}
global `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L423ed0.  v0:= 0I;
  #L423ed2.  v1:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v0];
  #L423ed6.  `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] := v1 @kind object;
  #L423eda.  v0:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v0];
  #L423ede.  `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] := v0 @kind object;
  #L423ee2.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this, `io.reactivex.Observer` v2 @kind object, `io.reactivex.functions.Function` v3 @kind object, `boolean` v4 , `int` v5 , `int` v6 ) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.<init>:(Lio/reactivex/Observer;Lio/reactivex/functions/Function;ZII)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L423ef4.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L423efa.  v0:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L423efe.  call `<init>`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L423f04.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` := v0 @kind object;
  #L423f08.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.Observer` := v2 @kind object;
  #L423f0c.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.mapper` @type ^`io.reactivex.functions.Function` := v3 @kind object;
  #L423f10.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.delayErrors` @type ^`boolean` := v4 @kind boolean;
  #L423f14.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int` := v5;
  #L423f18.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @type ^`int` := v6;
  #L423f1c.  v2:= 2147483647I;
  #L423f22.  if v5 == v2 then goto L423f34;
  #L423f26.  v2:= new `java.util.ArrayDeque`;
  #L423f2a.  call `<init>`(v2, v5) @signature `Ljava/util/ArrayDeque;.<init>:(I)V` @kind direct;
  #L423f30.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` := v2 @kind object;
  #L423f34.  v2:= new `java.util.concurrent.atomic.AtomicReference`;
  #L423f38.  v3:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L423f3c.  call `<init>`(v2, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L423f42.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` := v2 @kind object;
  #L423f46.  return @kind void;
}
procedure `boolean` `addInner`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v4 @kind this, `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver` v5 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.addInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L423ca8.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L423cac.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L423cb2.  v0:= temp @kind object;
  #L423cb4.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L423cb8.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L423cbc.  v2:= 0I;
  #L423cbe.  if v0 != v1 then goto L423cca;
  #L423cc2.  call `dispose`(v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.dispose:()V` @kind virtual;
  #L423cc8.  return v2;
  #L423cca.  v1:= length @variable v0;
  #L423ccc.  v3:= v1 + 1;
  #L423cd0.  v3:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v3];
  #L423cd4.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L423cda.  v3[v1]:= v5 @kind object;
  #L423cde.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L423ce2.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L423ce8.  v0:= temp;
  #L423cea.  if v0 == 0 then goto L423ca8;
  #L423cee.  v5:= 1I;
  #L423cf0.  return v5;
}
procedure `boolean` `checkTerminate`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v3 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L423d04.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` @kind boolean;
  #L423d08.  v1:= 1I;
  #L423d0a.  if v0 == 0 then goto L423d10;
  #L423d0e.  return v1;
  #L423d10.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L423d14.  call temp:= `get`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.get:()Ljava/lang/Object;` @kind virtual;
  #L423d1a.  v0:= temp @kind object;
  #L423d1c.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L423d20.  v2:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.delayErrors` @type ^`boolean` @kind boolean;
  #L423d24.  if v2 != 0 then goto L423d52;
  #L423d28.  if v0 == 0 then goto L423d52;
  #L423d2c.  call temp:= `disposeAll`(v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.disposeAll:()Z` @kind virtual;
  #L423d32.  v0:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L423d36.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L423d3c.  v0:= temp @kind object;
  #L423d3e.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L423d42.  if v0 == v2 then goto L423d50;
  #L423d46.  v2:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.Observer` @kind object;
  #L423d4a.  call `onError`(v2, v0) @signature `Lio/reactivex/Observer;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L423d50.  return v1;
  #L423d52.  v0:= 0I;
  #L423d54.  return v0;
}
procedure `void` `dispose`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v2 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.dispose:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L423f58.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` @kind boolean;
  #L423f5c.  if v0 != 0 then goto L423f90;
  #L423f60.  v0:= 1I;
  #L423f62.  v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L423f66.  call temp:= `disposeAll`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.disposeAll:()Z` @kind virtual;
  #L423f6c.  v0:= temp;
  #L423f6e.  if v0 == 0 then goto L423f90;
  #L423f72.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L423f76.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L423f7c.  v0:= temp @kind object;
  #L423f7e.  if v0 == 0 then goto L423f90;
  #L423f82.  v1:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L423f86.  if v0 == v1 then goto L423f90;
  #L423f8a.  call `onError`(v0) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L423f90.  return @kind void;
}
procedure `boolean` `disposeAll`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v4 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.disposeAll:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L423d68.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.Disposable` @kind object;
  #L423d6c.  call `dispose`(v0) @signature `Lio/reactivex/disposables/Disposable;.dispose:()V` @kind interface;
  #L423d72.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L423d76.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L423d7c.  v0:= temp @kind object;
  #L423d7e.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L423d82.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L423d86.  v2:= 0I;
  #L423d88.  if v0 == v1 then goto L423dbe;
  #L423d8c.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L423d90.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L423d96.  v0:= temp @kind object;
  #L423d98.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L423d9c.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.CANCELLED` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L423da0.  if v0 == v1 then goto L423dbe;
  #L423da4.  v1:= length @variable v0;
  #L423da6.  if v2 >= v1 then goto L423dba;
  #L423daa.  v3:= v0[v2] @kind object;
  #L423dae.  call `dispose`(v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.dispose:()V` @kind virtual;
  #L423db4.  v2:= v2 + 1;
  #L423db8.  goto L423da6;
  #L423dba.  v0:= 1I;
  #L423dbc.  return v0;
  #L423dbe.  return v2;
}
procedure `void` `drain`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @AccessFlag  {
    temp;
    v0;

  #L423fa4.  call temp:= `getAndIncrement`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.getAndIncrement:()I` @kind virtual;
  #L423faa.  v0:= temp;
  #L423fac.  if v0 != 0 then goto L423fb6;
  #L423fb0.  call `drainLoop`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @kind virtual;
  #L423fb6.  return @kind void;
}
procedure `void` `drainLoop`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v14 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;

  #L423fc8.  v0:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.Observer` @kind object;
  #L423fcc.  v1:= 1I;
  #L423fce.  v2:= 1I;
  #L423fd0.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L423fd6.  v3:= temp;
  #L423fd8.  if v3 == 0 then goto L423fde;
  #L423fdc.  return @kind void;
  #L423fde.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L423fe2.  if v3 == 0 then goto L42400e;
  #L423fe6.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L423fec.  v4:= temp;
  #L423fee.  if v4 == 0 then goto L423ff4;
  #L423ff2.  return @kind void;
  #L423ff4.  call temp:= `poll`(v3) @signature `Lio/reactivex/internal/fuseable/SimplePlainQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L423ffa.  v4:= temp @kind object;
  #L423ffc.  if v4 != 0 then goto L424006;
  #L424000.  if v4 != 0 then goto L423fe6;
  #L424004.  goto L42400e;
  #L424006.  call `onNext`(v0, v4) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L42400c.  goto L423fe6;
  #L42400e.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L424012.  v4:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L424016.  v5:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L42401a.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L424020.  v5:= temp @kind object;
  #L424022.  v5:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v5 @kind object;
  #L424026.  v6:= length @variable v5;
  #L424028.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L42402c.  v8:= 2147483647I;
  #L424032.  v9:= 0I;
  #L424034.  if v7 == v8 then goto L424050;
  #L424038.  @monitorenter v14
  #L42403a.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L42403e.  call temp:= `size`(v7) @signature `Ljava/util/Queue;.size:()I` @kind interface;
  #L424044.  v7:= temp;
  #L424046.  @monitorexit v14
  #L424048.  goto L424052;
  #L42404a.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L42404c.  @monitorexit v14
  #L42404e.  throw v0;
  #L424050.  v7:= 0I;
  #L424052.  if v3 == 0 then goto L424096;
  #L424056.  if v4 == 0 then goto L424066;
  #L42405a.  call temp:= `isEmpty`(v4) @signature `Lio/reactivex/internal/fuseable/SimplePlainQueue;.isEmpty:()Z` @kind interface;
  #L424060.  v3:= temp;
  #L424062.  if v3 == 0 then goto L424096;
  #L424066.  if v6 != 0 then goto L424096;
  #L42406a.  if v7 != 0 then goto L424096;
  #L42406e.  v1:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L424072.  call temp:= `terminate`(v1) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L424078.  v1:= temp @kind object;
  #L42407a.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.TERMINATED` @type ^`java.lang.Throwable` @kind object;
  #L42407e.  if v1 == v2 then goto L424094;
  #L424082.  if v1 != 0 then goto L42408e;
  #L424086.  call `onComplete`(v0) @signature `Lio/reactivex/Observer;.onComplete:()V` @kind interface;
  #L42408c.  goto L424094;
  #L42408e.  call `onError`(v0, v1) @signature `Lio/reactivex/Observer;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L424094.  return @kind void;
  #L424096.  if v6 == 0 then goto L4241d4;
  #L42409a.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @type ^`long` @kind wide;
  #L42409e.  v7:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @type ^`int`;
  #L4240a2.  if v6 <= v7 then goto L4240b6;
  #L4240a6.  v10:= v5[v7] @kind object;
  #L4240aa.  v10:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L4240ae.  v12:= lcmp(v10, v3);
  #L4240b2.  if v12 == 0 then goto L4240f8;
  #L4240b6.  if v6 > v7 then goto L4240bc;
  #L4240ba.  v7:= 0I;
  #L4240bc.  v10:= v7;
  #L4240be.  v7:= 0I;
  #L4240c0.  if v7 >= v6 then goto L4240e6;
  #L4240c4.  v11:= v5[v10] @kind object;
  #L4240c8.  v11:= v11.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L4240cc.  v13:= lcmp(v11, v3);
  #L4240d0.  if v13 != 0 then goto L4240d6;
  #L4240d4.  goto L4240e6;
  #L4240d6.  v10:= v10 + 1;
  #L4240da.  if v10 != v6 then goto L4240e0;
  #L4240de.  v10:= 0I;
  #L4240e0.  v7:= v7 + 1;
  #L4240e4.  goto L4240c0;
  #L4240e6.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @type ^`int` := v10;
  #L4240ea.  v3:= v5[v10] @kind object;
  #L4240ee.  v3:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L4240f2.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @type ^`long` := v3 @kind wide;
  #L4240f6.  v7:= v10;
  #L4240f8.  v3:= 0I;
  #L4240fa.  v4:= 0I;
  #L4240fc.  if v3 >= v6 then goto L4241c2;
  #L424100.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L424106.  v10:= temp;
  #L424108.  if v10 == 0 then goto L42410e;
  #L42410c.  return @kind void;
  #L42410e.  v10:= v5[v7] @kind object;
  #L424112.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L424118.  v11:= temp;
  #L42411a.  if v11 == 0 then goto L424120;
  #L42411e.  return @kind void;
  #L424120.  v11:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L424124.  if v11 != 0 then goto L42412a;
  #L424128.  goto L42413a;
  #L42412a.  call temp:= `poll`(v11) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L424130.  v12:= temp @kind object;
  #L424132.  if v12 != 0 then goto L424178;
  #L424136.  if v12 != 0 then goto L424112;
  #L42413a.  v11:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.done` @type ^`boolean` @kind boolean;
  #L42413e.  v12:= v10.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L424142.  if v11 == 0 then goto L42416c;
  #L424146.  if v12 == 0 then goto L424156;
  #L42414a.  call temp:= `isEmpty`(v12) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L424150.  v11:= temp;
  #L424152.  if v11 == 0 then goto L42416c;
  #L424156.  call `removeInner`(v14, v10) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.removeInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @kind virtual;
  #L42415c.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L424162.  v4:= temp;
  #L424164.  if v4 == 0 then goto L42416a;
  #L424168.  return @kind void;
  #L42416a.  v4:= 1I;
  #L42416c.  v7:= v7 + 1;
  #L424170.  if v7 != v6 then goto L4241be;
  #L424174.  v7:= 0I;
  #L424176.  goto L4241be;
  #L424178.  call `onNext`(v0, v12) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L42417e.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L424184.  v12:= temp;
  #L424186.  if v12 == 0 then goto L42412a;
  #L42418a.  return @kind void;
  #L42418c.  v4:= Exception @type ^`java.lang.Throwable` @kind object;
  #L42418e.  call `throwIfFatal`(v4) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L424194.  call `dispose`(v10) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.dispose:()V` @kind virtual;
  #L42419a.  v11:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L42419e.  call temp:= `addThrowable`(v11, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L4241a4.  call temp:= `checkTerminate`(v14) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.checkTerminate:()Z` @kind virtual;
  #L4241aa.  v4:= temp;
  #L4241ac.  if v4 == 0 then goto L4241b2;
  #L4241b0.  return @kind void;
  #L4241b2.  call `removeInner`(v14, v10) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.removeInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @kind virtual;
  #L4241b8.  v3:= v3 + 1;
  #L4241bc.  v4:= 1I;
  #L4241be.  v3:= v3 + v1 @kind int;
  #L4241c0.  goto L4240fc;
  #L4241c2.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastIndex` @type ^`int` := v7;
  #L4241c6.  v3:= v5[v7] @kind object;
  #L4241ca.  v5:= v3.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.id` @type ^`long` @kind wide;
  #L4241ce.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.lastId` @type ^`long` := v5 @kind wide;
  #L4241d2.  goto L4241d6;
  #L4241d4.  v4:= 0I;
  #L4241d6.  if v4 == 0 then goto L42421a;
  #L4241da.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L4241de.  if v3 == v8 then goto L423fd0;
  #L4241e2.  @monitorenter v14
  #L4241e4.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L4241e8.  call temp:= `poll`(v3) @signature `Ljava/util/Queue;.poll:()Ljava/lang/Object;` @kind interface;
  #L4241ee.  v3:= temp @kind object;
  #L4241f0.  v3:= (`io.reactivex.ObservableSource`) v3 @kind object;
  #L4241f4.  if v3 != 0 then goto L424208;
  #L4241f8.  v3:= v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L4241fc.  v3:= v3 - v1 @kind int;
  #L4241fe.  v14.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int` := v3;
  #L424202.  @monitorexit v14
  #L424204.  goto L423fd0;
  #L424208.  @monitorexit v14
  #L42420a.  call `subscribeInner`(v14, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.subscribeInner:(Lio/reactivex/ObservableSource;)V` @kind virtual;
  #L424210.  goto L423fd0;
  #L424214.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L424216.  @monitorexit v14
  #L424218.  throw v0;
  #L42421a.  v2:= -v2 @kind int;
  #L42421c.  call temp:= `addAndGet`(v14, v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.addAndGet:(I)I` @kind virtual;
  #L424222.  v2:= temp;
  #L424224.  if v2 != 0 then goto L423fd0;
  #L424228.  return @kind void;
  catch `java.lang.Throwable` @[L42403a..L42404e] goto L42404a;
  catch `java.lang.Throwable` @[L42412a..L424132] goto L42418c;
  catch `java.lang.Throwable` @[L4241e4..L42420a] goto L424214;
  catch `java.lang.Throwable` @[L424216..L424218] goto L424214;
}
procedure `boolean` `isDisposed`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.isDisposed:()Z` @AccessFlag PUBLIC {
    temp;
    v0;

  #L423dd0.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.cancelled` @type ^`boolean` @kind boolean;
  #L423dd4.  return v0;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L424268.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L42426c.  if v0 == 0 then goto L424272;
  #L424270.  return @kind void;
  #L424272.  v0:= 1I;
  #L424274.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` := v0 @kind boolean;
  #L424278.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L42427e.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L424290.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L424294.  if v0 == 0 then goto L4242a0;
  #L424298.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L42429e.  return @kind void;
  #L4242a0.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L4242a4.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L4242aa.  v0:= temp;
  #L4242ac.  if v0 == 0 then goto L4242be;
  #L4242b0.  v2:= 1I;
  #L4242b2.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` := v2 @kind boolean;
  #L4242b6.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L4242bc.  goto L4242c4;
  #L4242be.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L4242c4.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v2 @kind this, `java.lang.Object` v3 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4242d8.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.done` @type ^`boolean` @kind boolean;
  #L4242dc.  if v0 == 0 then goto L4242e2;
  #L4242e0.  return @kind void;
  #L4242e2.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.mapper` @type ^`io.reactivex.functions.Function` @kind object;
  #L4242e6.  call temp:= `apply`(v0, v3) @signature `Lio/reactivex/functions/Function;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L4242ec.  v3:= temp @kind object;
  #L4242ee.  v0:= "The mapper returned a null ObservableSource" @kind object;
  #L4242f2.  call temp:= `requireNonNull`(v3, v0) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L4242f8.  v3:= temp @kind object;
  #L4242fa.  v3:= (`io.reactivex.ObservableSource`) v3 @kind object;
  #L4242fe.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L424302.  v1:= 2147483647I;
  #L424308.  if v0 == v1 then goto L42433e;
  #L42430c.  @monitorenter v2
  #L42430e.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L424312.  v1:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L424316.  if v0 != v1 then goto L424328;
  #L42431a.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L42431e.  call temp:= `offer`(v0, v3) @signature `Ljava/util/Queue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L424324.  @monitorexit v2
  #L424326.  return @kind void;
  #L424328.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L42432c.  v0:= v0 + 1;
  #L424330.  v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int` := v0;
  #L424334.  @monitorexit v2
  #L424336.  goto L42433e;
  #L424338.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L42433a.  @monitorexit v2
  #L42433c.  throw v3;
  #L42433e.  call `subscribeInner`(v2, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.subscribeInner:(Lio/reactivex/ObservableSource;)V` @kind virtual;
  #L424344.  return @kind void;
  #L424346.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L424348.  call `throwIfFatal`(v3) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L42434e.  v0:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.Disposable` @kind object;
  #L424352.  call `dispose`(v0) @signature `Lio/reactivex/disposables/Disposable;.dispose:()V` @kind interface;
  #L424358.  call `onError`(v2, v3) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L42435e.  return @kind void;
  catch `java.lang.Throwable` @[L4242e2..L4242fe] goto L424346;
  catch `java.lang.Throwable` @[L42430e..L42433c] goto L424338;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v1 @kind this, `io.reactivex.disposables.Disposable` v2 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onSubscribe:(Lio/reactivex/disposables/Disposable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L424388.  v0:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.Disposable` @kind object;
  #L42438c.  call temp:= `validate`(v0, v2) @signature `Lio/reactivex/internal/disposables/DisposableHelper;.validate:(Lio/reactivex/disposables/Disposable;Lio/reactivex/disposables/Disposable;)Z` @kind static;
  #L424392.  v0:= temp;
  #L424394.  if v0 == 0 then goto L4243a6;
  #L424398.  v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.upstream` @type ^`io.reactivex.disposables.Disposable` := v2 @kind object;
  #L42439c.  v2:= v1.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.Observer` @kind object;
  #L4243a0.  call `onSubscribe`(v2, v1) @signature `Lio/reactivex/Observer;.onSubscribe:(Lio/reactivex/disposables/Disposable;)V` @kind interface;
  #L4243a6.  return @kind void;
}
procedure `void` `removeInner`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v6 @kind this, `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver` v7 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.removeInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L4243b8.  v0:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4243bc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4243c2.  v0:= temp @kind object;
  #L4243c4.  v0:= (`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[]) v0 @kind object;
  #L4243c8.  v1:= length @variable v0;
  #L4243ca.  if v1 != 0 then goto L4243d0;
  #L4243ce.  return @kind void;
  #L4243d0.  v2:= -1I;
  #L4243d2.  v3:= 0I;
  #L4243d4.  v4:= 0I;
  #L4243d6.  if v4 >= v1 then goto L4243ec;
  #L4243da.  v5:= v0[v4] @kind object;
  #L4243de.  if v5 != v7 then goto L4243e6;
  #L4243e2.  v2:= v4;
  #L4243e4.  goto L4243ec;
  #L4243e6.  v4:= v4 + 1;
  #L4243ea.  goto L4243d6;
  #L4243ec.  if v2 >= 0 then goto L4243f2;
  #L4243f0.  return @kind void;
  #L4243f2.  v4:= 1I;
  #L4243f4.  if v1 != v4 then goto L4243fe;
  #L4243f8.  v1:= `@@io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.EMPTY` @type ^`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[] @kind object;
  #L4243fc.  goto L42441c;
  #L4243fe.  v5:= v1 + -1;
  #L424402.  v5:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`[v5];
  #L424406.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L42440c.  v3:= v2 + 1;
  #L424410.  v1:= v1 - v2 @kind int;
  #L424412.  v1:= v1 - v4 @kind int;
  #L424414.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L42441a.  v1:= v5 @kind object;
  #L42441c.  v2:= v6.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.observers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L424420.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L424426.  v0:= temp;
  #L424428.  if v0 == 0 then goto L4243b8;
  #L42442c.  return @kind void;
}
procedure `void` `subscribeInner`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v5 @kind this, `io.reactivex.ObservableSource` v6 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.subscribeInner:(Lio/reactivex/ObservableSource;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L424440.  v0:= instanceof @variable v6 @type ^`java.util.concurrent.Callable` @kind boolean;
  #L424444.  if v0 == 0 then goto L4244a4;
  #L424448.  v6:= (`java.util.concurrent.Callable`) v6 @kind object;
  #L42444c.  call temp:= `tryEmitScalar`(v5, v6) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.tryEmitScalar:(Ljava/util/concurrent/Callable;)Z` @kind virtual;
  #L424452.  v6:= temp;
  #L424454.  if v6 == 0 then goto L4244ce;
  #L424458.  v6:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L42445c.  v0:= 2147483647I;
  #L424462.  if v6 == v0 then goto L4244ce;
  #L424466.  v6:= 0I;
  #L424468.  @monitorenter v5
  #L42446a.  v0:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.sources` @type ^`java.util.Queue` @kind object;
  #L42446e.  call temp:= `poll`(v0) @signature `Ljava/util/Queue;.poll:()Ljava/lang/Object;` @kind interface;
  #L424474.  v0:= temp @kind object;
  #L424476.  v0:= (`io.reactivex.ObservableSource`) v0 @kind object;
  #L42447a.  v1:= 1I;
  #L42447c.  if v0 != 0 then goto L42448c;
  #L424480.  v6:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int`;
  #L424484.  v6:= v6 - v1 @kind int;
  #L424486.  v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.wip` @type ^`int` := v6;
  #L42448a.  v6:= 1I;
  #L42448c.  @monitorexit v5
  #L42448e.  if v6 == 0 then goto L42449a;
  #L424492.  call `drain`(v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L424498.  goto L4244ce;
  #L42449a.  v6:= v0 @kind object;
  #L42449c.  goto L424440;
  #L42449e.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L4244a0.  @monitorexit v5
  #L4244a2.  throw v6;
  #L4244a4.  v0:= new `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver`;
  #L4244a8.  v1:= v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.uniqueId` @type ^`long` @kind wide;
  #L4244ac.  v3:= 1L;
  #L4244b0.  v3:= v3 + v1 @kind long;
  #L4244b2.  v5.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.uniqueId` @type ^`long` := v3 @kind wide;
  #L4244b6.  call `<init>`(v0, v5, v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;.<init>:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;J)V` @kind direct;
  #L4244bc.  call temp:= `addInner`(v5, v0) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.addInner:(Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)Z` @kind virtual;
  #L4244c2.  v1:= temp;
  #L4244c4.  if v1 == 0 then goto L4244ce;
  #L4244c8.  call `subscribe`(v6, v0) @signature `Lio/reactivex/ObservableSource;.subscribe:(Lio/reactivex/Observer;)V` @kind interface;
  #L4244ce.  return @kind void;
  catch `java.lang.Throwable` @[L42446a..L42448e] goto L42449e;
  catch `java.lang.Throwable` @[L4244a0..L4244a2] goto L42449e;
}
procedure `void` `tryEmit`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v2 @kind this, `java.lang.Object` v3 @kind object, `io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver` v4 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.tryEmit:(Ljava/lang/Object;Lio/reactivex/internal/operators/observable/ObservableFlatMap$InnerObserver;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L4244f4.  call temp:= `get`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.get:()I` @kind virtual;
  #L4244fa.  v0:= temp;
  #L4244fc.  if v0 != 0 then goto L424528;
  #L424500.  v0:= 0I;
  #L424502.  v1:= 1I;
  #L424504.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.compareAndSet:(II)Z` @kind virtual;
  #L42450a.  v0:= temp;
  #L42450c.  if v0 == 0 then goto L424528;
  #L424510.  v4:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.Observer` @kind object;
  #L424514.  call `onNext`(v4, v3) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L42451a.  call temp:= `decrementAndGet`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.decrementAndGet:()I` @kind virtual;
  #L424520.  v3:= temp;
  #L424522.  if v3 != 0 then goto L424556;
  #L424526.  return @kind void;
  #L424528.  v0:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L42452c.  if v0 != 0 then goto L424542;
  #L424530.  v0:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L424534.  v1:= v2.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @type ^`int`;
  #L424538.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L42453e.  v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L424542.  call temp:= `offer`(v0, v3) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L424548.  call temp:= `getAndIncrement`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.getAndIncrement:()I` @kind virtual;
  #L42454e.  v3:= temp;
  #L424550.  if v3 == 0 then goto L424556;
  #L424554.  return @kind void;
  #L424556.  call `drainLoop`(v2) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @kind virtual;
  #L42455c.  return @kind void;
}
procedure `boolean` `tryEmitScalar`(`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver` v4 @kind this, `java.util.concurrent.Callable` v5 @kind object) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.tryEmitScalar:(Ljava/util/concurrent/Callable;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L423de8.  v0:= 1I;
  #L423dea.  call temp:= `call`(v5) @signature `Ljava/util/concurrent/Callable;.call:()Ljava/lang/Object;` @kind interface;
  #L423df0.  v5:= temp @kind object;
  #L423df2.  if v5 != 0 then goto L423df8;
  #L423df6.  return v0;
  #L423df8.  call temp:= `get`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.get:()I` @kind virtual;
  #L423dfe.  v1:= temp;
  #L423e00.  v2:= 0I;
  #L423e02.  if v1 != 0 then goto L423e2a;
  #L423e06.  call temp:= `compareAndSet`(v4, v2, v0) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.compareAndSet:(II)Z` @kind virtual;
  #L423e0c.  v1:= temp;
  #L423e0e.  if v1 == 0 then goto L423e2a;
  #L423e12.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.downstream` @type ^`io.reactivex.Observer` @kind object;
  #L423e16.  call `onNext`(v1, v5) @signature `Lio/reactivex/Observer;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L423e1c.  call temp:= `decrementAndGet`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.decrementAndGet:()I` @kind virtual;
  #L423e22.  v5:= temp;
  #L423e24.  if v5 != 0 then goto L423e90;
  #L423e28.  return v0;
  #L423e2a.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` @kind object;
  #L423e2e.  if v1 != 0 then goto L423e60;
  #L423e32.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.maxConcurrency` @type ^`int`;
  #L423e36.  v3:= 2147483647I;
  #L423e3c.  if v1 != v3 then goto L423e50;
  #L423e40.  v1:= new `io.reactivex.internal.queue.SpscLinkedArrayQueue`;
  #L423e44.  v3:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.bufferSize` @type ^`int`;
  #L423e48.  call `<init>`(v1, v3) @signature `Lio/reactivex/internal/queue/SpscLinkedArrayQueue;.<init>:(I)V` @kind direct;
  #L423e4e.  goto L423e5c;
  #L423e50.  v3:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L423e54.  call `<init>`(v3, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L423e5a.  v1:= v3 @kind object;
  #L423e5c.  v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.queue` @type ^`io.reactivex.internal.fuseable.SimplePlainQueue` := v1 @kind object;
  #L423e60.  call temp:= `offer`(v1, v5) @signature `Lio/reactivex/internal/fuseable/SimplePlainQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L423e66.  v5:= temp;
  #L423e68.  if v5 != 0 then goto L423e82;
  #L423e6c.  v5:= new `java.lang.IllegalStateException`;
  #L423e70.  v1:= "Scalar queue full?!" @kind object;
  #L423e74.  call `<init>`(v5, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L423e7a.  call `onError`(v4, v5) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L423e80.  return v0;
  #L423e82.  call temp:= `getAndIncrement`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.getAndIncrement:()I` @kind virtual;
  #L423e88.  v5:= temp;
  #L423e8a.  if v5 == 0 then goto L423e90;
  #L423e8e.  return v2;
  #L423e90.  call `drainLoop`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drainLoop:()V` @kind virtual;
  #L423e96.  return v0;
  #L423e98.  v5:= Exception @type ^`java.lang.Throwable` @kind object;
  #L423e9a.  call `throwIfFatal`(v5) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L423ea0.  v1:= v4.`io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L423ea4.  call temp:= `addThrowable`(v1, v5) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L423eaa.  call `drain`(v4) @signature `Lio/reactivex/internal/operators/observable/ObservableFlatMap$MergeObserver;.drain:()V` @kind virtual;
  #L423eb0.  return v0;
  catch `java.lang.Throwable` @[L423dea..L423df2] goto L423e98;
}

record `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.FlowableSubscriber` @kind interface, `io.reactivex.disposables.Disposable` @kind interface {
  `int` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.bufferSize` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.current` @AccessFlag FINAL;
  `io.reactivex.internal.fuseable.SimpleQueue` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.queue` @AccessFlag VOLATILE;
  `java.util.concurrent.atomic.AtomicBoolean` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.shouldConnect` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.sourceMode` @AccessFlag ;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @AccessFlag FINAL;
  `java.lang.Object` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @AccessFlag VOLATILE;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @AccessFlag FINAL;
}
global `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.EMPTY` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L4019f4.  v0:= 0I;
  #L4019f6.  v1:= new `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[v0];
  #L4019fa.  `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.EMPTY` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] := v1 @kind object;
  #L4019fe.  v0:= new `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[v0];
  #L401a02.  `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] := v0 @kind object;
  #L401a06.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v2 @kind this, `java.util.concurrent.atomic.AtomicReference` v3 @kind object, `int` v4 ) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.<init>:(Ljava/util/concurrent/atomic/AtomicReference;I)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L401a18.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L401a1e.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L401a22.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L401a28.  v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L401a2c.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L401a30.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.EMPTY` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L401a34.  call `<init>`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:(Ljava/lang/Object;)V` @kind direct;
  #L401a3a.  v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L401a3e.  v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.current` @type ^`java.util.concurrent.atomic.AtomicReference` := v3 @kind object;
  #L401a42.  v3:= new `java.util.concurrent.atomic.AtomicBoolean`;
  #L401a46.  call `<init>`(v3) @signature `Ljava/util/concurrent/atomic/AtomicBoolean;.<init>:()V` @kind direct;
  #L401a4c.  v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.shouldConnect` @type ^`java.util.concurrent.atomic.AtomicBoolean` := v3 @kind object;
  #L401a50.  v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.bufferSize` @type ^`int` := v4;
  #L401a54.  return @kind void;
}
procedure `boolean` `add`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v4 @kind this, `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber` v5 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.add:(Lio/reactivex/internal/operators/flowable/FlowablePublish$InnerSubscriber;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L4018c0.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4018c4.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4018ca.  v0:= temp @kind object;
  #L4018cc.  v0:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v0 @kind object;
  #L4018d0.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L4018d4.  v2:= 0I;
  #L4018d6.  if v0 != v1 then goto L4018dc;
  #L4018da.  return v2;
  #L4018dc.  v1:= length @variable v0;
  #L4018de.  v3:= v1 + 1;
  #L4018e2.  v3:= new `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[v3];
  #L4018e6.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L4018ec.  v3[v1]:= v5 @kind object;
  #L4018f0.  v1:= v4.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4018f4.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L4018fa.  v0:= temp;
  #L4018fc.  if v0 == 0 then goto L4018c0;
  #L401900.  v5:= 1I;
  #L401902.  return v5;
}
procedure `boolean` `checkTerminated`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v4 @kind this, `java.lang.Object` v5 @kind object, `boolean` v6 ) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.checkTerminated:(Ljava/lang/Object;Z)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L401914.  v0:= 0I;
  #L401916.  if v5 == 0 then goto L4019b6;
  #L40191a.  call temp:= `isComplete`(v5) @signature `Lio/reactivex/internal/util/NotificationLite;.isComplete:(Ljava/lang/Object;)Z` @kind static;
  #L401920.  v1:= temp;
  #L401922.  v2:= 0I;
  #L401924.  v3:= 1I;
  #L401926.  if v1 == 0 then goto L401968;
  #L40192a.  if v6 == 0 then goto L4019b6;
  #L40192e.  v5:= v4.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.current` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401932.  call temp:= `compareAndSet`(v5, v4, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L401938.  v5:= v4.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L40193c.  v6:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L401940.  call temp:= `getAndSet`(v5, v6) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L401946.  v5:= temp @kind object;
  #L401948.  v5:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v5 @kind object;
  #L40194c.  v6:= length @variable v5;
  #L40194e.  if v0 >= v6 then goto L401966;
  #L401952.  v1:= v5[v0] @kind object;
  #L401956.  v1:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.child` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L40195a.  call `onComplete`(v1) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L401960.  v0:= v0 + 1;
  #L401964.  goto L40194e;
  #L401966.  return v3;
  #L401968.  call temp:= `getError`(v5) @signature `Lio/reactivex/internal/util/NotificationLite;.getError:(Ljava/lang/Object;)Ljava/lang/Throwable;` @kind static;
  #L40196e.  v5:= temp @kind object;
  #L401970.  v6:= v4.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.current` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401974.  call temp:= `compareAndSet`(v6, v4, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L40197a.  v6:= v4.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L40197e.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L401982.  call temp:= `getAndSet`(v6, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L401988.  v6:= temp @kind object;
  #L40198a.  v6:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v6 @kind object;
  #L40198e.  v1:= length @variable v6;
  #L401990.  if v1 == 0 then goto L4019ae;
  #L401994.  v1:= length @variable v6;
  #L401996.  if v0 >= v1 then goto L4019b4;
  #L40199a.  v2:= v6[v0] @kind object;
  #L40199e.  v2:= v2.`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.child` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L4019a2.  call `onError`(v2, v5) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L4019a8.  v0:= v0 + 1;
  #L4019ac.  goto L401996;
  #L4019ae.  call `onError`(v5) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L4019b4.  return v3;
  #L4019b6.  return v0;
}
procedure `void` `dispatch`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v25 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.dispatch:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;
    v23;
    v24;

  #L401a68.  v1:= v25 @kind object;
  #L401a6c.  call temp:= `getAndIncrement`(v25) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.getAndIncrement:()I` @kind virtual;
  #L401a72.  v0:= temp;
  #L401a74.  if v0 == 0 then goto L401a7a;
  #L401a78.  return @kind void;
  #L401a7a.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401a7e.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401a84.  v0:= temp @kind object;
  #L401a86.  v0:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v0 @kind object;
  #L401a8a.  v3:= 1I;
  #L401a8c.  v4:= v0 @kind object;
  #L401a8e.  v5:= 1I;
  #L401a90.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` @kind object;
  #L401a94.  v6:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L401a98.  if v6 == 0 then goto L401aae;
  #L401a9c.  call temp:= `isEmpty`(v6) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L401aa2.  v8:= temp;
  #L401aa4.  if v8 == 0 then goto L401aaa;
  #L401aa8.  goto L401aae;
  #L401aaa.  v8:= 0I;
  #L401aac.  goto L401ab0;
  #L401aae.  v8:= 1I;
  #L401ab0.  call temp:= `checkTerminated`(v1, v0, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.checkTerminated:(Ljava/lang/Object;Z)Z` @kind virtual;
  #L401ab6.  v0:= temp;
  #L401ab8.  if v0 == 0 then goto L401abe;
  #L401abc.  return @kind void;
  #L401abe.  if v8 != 0 then goto L401cea;
  #L401ac2.  v0:= length @variable v4;
  #L401ac4.  v9:= length @variable v4;
  #L401ac6.  v12:= 0I;
  #L401ac8.  v13:= 0I;
  #L401aca.  v14:= 9223372036854775807L;
  #L401ad4.  v16:= -9223372036854775808L;
  #L401ad8.  if v12 >= v9 then goto L401b0e;
  #L401adc.  v7:= v4[v12] @kind object;
  #L401ae0.  call temp:= `get`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$InnerSubscriber;.get:()J` @kind virtual;
  #L401ae6.  v18:= temp @kind wide;
  #L401ae8.  v20:= lcmp(v18, v16);
  #L401aec.  if v20 == 0 then goto L401b04;
  #L401af0.  v10:= v7.`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.emitted` @type ^`long` @kind wide;
  #L401af4.  v10:= v18 - v10 @kind long;
  #L401af8.  call temp:= `min`(v14, v10) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L401afe.  v10:= temp @kind wide;
  #L401b00.  v14:= v10 @kind wide;
  #L401b02.  goto L401b08;
  #L401b04.  v13:= v13 + 1;
  #L401b08.  v12:= v12 + 1;
  #L401b0c.  goto L401ad4;
  #L401b0e.  v9:= 1L;
  #L401b12.  if v0 != v13 then goto L401b8e;
  #L401b16.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` @kind object;
  #L401b1a.  call temp:= `poll`(v6) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L401b20.  v7:= temp @kind object;
  #L401b22.  goto L401b52;
  #L401b24.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L401b26.  v6:= v0 @kind object;
  #L401b28.  call `throwIfFatal`(v6) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L401b2e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401b32.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401b38.  v0:= temp @kind object;
  #L401b3a.  v0:= (`org.reactivestreams.Subscription`) v0 @kind object;
  #L401b3e.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L401b44.  call temp:= `error`(v6) @signature `Lio/reactivex/internal/util/NotificationLite;.error:(Ljava/lang/Throwable;)Ljava/lang/Object;` @kind static;
  #L401b4a.  v0:= temp @kind object;
  #L401b4c.  v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` := v0 @kind object;
  #L401b50.  v7:= 0I;
  #L401b52.  if v7 != 0 then goto L401b5a;
  #L401b56.  v6:= 1I;
  #L401b58.  goto L401b5c;
  #L401b5a.  v6:= 0I;
  #L401b5c.  call temp:= `checkTerminated`(v1, v0, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.checkTerminated:(Ljava/lang/Object;Z)Z` @kind virtual;
  #L401b62.  v0:= temp;
  #L401b64.  if v0 == 0 then goto L401b6a;
  #L401b68.  return @kind void;
  #L401b6a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.sourceMode` @type ^`int`;
  #L401b6e.  if v0 == v3 then goto L401b88;
  #L401b72.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401b76.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401b7c.  v0:= temp @kind object;
  #L401b7e.  v0:= (`org.reactivestreams.Subscription`) v0 @kind object;
  #L401b82.  call `request`(v0, v9) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L401b88.  v6:= 1I;
  #L401b8a.  goto L401ce8;
  #L401b8e.  v0:= v8;
  #L401b90.  v8:= 0I;
  #L401b92.  v11:= (`long`) v8 @kind i2l;
  #L401b94.  v13:= lcmp(v11, v14);
  #L401b98.  if v13 >= 0 then goto L401cb0;
  #L401b9c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` @kind object;
  #L401ba0.  call temp:= `poll`(v6) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L401ba6.  v13:= temp @kind object;
  #L401ba8.  goto L401bd8;
  #L401baa.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L401bac.  v13:= v0 @kind object;
  #L401bae.  call `throwIfFatal`(v13) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L401bb4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401bb8.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401bbe.  v0:= temp @kind object;
  #L401bc0.  v0:= (`org.reactivestreams.Subscription`) v0 @kind object;
  #L401bc4.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L401bca.  call temp:= `error`(v13) @signature `Lio/reactivex/internal/util/NotificationLite;.error:(Ljava/lang/Throwable;)Ljava/lang/Object;` @kind static;
  #L401bd0.  v0:= temp @kind object;
  #L401bd2.  v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` := v0 @kind object;
  #L401bd6.  v13:= 0I;
  #L401bd8.  if v13 != 0 then goto L401be0;
  #L401bdc.  v7:= 1I;
  #L401bde.  goto L401be2;
  #L401be0.  v7:= 0I;
  #L401be2.  call temp:= `checkTerminated`(v1, v0, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.checkTerminated:(Ljava/lang/Object;Z)Z` @kind virtual;
  #L401be8.  v0:= temp;
  #L401bea.  if v0 == 0 then goto L401bf0;
  #L401bee.  return @kind void;
  #L401bf0.  if v7 == 0 then goto L401bf8;
  #L401bf4.  v0:= v7;
  #L401bf6.  goto L401cb0;
  #L401bf8.  call temp:= `getValue`(v13) @signature `Lio/reactivex/internal/util/NotificationLite;.getValue:(Ljava/lang/Object;)Ljava/lang/Object;` @kind static;
  #L401bfe.  v0:= temp @kind object;
  #L401c00.  v11:= length @variable v4;
  #L401c02.  v12:= 0I;
  #L401c04.  v13:= 0I;
  #L401c06.  if v12 >= v11 then goto L401c72;
  #L401c0a.  v3:= v4[v12] @kind object;
  #L401c0e.  call temp:= `get`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$InnerSubscriber;.get:()J` @kind virtual;
  #L401c14.  v22:= temp @kind wide;
  #L401c16.  v24:= lcmp(v22, v16);
  #L401c1a.  if v24 == 0 then goto L401c4e;
  #L401c1e.  v20:= 9223372036854775807L;
  #L401c28.  v24:= lcmp(v22, v20);
  #L401c2c.  v22:= v6 @kind object;
  #L401c30.  v23:= v7;
  #L401c34.  if v24 == 0 then goto L401c42;
  #L401c38.  v6:= v3.`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.emitted` @type ^`long` @kind wide;
  #L401c3c.  v6:= v6 + v9 @kind long;
  #L401c3e.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.emitted` @type ^`long` := v6 @kind wide;
  #L401c42.  v3:= v3.`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.child` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L401c46.  call `onNext`(v3, v0) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L401c4c.  goto L401c62;
  #L401c4e.  v22:= v6 @kind object;
  #L401c52.  v23:= v7;
  #L401c56.  v20:= 9223372036854775807L;
  #L401c60.  v13:= 1I;
  #L401c62.  v12:= v12 + 1;
  #L401c66.  v6:= v22 @kind object;
  #L401c6a.  v7:= v23;
  #L401c6e.  v3:= 1I;
  #L401c70.  goto L401c06;
  #L401c72.  v22:= v6 @kind object;
  #L401c76.  v23:= v7;
  #L401c7a.  v20:= 9223372036854775807L;
  #L401c84.  v8:= v8 + 1;
  #L401c88.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401c8e.  v0:= temp @kind object;
  #L401c90.  v0:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v0 @kind object;
  #L401c94.  if v13 != 0 then goto L401cac;
  #L401c98.  if v0 == v4 then goto L401c9e;
  #L401c9c.  goto L401cac;
  #L401c9e.  v6:= v22 @kind object;
  #L401ca2.  v0:= v23;
  #L401ca6.  v3:= 1I;
  #L401ca8.  goto L401b92;
  #L401cac.  v4:= v0 @kind object;
  #L401cae.  goto L401d0a;
  #L401cb0.  if v8 <= 0 then goto L401cd6;
  #L401cb4.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.sourceMode` @type ^`int`;
  #L401cb8.  v6:= 1I;
  #L401cba.  if v3 == v6 then goto L401cd8;
  #L401cbe.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401cc2.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401cc8.  v3:= temp @kind object;
  #L401cca.  v3:= (`org.reactivestreams.Subscription`) v3 @kind object;
  #L401cce.  call `request`(v3, v11) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L401cd4.  goto L401cd8;
  #L401cd6.  v6:= 1I;
  #L401cd8.  v7:= 0L;
  #L401cdc.  v3:= lcmp(v14, v7);
  #L401ce0.  if v3 == 0 then goto L401cec;
  #L401ce4.  if v0 != 0 then goto L401cec;
  #L401ce8.  goto L401d0a;
  #L401cea.  v6:= 1I;
  #L401cec.  v0:= -v5 @kind int;
  #L401cee.  call temp:= `addAndGet`(v1, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.addAndGet:(I)I` @kind virtual;
  #L401cf4.  v5:= temp;
  #L401cf6.  if v5 != 0 then goto L401cfc;
  #L401cfa.  return @kind void;
  #L401cfc.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401d02.  v0:= temp @kind object;
  #L401d04.  v4:= v0 @kind object;
  #L401d06.  v4:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v4 @kind object;
  #L401d0a.  v3:= 1I;
  #L401d0c.  goto L401a90;
  catch `java.lang.Throwable` @[L401b1a..L401b22] goto L401b24;
  catch `java.lang.Throwable` @[L401ba0..L401ba8] goto L401baa;
}
procedure `void` `dispose`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.dispose:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L401d38.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401d3c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401d42.  v0:= temp @kind object;
  #L401d44.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L401d48.  if v0 == v1 then goto L401d7a;
  #L401d4c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401d50.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L401d56.  v0:= temp @kind object;
  #L401d58.  v0:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v0 @kind object;
  #L401d5c.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L401d60.  if v0 == v1 then goto L401d7a;
  #L401d64.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.current` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401d68.  v1:= 0I;
  #L401d6a.  call temp:= `compareAndSet`(v0, v2, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L401d70.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401d74.  call temp:= `cancel`(v0) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.cancel:(Ljava/util/concurrent/atomic/AtomicReference;)Z` @kind static;
  #L401d7a.  return @kind void;
}
procedure `boolean` `isDisposed`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.isDisposed:()Z` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L4019c8.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L4019cc.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L4019d2.  v0:= temp @kind object;
  #L4019d4.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.TERMINATED` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L4019d8.  if v0 != v1 then goto L4019e0;
  #L4019dc.  v0:= 1I;
  #L4019de.  goto L4019e2;
  #L4019e0.  v0:= 0I;
  #L4019e2.  return v0;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L401d8c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` @kind object;
  #L401d90.  if v0 != 0 then goto L401da6;
  #L401d94.  call temp:= `complete`() @signature `Lio/reactivex/internal/util/NotificationLite;.complete:()Ljava/lang/Object;` @kind static;
  #L401d9a.  v0:= temp @kind object;
  #L401d9c.  v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` := v0 @kind object;
  #L401da0.  call `dispatch`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.dispatch:()V` @kind virtual;
  #L401da6.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L401db8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` @kind object;
  #L401dbc.  if v0 != 0 then goto L401dd4;
  #L401dc0.  call temp:= `error`(v2) @signature `Lio/reactivex/internal/util/NotificationLite;.error:(Ljava/lang/Throwable;)Ljava/lang/Object;` @kind static;
  #L401dc6.  v2:= temp @kind object;
  #L401dc8.  v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` := v2 @kind object;
  #L401dcc.  call `dispatch`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.dispatch:()V` @kind virtual;
  #L401dd2.  goto L401dda;
  #L401dd4.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L401dda.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v1 @kind this, `java.lang.Object` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L401dec.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.sourceMode` @type ^`int`;
  #L401df0.  if v0 != 0 then goto L401e1a;
  #L401df4.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L401df8.  call temp:= `offer`(v0, v2) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L401dfe.  v2:= temp;
  #L401e00.  if v2 != 0 then goto L401e1a;
  #L401e04.  v2:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L401e08.  v0:= "Prefetch queue is full?!" @kind object;
  #L401e0c.  call `<init>`(v2, v0) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L401e12.  call `onError`(v1, v2) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L401e18.  return @kind void;
  #L401e1a.  call `dispatch`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.dispatch:()V` @kind virtual;
  #L401e20.  return @kind void;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v3 @kind this, `org.reactivestreams.Subscription` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L401e34.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.upstream` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401e38.  call temp:= `setOnce`(v0, v4) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.setOnce:(Ljava/util/concurrent/atomic/AtomicReference;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L401e3e.  v0:= temp;
  #L401e40.  if v0 == 0 then goto L401eb8;
  #L401e44.  v0:= instanceof @variable v4 @type ^`io.reactivex.internal.fuseable.QueueSubscription` @kind boolean;
  #L401e48.  if v0 == 0 then goto L401e9a;
  #L401e4c.  v0:= v4 @kind object;
  #L401e4e.  v0:= (`io.reactivex.internal.fuseable.QueueSubscription`) v0 @kind object;
  #L401e52.  v1:= 7I;
  #L401e54.  call temp:= `requestFusion`(v0, v1) @signature `Lio/reactivex/internal/fuseable/QueueSubscription;.requestFusion:(I)I` @kind interface;
  #L401e5a.  v1:= temp;
  #L401e5c.  v2:= 1I;
  #L401e5e.  if v1 != v2 then goto L401e7e;
  #L401e62.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.sourceMode` @type ^`int` := v1;
  #L401e66.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L401e6a.  call temp:= `complete`() @signature `Lio/reactivex/internal/util/NotificationLite;.complete:()Ljava/lang/Object;` @kind static;
  #L401e70.  v4:= temp @kind object;
  #L401e72.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.terminalEvent` @type ^`java.lang.Object` := v4 @kind object;
  #L401e76.  call `dispatch`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.dispatch:()V` @kind virtual;
  #L401e7c.  return @kind void;
  #L401e7e.  v2:= 2I;
  #L401e80.  if v1 != v2 then goto L401e9a;
  #L401e84.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.sourceMode` @type ^`int` := v1;
  #L401e88.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L401e8c.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.bufferSize` @type ^`int`;
  #L401e90.  v0:= (`long`) v0 @kind i2l;
  #L401e92.  call `request`(v4, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L401e98.  return @kind void;
  #L401e9a.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L401e9e.  v1:= v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.bufferSize` @type ^`int`;
  #L401ea2.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L401ea8.  v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` := v0 @kind object;
  #L401eac.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.bufferSize` @type ^`int`;
  #L401eb0.  v0:= (`long`) v0 @kind i2l;
  #L401eb2.  call `request`(v4, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L401eb8.  return @kind void;
}
procedure `void` `remove`(`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber` v6 @kind this, `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber` v7 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowablePublish$PublishSubscriber;.remove:(Lio/reactivex/internal/operators/flowable/FlowablePublish$InnerSubscriber;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L401ecc.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401ed0.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L401ed6.  v0:= temp @kind object;
  #L401ed8.  v0:= (`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[]) v0 @kind object;
  #L401edc.  v1:= length @variable v0;
  #L401ede.  if v1 != 0 then goto L401ee4;
  #L401ee2.  goto L401f48;
  #L401ee4.  v2:= -1I;
  #L401ee6.  v3:= 0I;
  #L401ee8.  v4:= 0I;
  #L401eea.  if v4 >= v1 then goto L401f08;
  #L401eee.  v5:= v0[v4] @kind object;
  #L401ef2.  call temp:= `equals`(v5, v7) @signature `Ljava/lang/Object;.equals:(Ljava/lang/Object;)Z` @kind virtual;
  #L401ef8.  v5:= temp;
  #L401efa.  if v5 == 0 then goto L401f02;
  #L401efe.  v2:= v4;
  #L401f00.  goto L401f08;
  #L401f02.  v4:= v4 + 1;
  #L401f06.  goto L401eea;
  #L401f08.  if v2 >= 0 then goto L401f0e;
  #L401f0c.  return @kind void;
  #L401f0e.  v4:= 1I;
  #L401f10.  if v1 != v4 then goto L401f1a;
  #L401f14.  v1:= `@@io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.EMPTY` @type ^`io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[] @kind object;
  #L401f18.  goto L401f38;
  #L401f1a.  v5:= v1 + -1;
  #L401f1e.  v5:= new `io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber`[v5];
  #L401f22.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L401f28.  v3:= v2 + 1;
  #L401f2c.  v1:= v1 - v2 @kind int;
  #L401f2e.  v1:= v1 - v4 @kind int;
  #L401f30.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L401f36.  v1:= v5 @kind object;
  #L401f38.  v2:= v6.`io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L401f3c.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L401f42.  v0:= temp;
  #L401f44.  if v0 == 0 then goto L401ecc;
  #L401f48.  return @kind void;
}

record `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `io.reactivex.FlowableSubscriber` @kind interface, `org.reactivestreams.Subscription` @kind interface {
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @AccessFlag VOLATILE;
  `org.reactivestreams.Subscriber` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @AccessFlag FINAL;
  `io.reactivex.functions.Function` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.mapper` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @AccessFlag VOLATILE;
  `org.reactivestreams.Subscription` `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @AccessFlag ;
}
global `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L408bb4.  v0:= new `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`;
  #L408bb8.  v1:= 0I;
  #L408bba.  v2:= -1L;
  #L408bbe.  v4:= 1I;
  #L408bc0.  call `<init>`(v0, v1, v2, v4) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;JI)V` @kind direct;
  #L408bc6.  `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` := v0 @kind object;
  #L408bca.  v0:= `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` @kind object;
  #L408bce.  call `cancel`(v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L408bd4.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this, `org.reactivestreams.Subscriber` v2 @kind object, `io.reactivex.functions.Function` v3 @kind object, `int` v4 , `boolean` v5 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.<init>:(Lorg/reactivestreams/Subscriber;Lio/reactivex/functions/Function;IZ)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;

  #L408be8.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L408bee.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L408bf2.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L408bf8.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L408bfc.  v0:= new `java.util.concurrent.atomic.AtomicLong`;
  #L408c00.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L408c06.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` := v0 @kind object;
  #L408c0a.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @type ^`org.reactivestreams.Subscriber` := v2 @kind object;
  #L408c0e.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.mapper` @type ^`io.reactivex.functions.Function` := v3 @kind object;
  #L408c12.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.bufferSize` @type ^`int` := v4;
  #L408c16.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` := v5 @kind boolean;
  #L408c1a.  v2:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L408c1e.  call `<init>`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L408c24.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` := v2 @kind object;
  #L408c28.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L408c3c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L408c40.  if v0 != 0 then goto L408c5a;
  #L408c44.  v0:= 1I;
  #L408c46.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L408c4a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`org.reactivestreams.Subscription` @kind object;
  #L408c4e.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L408c54.  call `disposeInner`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L408c5a.  return @kind void;
}
procedure `void` `disposeInner`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L408c6c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408c70.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L408c76.  v0:= temp @kind object;
  #L408c78.  v0:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v0 @kind object;
  #L408c7c.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` @kind object;
  #L408c80.  if v0 == v1 then goto L408ca6;
  #L408c84.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408c88.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L408c8e.  v0:= temp @kind object;
  #L408c90.  v0:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v0 @kind object;
  #L408c94.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` @kind object;
  #L408c98.  if v0 == v1 then goto L408ca6;
  #L408c9c.  if v0 == 0 then goto L408ca6;
  #L408ca0.  call `cancel`(v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L408ca6.  return @kind void;
}
procedure `void` `drain`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v17 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;

  #L408cb8.  v1:= v17 @kind object;
  #L408cbc.  call temp:= `getAndIncrement`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.getAndIncrement:()I` @kind virtual;
  #L408cc2.  v0:= temp;
  #L408cc4.  if v0 == 0 then goto L408cca;
  #L408cc8.  return @kind void;
  #L408cca.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L408cce.  v4:= 1I;
  #L408cd0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L408cd4.  v5:= 0I;
  #L408cd6.  if v0 == 0 then goto L408ce6;
  #L408cda.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408cde.  call `lazySet`(v0, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L408ce4.  return @kind void;
  #L408ce6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L408cea.  if v0 == 0 then goto L408d7c;
  #L408cee.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L408cf2.  if v0 == 0 then goto L408d36;
  #L408cf6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408cfa.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L408d00.  v0:= temp @kind object;
  #L408d02.  if v0 != 0 then goto L408d7c;
  #L408d06.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408d0a.  call temp:= `get`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.get:()Ljava/lang/Object;` @kind virtual;
  #L408d10.  v0:= temp @kind object;
  #L408d12.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L408d16.  if v0 == 0 then goto L408d2e;
  #L408d1a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408d1e.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L408d24.  v0:= temp @kind object;
  #L408d26.  call `onError`(v2, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L408d2c.  goto L408d34;
  #L408d2e.  call `onComplete`(v2) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L408d34.  return @kind void;
  #L408d36.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408d3a.  call temp:= `get`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.get:()Ljava/lang/Object;` @kind virtual;
  #L408d40.  v0:= temp @kind object;
  #L408d42.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L408d46.  if v0 == 0 then goto L408d64;
  #L408d4a.  call `disposeInner`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L408d50.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408d54.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L408d5a.  v0:= temp @kind object;
  #L408d5c.  call `onError`(v2, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L408d62.  return @kind void;
  #L408d64.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408d68.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L408d6e.  v0:= temp @kind object;
  #L408d70.  if v0 != 0 then goto L408d7c;
  #L408d74.  call `onComplete`(v2) @signature `Lorg/reactivestreams/Subscriber;.onComplete:()V` @kind interface;
  #L408d7a.  return @kind void;
  #L408d7c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408d80.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L408d86.  v0:= temp @kind object;
  #L408d88.  v6:= v0 @kind object;
  #L408d8a.  v6:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v6 @kind object;
  #L408d8e.  if v6 == 0 then goto L408d9a;
  #L408d92.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber.queue` @type ^`io.reactivex.internal.fuseable.SimpleQueue` @kind object;
  #L408d96.  v7:= v0 @kind object;
  #L408d98.  goto L408d9c;
  #L408d9a.  v7:= v5 @kind object;
  #L408d9c.  if v7 == 0 then goto L408f36;
  #L408da0.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber.done` @type ^`boolean` @kind boolean;
  #L408da4.  if v0 == 0 then goto L408e12;
  #L408da8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L408dac.  if v0 != 0 then goto L408df8;
  #L408db0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408db4.  call temp:= `get`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.get:()Ljava/lang/Object;` @kind virtual;
  #L408dba.  v0:= temp @kind object;
  #L408dbc.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L408dc0.  if v0 == 0 then goto L408dde;
  #L408dc4.  call `disposeInner`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L408dca.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408dce.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L408dd4.  v0:= temp @kind object;
  #L408dd6.  call `onError`(v2, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L408ddc.  return @kind void;
  #L408dde.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L408de4.  v0:= temp;
  #L408de6.  if v0 == 0 then goto L408e12;
  #L408dea.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408dee.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L408df4.  goto L408cd0;
  #L408df8.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.isEmpty:()Z` @kind interface;
  #L408dfe.  v0:= temp;
  #L408e00.  if v0 == 0 then goto L408e12;
  #L408e04.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408e08.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L408e0e.  goto L408cd0;
  #L408e12.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L408e16.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L408e1c.  v8:= temp @kind wide;
  #L408e1e.  v10:= 0L;
  #L408e22.  v12:= v10 @kind wide;
  #L408e24.  v14:= 0I;
  #L408e26.  v0:= lcmp(v12, v8);
  #L408e2a.  if v0 == 0 then goto L408eee;
  #L408e2e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L408e32.  if v0 == 0 then goto L408e38;
  #L408e36.  return @kind void;
  #L408e38.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber.done` @type ^`boolean` @kind boolean;
  #L408e3c.  call temp:= `poll`(v7) @signature `Lio/reactivex/internal/fuseable/SimpleQueue;.poll:()Ljava/lang/Object;` @kind interface;
  #L408e42.  v15:= temp @kind object;
  #L408e44.  goto L408e64;
  #L408e46.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L408e48.  v15:= v0 @kind object;
  #L408e4a.  call `throwIfFatal`(v15) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L408e50.  call `cancel`(v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L408e56.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408e5a.  call temp:= `addThrowable`(v0, v15) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L408e60.  v15:= v5 @kind object;
  #L408e62.  v0:= 1I;
  #L408e64.  if v15 != 0 then goto L408e6e;
  #L408e68.  v16:= 1I;
  #L408e6c.  goto L408e72;
  #L408e6e.  v16:= 0I;
  #L408e72.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408e76.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L408e7c.  v3:= temp @kind object;
  #L408e7e.  if v6 == v3 then goto L408e86;
  #L408e82.  v14:= 1I;
  #L408e84.  goto L408eee;
  #L408e86.  if v0 == 0 then goto L408eda;
  #L408e8a.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L408e8e.  if v0 != 0 then goto L408eca;
  #L408e92.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408e96.  call temp:= `get`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.get:()Ljava/lang/Object;` @kind virtual;
  #L408e9c.  v0:= temp @kind object;
  #L408e9e.  v0:= (`java.lang.Throwable`) v0 @kind object;
  #L408ea2.  if v0 == 0 then goto L408eba;
  #L408ea6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408eaa.  call temp:= `terminate`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.terminate:()Ljava/lang/Throwable;` @kind virtual;
  #L408eb0.  v0:= temp @kind object;
  #L408eb2.  call `onError`(v2, v0) @signature `Lorg/reactivestreams/Subscriber;.onError:(Ljava/lang/Throwable;)V` @kind interface;
  #L408eb8.  return @kind void;
  #L408eba.  if v16 == 0 then goto L408eda;
  #L408ebe.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408ec2.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L408ec8.  goto L408e82;
  #L408eca.  if v16 == 0 then goto L408eda;
  #L408ece.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408ed2.  call temp:= `compareAndSet`(v0, v6, v5) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L408ed8.  goto L408e82;
  #L408eda.  if v16 == 0 then goto L408ee0;
  #L408ede.  goto L408eee;
  #L408ee0.  call `onNext`(v2, v15) @signature `Lorg/reactivestreams/Subscriber;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L408ee6.  v14:= 1L;
  #L408eea.  v12:= v12 + v14 @kind long;
  #L408eec.  goto L408e24;
  #L408eee.  v0:= lcmp(v12, v10);
  #L408ef2.  if v0 == 0 then goto L408f2e;
  #L408ef6.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L408efa.  if v0 != 0 then goto L408f2e;
  #L408efe.  v10:= 9223372036854775807L;
  #L408f08.  v0:= lcmp(v8, v10);
  #L408f0c.  if v0 == 0 then goto L408f1c;
  #L408f10.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L408f14.  v7:= -v12 @kind long;
  #L408f16.  call temp:= `addAndGet`(v0, v7) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L408f1c.  call temp:= `get`(v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.get:()Ljava/lang/Object;` @kind virtual;
  #L408f22.  v0:= temp @kind object;
  #L408f24.  v0:= (`org.reactivestreams.Subscription`) v0 @kind object;
  #L408f28.  call `request`(v0, v12) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L408f2e.  if v14 == 0 then goto L408f36;
  #L408f32.  goto L408cd0;
  #L408f36.  v0:= -v4 @kind int;
  #L408f38.  call temp:= `addAndGet`(v1, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.addAndGet:(I)I` @kind virtual;
  #L408f3e.  v4:= temp;
  #L408f40.  if v4 != 0 then goto L408cd0;
  #L408f44.  return @kind void;
  catch `java.lang.Throwable` @[L408e3c..L408e44] goto L408e46;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L408f64.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L408f68.  if v0 == 0 then goto L408f6e;
  #L408f6c.  return @kind void;
  #L408f6e.  v0:= 1I;
  #L408f70.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` := v0 @kind boolean;
  #L408f74.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @kind virtual;
  #L408f7a.  return @kind void;
}
procedure `void` `onError`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onError:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L408f8c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L408f90.  if v0 != 0 then goto L408fc0;
  #L408f94.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.error` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L408f98.  call temp:= `addThrowable`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.addThrowable:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L408f9e.  v0:= temp;
  #L408fa0.  if v0 == 0 then goto L408fc0;
  #L408fa4.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L408fa8.  if v2 != 0 then goto L408fb2;
  #L408fac.  call `disposeInner`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.disposeInner:()V` @kind virtual;
  #L408fb2.  v2:= 1I;
  #L408fb4.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` := v2 @kind boolean;
  #L408fb8.  call `drain`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @kind virtual;
  #L408fbe.  goto L408fc6;
  #L408fc0.  call `onError`(v2) @signature `Lio/reactivex/plugins/RxJavaPlugins;.onError:(Ljava/lang/Throwable;)V` @kind static;
  #L408fc6.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v4 @kind this, `java.lang.Object` v5 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L408fd8.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.done` @type ^`boolean` @kind boolean;
  #L408fdc.  if v0 == 0 then goto L408fe2;
  #L408fe0.  return @kind void;
  #L408fe2.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @type ^`long` @kind wide;
  #L408fe6.  v2:= 1L;
  #L408fea.  v0:= v0 + v2 @kind long;
  #L408fec.  v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @type ^`long` := v0 @kind wide;
  #L408ff0.  v2:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L408ff4.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L408ffa.  v2:= temp @kind object;
  #L408ffc.  v2:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v2 @kind object;
  #L409000.  if v2 == 0 then goto L40900a;
  #L409004.  call `cancel`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.cancel:()V` @kind virtual;
  #L40900a.  v2:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.mapper` @type ^`io.reactivex.functions.Function` @kind object;
  #L40900e.  call temp:= `apply`(v2, v5) @signature `Lio/reactivex/functions/Function;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L409014.  v5:= temp @kind object;
  #L409016.  v2:= "The publisher returned is null" @kind object;
  #L40901a.  call temp:= `requireNonNull`(v5, v2) @signature `Lio/reactivex/internal/functions/ObjectHelper;.requireNonNull:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L409020.  v5:= temp @kind object;
  #L409022.  v5:= (`org.reactivestreams.Publisher`) v5 @kind object;
  #L409026.  v2:= new `io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`;
  #L40902a.  v3:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.bufferSize` @type ^`int`;
  #L40902e.  call `<init>`(v2, v4, v0, v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapInnerSubscriber;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;JI)V` @kind direct;
  #L409034.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L409038.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L40903e.  v0:= temp @kind object;
  #L409040.  v0:= (`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber`) v0 @kind object;
  #L409044.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.CANCELLED` @type ^`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapInnerSubscriber` @kind object;
  #L409048.  if v0 != v1 then goto L40904e;
  #L40904c.  goto L409064;
  #L40904e.  v1:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L409052.  call temp:= `compareAndSet`(v1, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L409058.  v0:= temp;
  #L40905a.  if v0 == 0 then goto L409034;
  #L40905e.  call `subscribe`(v5, v2) @signature `Lorg/reactivestreams/Publisher;.subscribe:(Lorg/reactivestreams/Subscriber;)V` @kind interface;
  #L409064.  return @kind void;
  #L409066.  v5:= Exception @type ^`java.lang.Throwable` @kind object;
  #L409068.  call `throwIfFatal`(v5) @signature `Lio/reactivex/exceptions/Exceptions;.throwIfFatal:(Ljava/lang/Throwable;)V` @kind static;
  #L40906e.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`org.reactivestreams.Subscription` @kind object;
  #L409072.  call `cancel`(v0) @signature `Lorg/reactivestreams/Subscription;.cancel:()V` @kind interface;
  #L409078.  call `onError`(v4, v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onError:(Ljava/lang/Throwable;)V` @kind virtual;
  #L40907e.  return @kind void;
  catch `java.lang.Throwable` @[L40900a..L409026] goto L409066;
}
procedure `void` `onSubscribe`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v1 @kind this, `org.reactivestreams.Subscription` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L40909c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`org.reactivestreams.Subscription` @kind object;
  #L4090a0.  call temp:= `validate`(v0, v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(Lorg/reactivestreams/Subscription;Lorg/reactivestreams/Subscription;)Z` @kind static;
  #L4090a6.  v0:= temp;
  #L4090a8.  if v0 == 0 then goto L4090ba;
  #L4090ac.  v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`org.reactivestreams.Subscription` := v2 @kind object;
  #L4090b0.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.downstream` @type ^`org.reactivestreams.Subscriber` @kind object;
  #L4090b4.  call `onSubscribe`(v2, v1) @signature `Lorg/reactivestreams/Subscriber;.onSubscribe:(Lorg/reactivestreams/Subscription;)V` @kind interface;
  #L4090ba.  return @kind void;
}
procedure `void` `request`(`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber` v3 @kind this, `long` v4 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.request:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L4090cc.  call temp:= `validate`(v4) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.validate:(J)Z` @kind static;
  #L4090d2.  v0:= temp;
  #L4090d4.  if v0 == 0 then goto L40910e;
  #L4090d8.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L4090dc.  call temp:= `add`(v0, v4) @signature `Lio/reactivex/internal/util/BackpressureHelper;.add:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L4090e2.  v4:= v3.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.unique` @type ^`long` @kind wide;
  #L4090e6.  v0:= 0L;
  #L4090ea.  v2:= lcmp(v4, v0);
  #L4090ee.  if v2 != 0 then goto L409108;
  #L4090f2.  v4:= v3.`io.reactivex.internal.operators.flowable.FlowableSwitchMap$SwitchMapSubscriber.upstream` @type ^`org.reactivestreams.Subscription` @kind object;
  #L4090f6.  v0:= 9223372036854775807L;
  #L409100.  call `request`(v4, v0) @signature `Lorg/reactivestreams/Subscription;.request:(J)V` @kind interface;
  #L409106.  goto L40910e;
  #L409108.  call `drain`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableSwitchMap$SwitchMapSubscriber;.drain:()V` @kind virtual;
  #L40910e.  return @kind void;
}

record `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `b2.h` @kind interface, `d3.c` @kind interface {
  `d3.b` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @AccessFlag VOLATILE;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @AccessFlag ;
  `h2.e` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.mapper` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @AccessFlag FINAL;
  `k2.i` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @AccessFlag VOLATILE;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @AccessFlag ;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @AccessFlag FINAL;
  `long` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.uniqueId` @AccessFlag ;
  `d3.c` `io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @AccessFlag ;
}
global `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.a` @AccessFlag STATIC_FINAL;
global `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.b` @AccessFlag STATIC_FINAL;
global `long` `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L392528.  v0:= 0I;
  #L39252a.  v1:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v0];
  #L39252e.  `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.a` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] := v1 @kind object;
  #L392532.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v0];
  #L392536.  `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.b` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] := v0 @kind object;
  #L39253a.  return @kind void;
}
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `d3.b` v3 @kind object, `h2.e` v4 @kind object, `boolean` v5 , `int` v6 , `int` v7 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.<init>:(Ld3/b;Lh2/e;ZII)V` @AccessFlag CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L39254c.  call `<init>`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L392552.  v0:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L392556.  call `<init>`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L39255c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` := v0 @kind object;
  #L392560.  v0:= new `java.util.concurrent.atomic.AtomicReference`;
  #L392564.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L39256a.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` := v0 @kind object;
  #L39256e.  v1:= new `java.util.concurrent.atomic.AtomicLong`;
  #L392572.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L392578.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` := v1 @kind object;
  #L39257c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @type ^`d3.b` := v3 @kind object;
  #L392580.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.mapper` @type ^`h2.e` := v4 @kind object;
  #L392584.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` := v5 @kind boolean;
  #L392588.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int` := v6;
  #L39258c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int` := v7;
  #L392590.  v3:= 1I;
  #L392592.  v4:= v6 ^> 1;
  #L392596.  call temp:= `max`(v3, v4) @signature `Ljava/lang/Math;.max:(II)I` @kind static;
  #L39259c.  v3:= temp;
  #L39259e.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @type ^`int` := v3;
  #L3925a2.  v3:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.a` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L3925a6.  call `lazySet`(v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.lazySet:(Ljava/lang/Object;)V` @kind virtual;
  #L3925ac.  return @kind void;
}
procedure `void` `a`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.a:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L392af8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L392afc.  if v0 == 0 then goto L392b08;
  #L392b00.  call `q`(v2) @signature `Ll2/a;.q:(Ljava/lang/Throwable;)V` @kind static;
  #L392b06.  return @kind void;
  #L392b08.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L392b0c.  call temp:= `a`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.a:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L392b12.  v0:= temp;
  #L392b14.  if v0 == 0 then goto L392b26;
  #L392b18.  v2:= 1I;
  #L392b1a.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` := v2 @kind boolean;
  #L392b1e.  call `i`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.i:()V` @kind virtual;
  #L392b24.  goto L392b2c;
  #L392b26.  call `q`(v2) @signature `Ll2/a;.q:(Ljava/lang/Throwable;)V` @kind static;
  #L392b2c.  return @kind void;
}
procedure `boolean` `b`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v4 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v5 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.b:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L3923f0.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L3923f4.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L3923fa.  v0:= temp @kind object;
  #L3923fc.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L392400.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.b` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L392404.  v2:= 0I;
  #L392406.  if v0 != v1 then goto L392412;
  #L39240a.  call `e`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.e:()V` @kind virtual;
  #L392410.  return v2;
  #L392412.  v1:= length @variable v0;
  #L392414.  v3:= v1 + 1;
  #L392418.  v3:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v3];
  #L39241c.  call `arraycopy`(v0, v2, v3, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L392422.  v3[v1]:= v5 @kind object;
  #L392426.  v1:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L39242a.  call temp:= `compareAndSet`(v1, v0, v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L392430.  v0:= temp;
  #L392432.  if v0 == 0 then goto L3923f0;
  #L392436.  v5:= 1I;
  #L392438.  return v5;
}
procedure `void` `c`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `d3.c` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.c:(Ld3/c;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L392c4c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L392c50.  call temp:= `i`(v0, v3) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.i:(Ld3/c;Ld3/c;)Z` @kind static;
  #L392c56.  v0:= temp;
  #L392c58.  if v0 == 0 then goto L392c9a;
  #L392c5c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` := v3 @kind object;
  #L392c60.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @type ^`d3.b` @kind object;
  #L392c64.  call `c`(v0, v2) @signature `Ld3/b;.c:(Ld3/c;)V` @kind interface;
  #L392c6a.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L392c6e.  if v0 != 0 then goto L392c9a;
  #L392c72.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L392c76.  v1:= 2147483647I;
  #L392c7c.  if v0 != v1 then goto L392c92;
  #L392c80.  v0:= 9223372036854775807L;
  #L392c8a.  call `g`(v3, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L392c90.  goto L392c9a;
  #L392c92.  v0:= (`long`) v0 @kind i2l;
  #L392c94.  call `g`(v3, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L392c9a.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L3925c0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L3925c4.  if v0 != 0 then goto L3925f8;
  #L3925c8.  v0:= 1I;
  #L3925ca.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L3925ce.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L3925d2.  call `cancel`(v0) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L3925d8.  call `h`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.h:()V` @kind virtual;
  #L3925de.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L3925e4.  v0:= temp;
  #L3925e6.  if v0 != 0 then goto L3925f8;
  #L3925ea.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` @kind object;
  #L3925ee.  if v0 == 0 then goto L3925f8;
  #L3925f2.  call `clear`(v0) @signature `Lk2/j;.clear:()V` @kind interface;
  #L3925f8.  return @kind void;
}
procedure `boolean` `d`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v3 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L39244c.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L392450.  v1:= 1I;
  #L392452.  if v0 == 0 then goto L39245e;
  #L392456.  call `e`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.e:()V` @kind virtual;
  #L39245c.  return v1;
  #L39245e.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L392462.  if v0 != 0 then goto L39249c;
  #L392466.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L39246a.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L392470.  v0:= temp @kind object;
  #L392472.  if v0 == 0 then goto L39249c;
  #L392476.  call `e`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.e:()V` @kind virtual;
  #L39247c.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L392480.  call temp:= `b`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L392486.  v0:= temp @kind object;
  #L392488.  v2:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L39248c.  if v0 == v2 then goto L39249a;
  #L392490.  v2:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @type ^`d3.b` @kind object;
  #L392494.  call `a`(v2, v0) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L39249a.  return v1;
  #L39249c.  v0:= 0I;
  #L39249e.  return v0;
}
procedure `void` `e`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.e:()V` @AccessFlag  {
    temp;
    v0;

  #L39260c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` @kind object;
  #L392610.  if v0 == 0 then goto L39261a;
  #L392614.  call `clear`(v0) @signature `Lk2/j;.clear:()V` @kind interface;
  #L39261a.  return @kind void;
}
procedure `void` `g`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this, `long` v2 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.g:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L392d34.  call temp:= `h`(v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.h:(J)Z` @kind static;
  #L392d3a.  v0:= temp;
  #L392d3c.  if v0 == 0 then goto L392d50;
  #L392d40.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392d44.  call temp:= `a`(v0, v2) @signature `Lio/reactivex/internal/util/b;.a:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L392d4a.  call `i`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.i:()V` @kind virtual;
  #L392d50.  return @kind void;
}
procedure `void` `h`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v4 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.h:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;

  #L39262c.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L392630.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L392636.  v0:= temp @kind object;
  #L392638.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L39263c.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.b` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L392640.  if v0 == v1 then goto L39268e;
  #L392644.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L392648.  call temp:= `getAndSet`(v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L39264e.  v0:= temp @kind object;
  #L392650.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L392654.  if v0 == v1 then goto L39268e;
  #L392658.  v1:= length @variable v0;
  #L39265a.  v2:= 0I;
  #L39265c.  if v2 >= v1 then goto L392670;
  #L392660.  v3:= v0[v2] @kind object;
  #L392664.  call `e`(v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.e:()V` @kind virtual;
  #L39266a.  v2:= v2 + 1;
  #L39266e.  goto L39265c;
  #L392670.  v0:= v4.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L392674.  call temp:= `b`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L39267a.  v0:= temp @kind object;
  #L39267c.  if v0 == 0 then goto L39268e;
  #L392680.  v1:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L392684.  if v0 == v1 then goto L39268e;
  #L392688.  call `q`(v0) @signature `Ll2/a;.q:(Ljava/lang/Throwable;)V` @kind static;
  #L39268e.  return @kind void;
}
procedure `void` `i`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.i:()V` @AccessFlag  {
    temp;
    v0;

  #L3926a0.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L3926a6.  v0:= temp;
  #L3926a8.  if v0 != 0 then goto L3926b2;
  #L3926ac.  call `j`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.j:()V` @kind virtual;
  #L3926b2.  return @kind void;
}
procedure `void` `j`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v24 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.j:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;
    v17;
    v18;
    v19;
    v20;
    v21;
    v22;
    v23;

  #L3926c4.  v1:= v24 @kind object;
  #L3926c8.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @type ^`d3.b` @kind object;
  #L3926cc.  v4:= 1I;
  #L3926ce.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L3926d4.  v0:= temp;
  #L3926d6.  if v0 == 0 then goto L3926dc;
  #L3926da.  return @kind void;
  #L3926dc.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` @kind object;
  #L3926e0.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L3926e4.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L3926ea.  v5:= temp @kind wide;
  #L3926ec.  v7:= 9223372036854775807L;
  #L3926f6.  v10:= lcmp(v5, v7);
  #L3926fa.  if v10 != 0 then goto L392702;
  #L3926fe.  v10:= 1I;
  #L392700.  goto L392704;
  #L392702.  v10:= 0I;
  #L392704.  v12:= 1L;
  #L392708.  v14:= 0L;
  #L39270c.  v16:= v14 @kind wide;
  #L392710.  if v0 == 0 then goto L392796;
  #L392714.  v7:= v14 @kind wide;
  #L392716.  v18:= 0I;
  #L39271a.  v19:= lcmp(v5, v14);
  #L39271e.  if v19 == 0 then goto L392756;
  #L392722.  call temp:= `poll`(v0) @signature `Lk2/i;.poll:()Ljava/lang/Object;` @kind interface;
  #L392728.  v9:= temp @kind object;
  #L39272a.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L392730.  v18:= temp;
  #L392732.  if v18 == 0 then goto L392738;
  #L392736.  return @kind void;
  #L392738.  if v9 != 0 then goto L392742;
  #L39273c.  v18:= v9 @kind object;
  #L392740.  goto L392756;
  #L392742.  call `onNext`(v2, v9) @signature `Ld3/b;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L392748.  v16:= v16 + v12 @kind long;
  #L39274c.  v7:= v7 + v12 @kind long;
  #L39274e.  v5:= v5 - v12 @kind long;
  #L392750.  v18:= v9 @kind object;
  #L392754.  goto L39271a;
  #L392756.  v9:= lcmp(v7, v14);
  #L39275a.  if v9 == 0 then goto L39277c;
  #L39275e.  if v10 == 0 then goto L39276e;
  #L392762.  v5:= 9223372036854775807L;
  #L39276c.  goto L39277c;
  #L39276e.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392772.  v6:= -v7 @kind long;
  #L392774.  call temp:= `addAndGet`(v5, v6) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L39277a.  v5:= temp @kind wide;
  #L39277c.  v7:= lcmp(v5, v14);
  #L392780.  if v7 == 0 then goto L392796;
  #L392784.  if v18 != 0 then goto L39278a;
  #L392788.  goto L392796;
  #L39278a.  v7:= 9223372036854775807L;
  #L392794.  goto L392714;
  #L392796.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L39279a.  v7:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` @kind object;
  #L39279e.  v8:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L3927a2.  call temp:= `get`(v8) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L3927a8.  v8:= temp @kind object;
  #L3927aa.  v8:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v8 @kind object;
  #L3927ae.  v9:= length @variable v8;
  #L3927b0.  if v0 == 0 then goto L3927f0;
  #L3927b4.  if v7 == 0 then goto L3927c4;
  #L3927b8.  call temp:= `isEmpty`(v7) @signature `Lk2/j;.isEmpty:()Z` @kind interface;
  #L3927be.  v0:= temp;
  #L3927c0.  if v0 == 0 then goto L3927f0;
  #L3927c4.  if v9 != 0 then goto L3927f0;
  #L3927c8.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L3927cc.  call temp:= `b`(v0) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L3927d2.  v0:= temp @kind object;
  #L3927d4.  v3:= `@@io.reactivex.internal.util.ExceptionHelper.a` @type ^`java.lang.Throwable` @kind object;
  #L3927d8.  if v0 == v3 then goto L3927ee;
  #L3927dc.  if v0 != 0 then goto L3927e8;
  #L3927e0.  call `onComplete`(v2) @signature `Ld3/b;.onComplete:()V` @kind interface;
  #L3927e6.  goto L3927ee;
  #L3927e8.  call `a`(v2, v0) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L3927ee.  return @kind void;
  #L3927f0.  v18:= v4;
  #L3927f4.  if v9 == 0 then goto L3929fc;
  #L3927f8.  v3:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @type ^`long` @kind wide;
  #L3927fc.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @type ^`int`;
  #L392800.  if v9 <= v0 then goto L392814;
  #L392804.  v7:= v8[v0] @kind object;
  #L392808.  v11:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L39280c.  v7:= lcmp(v11, v3);
  #L392810.  if v7 == 0 then goto L392852;
  #L392814.  if v9 > v0 then goto L39281a;
  #L392818.  v0:= 0I;
  #L39281a.  v7:= 0I;
  #L39281c.  if v7 >= v9 then goto L392842;
  #L392820.  v11:= v8[v0] @kind object;
  #L392824.  v11:= v11.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L392828.  v13:= lcmp(v11, v3);
  #L39282c.  if v13 != 0 then goto L392832;
  #L392830.  goto L392842;
  #L392832.  v0:= v0 + 1;
  #L392836.  if v0 != v9 then goto L39283c;
  #L39283a.  v0:= 0I;
  #L39283c.  v7:= v7 + 1;
  #L392840.  goto L39281c;
  #L392842.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @type ^`int` := v0;
  #L392846.  v3:= v8[v0] @kind object;
  #L39284a.  v3:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L39284e.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @type ^`long` := v3 @kind wide;
  #L392852.  v3:= v0;
  #L392854.  v0:= 0I;
  #L392856.  v4:= 0I;
  #L392858.  if v4 >= v9 then goto L3929dc;
  #L39285c.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L392862.  v7:= temp;
  #L392864.  if v7 == 0 then goto L39286a;
  #L392868.  return @kind void;
  #L39286a.  v7:= v8[v3] @kind object;
  #L39286e.  v11:= 0I;
  #L392870.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L392876.  v12:= temp;
  #L392878.  if v12 == 0 then goto L39287e;
  #L39287c.  return @kind void;
  #L39287e.  v12:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` @kind object;
  #L392882.  if v12 != 0 then goto L392890;
  #L392886.  v13:= v8 @kind object;
  #L392888.  v22:= v9;
  #L39288c.  goto L39296e;
  #L392890.  v13:= v8 @kind object;
  #L392892.  v22:= v9;
  #L392896.  v8:= v14 @kind wide;
  #L392898.  v23:= lcmp(v5, v14);
  #L39289c.  if v23 == 0 then goto L392920;
  #L3928a0.  call temp:= `poll`(v12) @signature `Lk2/j;.poll:()Ljava/lang/Object;` @kind interface;
  #L3928a6.  v11:= temp @kind object;
  #L3928a8.  if v11 != 0 then goto L3928ae;
  #L3928ac.  goto L392920;
  #L3928ae.  call `onNext`(v2, v11) @signature `Ld3/b;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L3928b4.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L3928ba.  v23:= temp;
  #L3928bc.  if v23 == 0 then goto L3928c2;
  #L3928c0.  return @kind void;
  #L3928c2.  v20:= 1L;
  #L3928c6.  v5:= v5 - v20 @kind long;
  #L3928ca.  v8:= v8 + v20 @kind long;
  #L3928ce.  goto L392898;
  #L3928d0.  v0:= Exception @type ^`java.lang.Throwable` @kind object;
  #L3928d2.  v8:= v0 @kind object;
  #L3928d4.  call `b`(v8) @signature `Lf2/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L3928da.  call `e`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.e:()V` @kind virtual;
  #L3928e0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L3928e4.  call temp:= `a`(v0, v8) @signature `Lio/reactivex/internal/util/AtomicThrowable;.a:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L3928ea.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L3928ee.  if v0 != 0 then goto L3928fc;
  #L3928f2.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L3928f6.  call `cancel`(v0) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L3928fc.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L392902.  v0:= temp;
  #L392904.  if v0 == 0 then goto L39290a;
  #L392908.  return @kind void;
  #L39290a.  call `n`(v1, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.n:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @kind virtual;
  #L392910.  v4:= v4 + 1;
  #L392914.  v9:= v22;
  #L392918.  v0:= 1I;
  #L39291a.  v7:= 1L;
  #L39291e.  goto L3929ce;
  #L392920.  v12:= lcmp(v8, v14);
  #L392924.  if v12 == 0 then goto L392952;
  #L392928.  if v10 != 0 then goto L39293c;
  #L39292c.  v5:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392930.  v14:= -v8 @kind long;
  #L392932.  call temp:= `addAndGet`(v5, v14) @signature `Ljava/util/concurrent/atomic/AtomicLong;.addAndGet:(J)J` @kind virtual;
  #L392938.  v5:= temp @kind wide;
  #L39293a.  goto L392946;
  #L39293c.  v5:= 9223372036854775807L;
  #L392946.  call `b`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.b:(J)V` @kind virtual;
  #L39294c.  v8:= 0L;
  #L392950.  goto L392954;
  #L392952.  v8:= v14 @kind wide;
  #L392954.  v12:= lcmp(v5, v8);
  #L392958.  if v12 == 0 then goto L39296e;
  #L39295c.  if v11 != 0 then goto L392962;
  #L392960.  goto L39296e;
  #L392962.  v8:= v13 @kind object;
  #L392964.  v9:= v22;
  #L392968.  v14:= 0L;
  #L39296c.  goto L392870;
  #L39296e.  v8:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.done` @type ^`boolean` @kind boolean;
  #L392972.  v9:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` @kind object;
  #L392976.  if v8 == 0 then goto L3929aa;
  #L39297a.  if v9 == 0 then goto L39298a;
  #L39297e.  call temp:= `isEmpty`(v9) @signature `Lk2/j;.isEmpty:()Z` @kind interface;
  #L392984.  v8:= temp;
  #L392986.  if v8 == 0 then goto L3929aa;
  #L39298a.  call `n`(v1, v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.n:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @kind virtual;
  #L392990.  call temp:= `d`(v24) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.d:()Z` @kind virtual;
  #L392996.  v0:= temp;
  #L392998.  if v0 == 0 then goto L39299e;
  #L39299c.  return @kind void;
  #L39299e.  v7:= 1L;
  #L3929a2.  v16:= v16 + v7 @kind long;
  #L3929a6.  v0:= 1I;
  #L3929a8.  goto L3929ae;
  #L3929aa.  v7:= 1L;
  #L3929ae.  v11:= 0L;
  #L3929b2.  v9:= lcmp(v5, v11);
  #L3929b6.  if v9 != 0 then goto L3929c0;
  #L3929ba.  v9:= v0;
  #L3929bc.  v11:= 1I;
  #L3929be.  goto L3929e2;
  #L3929c0.  v3:= v3 + 1;
  #L3929c4.  v9:= v22;
  #L3929c8.  if v3 != v9 then goto L3929ce;
  #L3929cc.  v3:= 0I;
  #L3929ce.  v11:= 1I;
  #L3929d0.  v4:= v4 + v11 @kind int;
  #L3929d2.  v8:= v13 @kind object;
  #L3929d4.  v14:= 0L;
  #L3929d8.  goto L392858;
  #L3929dc.  v13:= v8 @kind object;
  #L3929de.  v11:= 1I;
  #L3929e0.  v9:= v0;
  #L3929e2.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastIndex` @type ^`int` := v3;
  #L3929e6.  v0:= v13[v3] @kind object;
  #L3929ea.  v3:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.id` @type ^`long` @kind wide;
  #L3929ee.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.lastId` @type ^`long` := v3 @kind wide;
  #L3929f2.  v3:= v16 @kind wide;
  #L3929f6.  v5:= 0L;
  #L3929fa.  goto L392a06;
  #L3929fc.  v11:= 1I;
  #L3929fe.  v5:= v14 @kind wide;
  #L392a00.  v3:= v16 @kind wide;
  #L392a04.  v9:= 0I;
  #L392a06.  v0:= lcmp(v3, v5);
  #L392a0a.  if v0 == 0 then goto L392a20;
  #L392a0e.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L392a12.  if v0 != 0 then goto L392a20;
  #L392a16.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L392a1a.  call `g`(v0, v3) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L392a20.  if v9 == 0 then goto L392a2c;
  #L392a24.  v4:= v18;
  #L392a28.  goto L3926ce;
  #L392a2c.  v3:= v18;
  #L392a30.  v0:= -v3 @kind int;
  #L392a32.  call temp:= `addAndGet`(v1, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L392a38.  v4:= temp;
  #L392a3a.  if v4 != 0 then goto L3926ce;
  #L392a3e.  return @kind void;
  catch `java.lang.Throwable` @[L3928a0..L3928a8] goto L3928d0;
}
procedure `k2.j` `k`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.k:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Lk2/j;` @AccessFlag  {
    temp;
    v0;
    v1;

  #L3924b0.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` @kind object;
  #L3924b4.  if v0 != 0 then goto L3924ca;
  #L3924b8.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L3924bc.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int`;
  #L3924c0.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L3924c6.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` := v0 @kind object;
  #L3924ca.  return v0 @kind object;
}
procedure `k2.j` `l`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.l:()Lk2/j;` @AccessFlag  {
    temp;
    v0;
    v1;

  #L3924dc.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` @kind object;
  #L3924e0.  if v0 != 0 then goto L392514;
  #L3924e4.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L3924e8.  v1:= 2147483647I;
  #L3924ee.  if v0 != v1 then goto L392502;
  #L3924f2.  v0:= new `io.reactivex.internal.queue.a`;
  #L3924f6.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int`;
  #L3924fa.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L392500.  goto L392510;
  #L392502.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L392506.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L39250a.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L392510.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` := v0 @kind object;
  #L392514.  return v0 @kind object;
}
procedure `void` `m`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v3 @kind object, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.m:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;Ljava/lang/Throwable;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L392a5c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L392a60.  call temp:= `a`(v0, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.a:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L392a66.  v0:= temp;
  #L392a68.  if v0 == 0 then goto L392ab8;
  #L392a6c.  v4:= 1I;
  #L392a6e.  v3.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.done` @type ^`boolean` := v4 @kind boolean;
  #L392a72.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L392a76.  if v3 != 0 then goto L392ab0;
  #L392a7a.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L392a7e.  call `cancel`(v3) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L392a84.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L392a88.  v4:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.b` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L392a8c.  call temp:= `getAndSet`(v3, v4) @signature `Ljava/util/concurrent/atomic/AtomicReference;.getAndSet:(Ljava/lang/Object;)Ljava/lang/Object;` @kind virtual;
  #L392a92.  v3:= temp @kind object;
  #L392a94.  v3:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v3 @kind object;
  #L392a98.  v4:= length @variable v3;
  #L392a9a.  v0:= 0I;
  #L392a9c.  if v0 >= v4 then goto L392ab0;
  #L392aa0.  v1:= v3[v0] @kind object;
  #L392aa4.  call `e`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.e:()V` @kind virtual;
  #L392aaa.  v0:= v0 + 1;
  #L392aae.  goto L392a9c;
  #L392ab0.  call `i`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.i:()V` @kind virtual;
  #L392ab6.  goto L392abe;
  #L392ab8.  call `q`(v4) @signature `Ll2/a;.q:(Ljava/lang/Throwable;)V` @kind static;
  #L392abe.  return @kind void;
}
procedure `void` `n`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v6 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v7 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.n:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;

  #L392cac.  v0:= v6.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L392cb0.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L392cb6.  v0:= temp @kind object;
  #L392cb8.  v0:= (`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[]) v0 @kind object;
  #L392cbc.  v1:= length @variable v0;
  #L392cbe.  if v1 != 0 then goto L392cc4;
  #L392cc2.  return @kind void;
  #L392cc4.  v2:= -1I;
  #L392cc6.  v3:= 0I;
  #L392cc8.  v4:= 0I;
  #L392cca.  if v4 >= v1 then goto L392ce0;
  #L392cce.  v5:= v0[v4] @kind object;
  #L392cd2.  if v5 != v7 then goto L392cda;
  #L392cd6.  v2:= v4;
  #L392cd8.  goto L392ce0;
  #L392cda.  v4:= v4 + 1;
  #L392cde.  goto L392cca;
  #L392ce0.  if v2 >= 0 then goto L392ce6;
  #L392ce4.  return @kind void;
  #L392ce6.  v4:= 1I;
  #L392ce8.  if v1 != v4 then goto L392cf2;
  #L392cec.  v1:= `@@io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.a` @type ^`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[] @kind object;
  #L392cf0.  goto L392d10;
  #L392cf2.  v5:= v1 + -1;
  #L392cf6.  v5:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`[v5];
  #L392cfa.  call `arraycopy`(v0, v3, v5, v3, v2) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L392d00.  v3:= v2 + 1;
  #L392d04.  v1:= v1 - v2 @kind int;
  #L392d06.  v1:= v1 - v4 @kind int;
  #L392d08.  call `arraycopy`(v0, v3, v5, v2, v1) @signature `Ljava/lang/System;.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V` @kind static;
  #L392d0e.  v1:= v5 @kind object;
  #L392d10.  v2:= v6.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.subscribers` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L392d14.  call temp:= `compareAndSet`(v2, v0, v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L392d1a.  v0:= temp;
  #L392d1c.  if v0 == 0 then goto L392cac;
  #L392d20.  return @kind void;
}
procedure `void` `o`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v7 @kind this, `java.lang.Object` v8 @kind object, `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber` v9 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.o:(Ljava/lang/Object;Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;

  #L392d64.  call temp:= `get`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L392d6a.  v0:= temp;
  #L392d6c.  v1:= "Inner queue full?!" @kind object;
  #L392d70.  if v0 != 0 then goto L392e1a;
  #L392d74.  v0:= 0I;
  #L392d76.  v2:= 1I;
  #L392d78.  call temp:= `compareAndSet`(v7, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L392d7e.  v0:= temp;
  #L392d80.  if v0 == 0 then goto L392e1a;
  #L392d84.  v0:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392d88.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L392d8e.  v2:= temp @kind wide;
  #L392d90.  v0:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` @kind object;
  #L392d94.  v4:= 0L;
  #L392d98.  v6:= lcmp(v2, v4);
  #L392d9c.  if v6 == 0 then goto L392de2;
  #L392da0.  if v0 == 0 then goto L392db0;
  #L392da4.  call temp:= `isEmpty`(v0) @signature `Lk2/j;.isEmpty:()Z` @kind interface;
  #L392daa.  v4:= temp;
  #L392dac.  if v4 == 0 then goto L392de2;
  #L392db0.  v0:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @type ^`d3.b` @kind object;
  #L392db4.  call `onNext`(v0, v8) @signature `Ld3/b;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L392dba.  v0:= 9223372036854775807L;
  #L392dc4.  v8:= lcmp(v2, v0);
  #L392dc8.  if v8 == 0 then goto L392dd6;
  #L392dcc.  v8:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392dd0.  call temp:= `decrementAndGet`(v8) @signature `Ljava/util/concurrent/atomic/AtomicLong;.decrementAndGet:()J` @kind virtual;
  #L392dd6.  v0:= 1L;
  #L392dda.  call `b`(v9, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.b:(J)V` @kind virtual;
  #L392de0.  goto L392e0c;
  #L392de2.  if v0 != 0 then goto L392dee;
  #L392de6.  call temp:= `k`(v7, v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.k:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Lk2/j;` @kind virtual;
  #L392dec.  v0:= temp @kind object;
  #L392dee.  call temp:= `offer`(v0, v8) @signature `Lk2/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L392df4.  v8:= temp;
  #L392df6.  if v8 != 0 then goto L392e0c;
  #L392dfa.  v8:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L392dfe.  call `<init>`(v8, v1) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L392e04.  call `a`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.a:(Ljava/lang/Throwable;)V` @kind virtual;
  #L392e0a.  return @kind void;
  #L392e0c.  call temp:= `decrementAndGet`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L392e12.  v8:= temp;
  #L392e14.  if v8 != 0 then goto L392e60;
  #L392e18.  return @kind void;
  #L392e1a.  v0:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` @kind object;
  #L392e1e.  if v0 != 0 then goto L392e34;
  #L392e22.  v0:= new `io.reactivex.internal.queue.SpscArrayQueue`;
  #L392e26.  v2:= v7.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.bufferSize` @type ^`int`;
  #L392e2a.  call `<init>`(v0, v2) @signature `Lio/reactivex/internal/queue/SpscArrayQueue;.<init>:(I)V` @kind direct;
  #L392e30.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber.queue` @type ^`k2.j` := v0 @kind object;
  #L392e34.  call temp:= `offer`(v0, v8) @signature `Lk2/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L392e3a.  v8:= temp;
  #L392e3c.  if v8 != 0 then goto L392e52;
  #L392e40.  v8:= new `io.reactivex.exceptions.MissingBackpressureException`;
  #L392e44.  call `<init>`(v8, v1) @signature `Lio/reactivex/exceptions/MissingBackpressureException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L392e4a.  call `a`(v7, v8) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.a:(Ljava/lang/Throwable;)V` @kind virtual;
  #L392e50.  return @kind void;
  #L392e52.  call temp:= `getAndIncrement`(v7) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L392e58.  v8:= temp;
  #L392e5a.  if v8 == 0 then goto L392e60;
  #L392e5e.  return @kind void;
  #L392e60.  call `j`(v7) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.j:()V` @kind virtual;
  #L392e66.  return @kind void;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L392ad0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L392ad4.  if v0 == 0 then goto L392ada;
  #L392ad8.  return @kind void;
  #L392ada.  v0:= 1I;
  #L392adc.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` := v0 @kind boolean;
  #L392ae0.  call `i`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.i:()V` @kind virtual;
  #L392ae6.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v5 @kind this, `java.lang.Object` v6 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L392b40.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.done` @type ^`boolean` @kind boolean;
  #L392b44.  if v0 == 0 then goto L392b4a;
  #L392b48.  return @kind void;
  #L392b4a.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.mapper` @type ^`h2.e` @kind object;
  #L392b4e.  call temp:= `apply`(v0, v6) @signature `Lh2/e;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L392b54.  v6:= temp @kind object;
  #L392b56.  v0:= "The mapper returned a null Publisher" @kind object;
  #L392b5a.  call temp:= `d`(v6, v0) @signature `Lj2/b;.d:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L392b60.  v6:= temp @kind object;
  #L392b62.  v6:= (`d3.a`) v6 @kind object;
  #L392b66.  v0:= instanceof @variable v6 @type ^`java.util.concurrent.Callable` @kind boolean;
  #L392b6a.  if v0 == 0 then goto L392bde;
  #L392b6e.  v6:= (`java.util.concurrent.Callable`) v6 @kind object;
  #L392b72.  call temp:= `call`(v6) @signature `Ljava/util/concurrent/Callable;.call:()Ljava/lang/Object;` @kind interface;
  #L392b78.  v6:= temp @kind object;
  #L392b7a.  if v6 == 0 then goto L392b86;
  #L392b7e.  call `p`(v5, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.p:(Ljava/lang/Object;)V` @kind virtual;
  #L392b84.  goto L392c08;
  #L392b86.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L392b8a.  v0:= 2147483647I;
  #L392b90.  if v6 == v0 then goto L392c08;
  #L392b94.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L392b98.  if v6 != 0 then goto L392c08;
  #L392b9c.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int`;
  #L392ba0.  v6:= v6 + 1;
  #L392ba4.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v6;
  #L392ba8.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @type ^`int`;
  #L392bac.  if v6 != v0 then goto L392c08;
  #L392bb0.  v6:= 0I;
  #L392bb2.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v6;
  #L392bb6.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L392bba.  v0:= (`long`) v0 @kind i2l;
  #L392bbc.  call `g`(v6, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L392bc2.  goto L392c08;
  #L392bc4.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L392bc6.  call `b`(v6) @signature `Lf2/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L392bcc.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.errs` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L392bd0.  call temp:= `a`(v0, v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.a:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L392bd6.  call `i`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.i:()V` @kind virtual;
  #L392bdc.  return @kind void;
  #L392bde.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMap$InnerSubscriber`;
  #L392be2.  v1:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.uniqueId` @type ^`long` @kind wide;
  #L392be6.  v3:= 1L;
  #L392bea.  v3:= v3 + v1 @kind long;
  #L392bec.  v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.uniqueId` @type ^`long` := v3 @kind wide;
  #L392bf0.  call `<init>`(v0, v5, v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;J)V` @kind direct;
  #L392bf6.  call temp:= `b`(v5, v0) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.b:(Lio/reactivex/internal/operators/flowable/FlowableFlatMap$InnerSubscriber;)Z` @kind virtual;
  #L392bfc.  v1:= temp;
  #L392bfe.  if v1 == 0 then goto L392c08;
  #L392c02.  call `a`(v6, v0) @signature `Ld3/a;.a:(Ld3/b;)V` @kind interface;
  #L392c08.  return @kind void;
  #L392c0a.  v6:= Exception @type ^`java.lang.Throwable` @kind object;
  #L392c0c.  call `b`(v6) @signature `Lf2/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L392c12.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L392c16.  call `cancel`(v0) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L392c1c.  call `a`(v5, v6) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.a:(Ljava/lang/Throwable;)V` @kind virtual;
  #L392c22.  return @kind void;
  catch `java.lang.Throwable` @[L392b4a..L392b66] goto L392c0a;
  catch `java.lang.Throwable` @[L392b6e..L392b7a] goto L392bc4;
}
procedure `void` `p`(`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber` v9 @kind this, `java.lang.Object` v10 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.p:(Ljava/lang/Object;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L392e78.  call temp:= `get`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L392e7e.  v0:= temp;
  #L392e80.  v1:= "Scalar queue full?!" @kind object;
  #L392e84.  if v0 != 0 then goto L392f5c;
  #L392e88.  v0:= 0I;
  #L392e8a.  v2:= 1I;
  #L392e8c.  call temp:= `compareAndSet`(v9, v0, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L392e92.  v3:= temp;
  #L392e94.  if v3 == 0 then goto L392f5c;
  #L392e98.  v3:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392e9c.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L392ea2.  v3:= temp @kind wide;
  #L392ea4.  v5:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.queue` @type ^`k2.i` @kind object;
  #L392ea8.  v6:= 0L;
  #L392eac.  v8:= lcmp(v3, v6);
  #L392eb0.  if v8 == 0 then goto L392f24;
  #L392eb4.  if v5 == 0 then goto L392ec4;
  #L392eb8.  call temp:= `isEmpty`(v5) @signature `Lk2/j;.isEmpty:()Z` @kind interface;
  #L392ebe.  v6:= temp;
  #L392ec0.  if v6 == 0 then goto L392f24;
  #L392ec4.  v1:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.actual` @type ^`d3.b` @kind object;
  #L392ec8.  call `onNext`(v1, v10) @signature `Ld3/b;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L392ece.  v5:= 9223372036854775807L;
  #L392ed8.  v10:= lcmp(v3, v5);
  #L392edc.  if v10 == 0 then goto L392eea;
  #L392ee0.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L392ee4.  call temp:= `decrementAndGet`(v10) @signature `Ljava/util/concurrent/atomic/AtomicLong;.decrementAndGet:()J` @kind virtual;
  #L392eea.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.maxConcurrency` @type ^`int`;
  #L392eee.  v1:= 2147483647I;
  #L392ef4.  if v10 == v1 then goto L392f4e;
  #L392ef8.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L392efc.  if v10 != 0 then goto L392f4e;
  #L392f00.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int`;
  #L392f04.  v10:= v10 + v2 @kind int;
  #L392f06.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v10;
  #L392f0a.  v1:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarLimit` @type ^`int`;
  #L392f0e.  if v10 != v1 then goto L392f4e;
  #L392f12.  v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.scalarEmitted` @type ^`int` := v0;
  #L392f16.  v10:= v9.`io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.upstream` @type ^`d3.c` @kind object;
  #L392f1a.  v0:= (`long`) v1 @kind i2l;
  #L392f1c.  call `g`(v10, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L392f22.  goto L392f4e;
  #L392f24.  if v5 != 0 then goto L392f30;
  #L392f28.  call temp:= `l`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.l:()Lk2/j;` @kind virtual;
  #L392f2e.  v5:= temp @kind object;
  #L392f30.  call temp:= `offer`(v5, v10) @signature `Lk2/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L392f36.  v10:= temp;
  #L392f38.  if v10 != 0 then goto L392f4e;
  #L392f3c.  v10:= new `java.lang.IllegalStateException`;
  #L392f40.  call `<init>`(v10, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L392f46.  call `a`(v9, v10) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.a:(Ljava/lang/Throwable;)V` @kind virtual;
  #L392f4c.  return @kind void;
  #L392f4e.  call temp:= `decrementAndGet`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L392f54.  v10:= temp;
  #L392f56.  if v10 != 0 then goto L392f90;
  #L392f5a.  return @kind void;
  #L392f5c.  call temp:= `l`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.l:()Lk2/j;` @kind virtual;
  #L392f62.  v0:= temp @kind object;
  #L392f64.  call temp:= `offer`(v0, v10) @signature `Lk2/j;.offer:(Ljava/lang/Object;)Z` @kind interface;
  #L392f6a.  v10:= temp;
  #L392f6c.  if v10 != 0 then goto L392f82;
  #L392f70.  v10:= new `java.lang.IllegalStateException`;
  #L392f74.  call `<init>`(v10, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L392f7a.  call `a`(v9, v10) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.a:(Ljava/lang/Throwable;)V` @kind virtual;
  #L392f80.  return @kind void;
  #L392f82.  call temp:= `getAndIncrement`(v9) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L392f88.  v10:= temp;
  #L392f8a.  if v10 == 0 then goto L392f90;
  #L392f8e.  return @kind void;
  #L392f90.  call `j`(v9) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMap$MergeSubscriber;.j:()V` @kind virtual;
  #L392f96.  return @kind void;
}

record `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` @kind class @AccessFlag FINAL extends `java.util.concurrent.atomic.AtomicInteger` @kind class, `b2.h` @kind interface, `d3.c` @kind interface {
  `java.util.concurrent.atomic.AtomicInteger` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @AccessFlag FINAL;
  `d3.b` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @AccessFlag FINAL;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.cancelled` @AccessFlag VOLATILE;
  `boolean` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.delayErrors` @AccessFlag FINAL;
  `io.reactivex.internal.util.AtomicThrowable` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @AccessFlag FINAL;
  `h2.e` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.mapper` @AccessFlag FINAL;
  `int` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicReference` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @AccessFlag FINAL;
  `java.util.concurrent.atomic.AtomicLong` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @AccessFlag FINAL;
  `d3.c` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @AccessFlag ;
  `e2.a` `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @AccessFlag FINAL;
}
global `long` `@@io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.serialVersionUID` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<init>`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v0 @kind this, `d3.b` v1 @kind object, `h2.e` v2 @kind object, `boolean` v3 , `int` v4 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.<init>:(Ld3/b;Lh2/e;ZI)V` @AccessFlag CONSTRUCTOR {
    temp;

  #L3930bc.  call `<init>`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:()V` @kind direct;
  #L3930c2.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` := v1 @kind object;
  #L3930c6.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.mapper` @type ^`h2.e` := v2 @kind object;
  #L3930ca.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.delayErrors` @type ^`boolean` := v3 @kind boolean;
  #L3930ce.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int` := v4;
  #L3930d2.  v1:= new `java.util.concurrent.atomic.AtomicLong`;
  #L3930d6.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicLong;.<init>:()V` @kind direct;
  #L3930dc.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` := v1 @kind object;
  #L3930e0.  v1:= new `e2.a`;
  #L3930e4.  call `<init>`(v1) @signature `Le2/a;.<init>:()V` @kind direct;
  #L3930ea.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` := v1 @kind object;
  #L3930ee.  v1:= new `io.reactivex.internal.util.AtomicThrowable`;
  #L3930f2.  call `<init>`(v1) @signature `Lio/reactivex/internal/util/AtomicThrowable;.<init>:()V` @kind direct;
  #L3930f8.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` := v1 @kind object;
  #L3930fc.  v1:= new `java.util.concurrent.atomic.AtomicInteger`;
  #L393100.  v2:= 1I;
  #L393102.  call `<init>`(v1, v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.<init>:(I)V` @kind direct;
  #L393108.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` := v1 @kind object;
  #L39310c.  v1:= new `java.util.concurrent.atomic.AtomicReference`;
  #L393110.  call `<init>`(v1) @signature `Ljava/util/concurrent/atomic/AtomicReference;.<init>:()V` @kind direct;
  #L393116.  v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` := v1 @kind object;
  #L39311a.  return @kind void;
}
procedure `void` `a`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v1 @kind this, `java.lang.Throwable` v2 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.a:(Ljava/lang/Throwable;)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L393678.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L39367c.  call temp:= `decrementAndGet`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L393682.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L393686.  call temp:= `a`(v0, v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.a:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L39368c.  v0:= temp;
  #L39368e.  if v0 == 0 then goto L3936ac;
  #L393692.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L393696.  if v2 != 0 then goto L3936a4;
  #L39369a.  v2:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L39369e.  call `e`(v2) @signature `Le2/a;.e:()V` @kind virtual;
  #L3936a4.  call `d`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.d:()V` @kind virtual;
  #L3936aa.  goto L3936b2;
  #L3936ac.  call `q`(v2) @signature `Ll2/a;.q:(Ljava/lang/Throwable;)V` @kind static;
  #L3936b2.  return @kind void;
}
procedure `void` `b`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.b:()V` @AccessFlag  {
    temp;
    v0;

  #L393158.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L39315c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L393162.  v0:= temp @kind object;
  #L393164.  v0:= (`io.reactivex.internal.queue.a`) v0 @kind object;
  #L393168.  if v0 == 0 then goto L393172;
  #L39316c.  call `clear`(v0) @signature `Lio/reactivex/internal/queue/a;.clear:()V` @kind virtual;
  #L393172.  return @kind void;
}
procedure `void` `c`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v2 @kind this, `d3.c` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.c:(Ld3/c;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L39374c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L393750.  call temp:= `i`(v0, v3) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.i:(Ld3/c;Ld3/c;)Z` @kind static;
  #L393756.  v0:= temp;
  #L393758.  if v0 == 0 then goto L393792;
  #L39375c.  v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` := v3 @kind object;
  #L393760.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L393764.  call `c`(v0, v2) @signature `Ld3/b;.c:(Ld3/c;)V` @kind interface;
  #L39376a.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int`;
  #L39376e.  v1:= 2147483647I;
  #L393774.  if v0 != v1 then goto L39378a;
  #L393778.  v0:= 9223372036854775807L;
  #L393782.  call `g`(v3, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L393788.  goto L393792;
  #L39378a.  v0:= (`long`) v0 @kind i2l;
  #L39378c.  call `g`(v3, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L393792.  return @kind void;
}
procedure `void` `cancel`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.cancel:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L39312c.  v0:= 1I;
  #L39312e.  v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.cancelled` @type ^`boolean` := v0 @kind boolean;
  #L393132.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L393136.  call `cancel`(v0) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L39313c.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L393140.  call `e`(v0) @signature `Le2/a;.e:()V` @kind virtual;
  #L393146.  return @kind void;
}
procedure `void` `d`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.d:()V` @AccessFlag  {
    temp;
    v0;

  #L393184.  call temp:= `getAndIncrement`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L39318a.  v0:= temp;
  #L39318c.  if v0 != 0 then goto L393196;
  #L393190.  call `e`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.e:()V` @kind virtual;
  #L393196.  return @kind void;
}
procedure `void` `e`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v17 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.e:()V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;
    v13;
    v14;
    v15;
    v16;

  #L3931a8.  v0:= v17 @kind object;
  #L3931ac.  v1:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L3931b0.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L3931b4.  v3:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L3931b8.  v4:= 1I;
  #L3931ba.  v5:= 1I;
  #L3931bc.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L3931c0.  call temp:= `get`(v6) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L3931c6.  v6:= temp @kind wide;
  #L3931c8.  v8:= 0L;
  #L3931cc.  v10:= v8 @kind wide;
  #L3931ce.  v12:= 0I;
  #L3931d0.  v13:= lcmp(v10, v6);
  #L3931d4.  if v13 == 0 then goto L393296;
  #L3931d8.  v14:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L3931dc.  if v14 == 0 then goto L3931e8;
  #L3931e0.  call `b`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.b:()V` @kind virtual;
  #L3931e6.  return @kind void;
  #L3931e8.  v14:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L3931ec.  if v14 != 0 then goto L39321e;
  #L3931f0.  v14:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L3931f4.  call temp:= `get`(v14) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L3931fa.  v14:= temp @kind object;
  #L3931fc.  v14:= (`java.lang.Throwable`) v14 @kind object;
  #L393200.  if v14 == 0 then goto L39321e;
  #L393204.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L393208.  call temp:= `b`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L39320e.  v2:= temp @kind object;
  #L393210.  call `b`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.b:()V` @kind virtual;
  #L393216.  call `a`(v1, v2) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L39321c.  return @kind void;
  #L39321e.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L393224.  v14:= temp;
  #L393226.  if v14 != 0 then goto L39322e;
  #L39322a.  v14:= 1I;
  #L39322c.  goto L393230;
  #L39322e.  v14:= 0I;
  #L393230.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L393236.  v15:= temp @kind object;
  #L393238.  v15:= (`io.reactivex.internal.queue.a`) v15 @kind object;
  #L39323c.  if v15 == 0 then goto L39324a;
  #L393240.  call temp:= `poll`(v15) @signature `Lio/reactivex/internal/queue/a;.poll:()Ljava/lang/Object;` @kind virtual;
  #L393246.  v15:= temp @kind object;
  #L393248.  goto L39324c;
  #L39324a.  v15:= 0I;
  #L39324c.  if v15 != 0 then goto L393256;
  #L393250.  v16:= 1I;
  #L393254.  goto L39325a;
  #L393256.  v16:= 0I;
  #L39325a.  if v14 == 0 then goto L393282;
  #L39325e.  if v16 == 0 then goto L393282;
  #L393262.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L393266.  call temp:= `b`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L39326c.  v2:= temp @kind object;
  #L39326e.  if v2 == 0 then goto L39327a;
  #L393272.  call `a`(v1, v2) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L393278.  goto L393280;
  #L39327a.  call `onComplete`(v1) @signature `Ld3/b;.onComplete:()V` @kind interface;
  #L393280.  return @kind void;
  #L393282.  if v16 == 0 then goto L393288;
  #L393286.  goto L393296;
  #L393288.  call `onNext`(v1, v15) @signature `Ld3/b;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L39328e.  v12:= 1L;
  #L393292.  v10:= v10 + v12 @kind long;
  #L393294.  goto L3931ce;
  #L393296.  if v13 != 0 then goto L393338;
  #L39329a.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L39329e.  if v6 == 0 then goto L3932aa;
  #L3932a2.  call `b`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.b:()V` @kind virtual;
  #L3932a8.  return @kind void;
  #L3932aa.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L3932ae.  if v6 != 0 then goto L3932e0;
  #L3932b2.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L3932b6.  call temp:= `get`(v6) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L3932bc.  v6:= temp @kind object;
  #L3932be.  v6:= (`java.lang.Throwable`) v6 @kind object;
  #L3932c2.  if v6 == 0 then goto L3932e0;
  #L3932c6.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L3932ca.  call temp:= `b`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L3932d0.  v2:= temp @kind object;
  #L3932d2.  call `b`(v17) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.b:()V` @kind virtual;
  #L3932d8.  call `a`(v1, v2) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L3932de.  return @kind void;
  #L3932e0.  call temp:= `get`(v2) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L3932e6.  v6:= temp;
  #L3932e8.  if v6 != 0 then goto L3932f0;
  #L3932ec.  v6:= 1I;
  #L3932ee.  goto L3932f2;
  #L3932f0.  v6:= 0I;
  #L3932f2.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L3932f8.  v7:= temp @kind object;
  #L3932fa.  v7:= (`io.reactivex.internal.queue.a`) v7 @kind object;
  #L3932fe.  if v7 == 0 then goto L39330e;
  #L393302.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/queue/a;.isEmpty:()Z` @kind virtual;
  #L393308.  v7:= temp;
  #L39330a.  if v7 == 0 then goto L393310;
  #L39330e.  v12:= 1I;
  #L393310.  if v6 == 0 then goto L393338;
  #L393314.  if v12 == 0 then goto L393338;
  #L393318.  v2:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L39331c.  call temp:= `b`(v2) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L393322.  v2:= temp @kind object;
  #L393324.  if v2 == 0 then goto L393330;
  #L393328.  call `a`(v1, v2) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L39332e.  goto L393336;
  #L393330.  call `onComplete`(v1) @signature `Ld3/b;.onComplete:()V` @kind interface;
  #L393336.  return @kind void;
  #L393338.  v6:= lcmp(v10, v8);
  #L39333c.  if v6 == 0 then goto L393362;
  #L393340.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L393344.  call temp:= `d`(v6, v10) @signature `Lio/reactivex/internal/util/b;.d:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L39334a.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int`;
  #L39334e.  v7:= 2147483647I;
  #L393354.  if v6 == v7 then goto L393362;
  #L393358.  v6:= v0.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L39335c.  call `g`(v6, v10) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L393362.  v5:= -v5 @kind int;
  #L393364.  call temp:= `addAndGet`(v0, v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.addAndGet:(I)I` @kind virtual;
  #L39336a.  v5:= temp;
  #L39336c.  if v5 != 0 then goto L3931bc;
  #L393370.  return @kind void;
}
procedure `void` `g`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v1 @kind this, `long` v2 ) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.g:(J)V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L3937a4.  call temp:= `h`(v2) @signature `Lio/reactivex/internal/subscriptions/SubscriptionHelper;.h:(J)Z` @kind static;
  #L3937aa.  v0:= temp;
  #L3937ac.  if v0 == 0 then goto L3937c0;
  #L3937b0.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L3937b4.  call temp:= `a`(v0, v2) @signature `Lio/reactivex/internal/util/b;.a:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L3937ba.  call `d`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.d:()V` @kind virtual;
  #L3937c0.  return @kind void;
}
procedure `io.reactivex.internal.queue.a` `h`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v3 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.h:()Lio/reactivex/internal/queue/a;` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;

  #L393070.  v0:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L393074.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L39307a.  v0:= temp @kind object;
  #L39307c.  v0:= (`io.reactivex.internal.queue.a`) v0 @kind object;
  #L393080.  if v0 == 0 then goto L393086;
  #L393084.  return v0 @kind object;
  #L393086.  v0:= new `io.reactivex.internal.queue.a`;
  #L39308a.  call temp:= `b`() @signature `Lb2/e;.b:()I` @kind static;
  #L393090.  v1:= temp;
  #L393092.  call `<init>`(v0, v1) @signature `Lio/reactivex/internal/queue/a;.<init>:(I)V` @kind direct;
  #L393098.  v1:= v3.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L39309c.  v2:= 0I;
  #L39309e.  call temp:= `compareAndSet`(v1, v2, v0) @signature `Ljava/util/concurrent/atomic/AtomicReference;.compareAndSet:(Ljava/lang/Object;Ljava/lang/Object;)Z` @kind virtual;
  #L3930a4.  v1:= temp;
  #L3930a6.  if v1 == 0 then goto L393070;
  #L3930aa.  return v0 @kind object;
}
procedure `void` `i`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v5 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver` v6 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.i:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L393384.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L393388.  call temp:= `a`(v0, v6) @signature `Le2/a;.a:(Le2/b;)Z` @kind virtual;
  #L39338e.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L393394.  v6:= temp;
  #L393396.  v0:= 1L;
  #L39339a.  v2:= 2147483647I;
  #L3933a0.  if v6 != 0 then goto L39343a;
  #L3933a4.  v6:= 0I;
  #L3933a6.  v3:= 1I;
  #L3933a8.  call temp:= `compareAndSet`(v5, v6, v3) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L3933ae.  v4:= temp;
  #L3933b0.  if v4 == 0 then goto L39343a;
  #L3933b4.  v4:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L3933b8.  call temp:= `decrementAndGet`(v4) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L3933be.  v4:= temp;
  #L3933c0.  if v4 != 0 then goto L3933c6;
  #L3933c4.  v6:= 1I;
  #L3933c6.  v3:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L3933ca.  call temp:= `get`(v3) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L3933d0.  v3:= temp @kind object;
  #L3933d2.  v3:= (`io.reactivex.internal.queue.a`) v3 @kind object;
  #L3933d6.  if v6 == 0 then goto L393412;
  #L3933da.  if v3 == 0 then goto L3933ea;
  #L3933de.  call temp:= `isEmpty`(v3) @signature `Lio/reactivex/internal/queue/a;.isEmpty:()Z` @kind virtual;
  #L3933e4.  v6:= temp;
  #L3933e6.  if v6 == 0 then goto L393412;
  #L3933ea.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L3933ee.  call temp:= `b`(v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L3933f4.  v6:= temp @kind object;
  #L3933f6.  if v6 == 0 then goto L393406;
  #L3933fa.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L3933fe.  call `a`(v0, v6) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L393404.  goto L393410;
  #L393406.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L39340a.  call `onComplete`(v6) @signature `Ld3/b;.onComplete:()V` @kind interface;
  #L393410.  return @kind void;
  #L393412.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int`;
  #L393416.  if v6 == v2 then goto L393424;
  #L39341a.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L39341e.  call `g`(v6, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L393424.  call temp:= `decrementAndGet`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L39342a.  v6:= temp;
  #L39342c.  if v6 != 0 then goto L393432;
  #L393430.  return @kind void;
  #L393432.  call `e`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.e:()V` @kind virtual;
  #L393438.  goto L39345c;
  #L39343a.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L39343e.  call temp:= `decrementAndGet`(v6) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L393444.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int`;
  #L393448.  if v6 == v2 then goto L393456;
  #L39344c.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L393450.  call `g`(v6, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L393456.  call `d`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.d:()V` @kind virtual;
  #L39345c.  return @kind void;
}
procedure `void` `j`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v2 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver` v3 @kind object, `java.lang.Throwable` v4 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.j:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver;Ljava/lang/Throwable;)V` @AccessFlag  {
    temp;
    v0;
    v1;

  #L393470.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L393474.  call temp:= `a`(v0, v3) @signature `Le2/a;.a:(Le2/b;)Z` @kind virtual;
  #L39347a.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L39347e.  call temp:= `a`(v3, v4) @signature `Lio/reactivex/internal/util/AtomicThrowable;.a:(Ljava/lang/Throwable;)Z` @kind virtual;
  #L393484.  v3:= temp;
  #L393486.  if v3 == 0 then goto L3934d6;
  #L39348a.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.delayErrors` @type ^`boolean` @kind boolean;
  #L39348e.  if v3 != 0 then goto L3934a8;
  #L393492.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L393496.  call `cancel`(v3) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L39349c.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L3934a0.  call `e`(v3) @signature `Le2/a;.e:()V` @kind virtual;
  #L3934a6.  goto L3934c4;
  #L3934a8.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int`;
  #L3934ac.  v4:= 2147483647I;
  #L3934b2.  if v3 == v4 then goto L3934c4;
  #L3934b6.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L3934ba.  v0:= 1L;
  #L3934be.  call `g`(v3, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L3934c4.  v3:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L3934c8.  call temp:= `decrementAndGet`(v3) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L3934ce.  call `d`(v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.d:()V` @kind virtual;
  #L3934d4.  goto L3934dc;
  #L3934d6.  call `q`(v4) @signature `Ll2/a;.q:(Ljava/lang/Throwable;)V` @kind static;
  #L3934dc.  return @kind void;
}
procedure `void` `k`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v5 @kind this, `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver` v6 @kind object, `java.lang.Object` v7 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.k:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver;Ljava/lang/Object;)V` @AccessFlag  {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L3934f0.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L3934f4.  call temp:= `a`(v0, v6) @signature `Le2/a;.a:(Le2/b;)Z` @kind virtual;
  #L3934fa.  call temp:= `get`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.get:()I` @kind virtual;
  #L393500.  v6:= temp;
  #L393502.  if v6 != 0 then goto L3935e4;
  #L393506.  v6:= 0I;
  #L393508.  v0:= 1I;
  #L39350a.  call temp:= `compareAndSet`(v5, v6, v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.compareAndSet:(II)Z` @kind virtual;
  #L393510.  v1:= temp;
  #L393512.  if v1 == 0 then goto L3935e4;
  #L393516.  v1:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L39351a.  call temp:= `decrementAndGet`(v1) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L393520.  v1:= temp;
  #L393522.  if v1 != 0 then goto L393528;
  #L393526.  v6:= 1I;
  #L393528.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L39352c.  call temp:= `get`(v0) @signature `Ljava/util/concurrent/atomic/AtomicLong;.get:()J` @kind virtual;
  #L393532.  v0:= temp @kind wide;
  #L393534.  v2:= 0L;
  #L393538.  v4:= lcmp(v0, v2);
  #L39353c.  if v4 == 0 then goto L3935be;
  #L393540.  v0:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L393544.  call `onNext`(v0, v7) @signature `Ld3/b;.onNext:(Ljava/lang/Object;)V` @kind interface;
  #L39354a.  v7:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.queue` @type ^`java.util.concurrent.atomic.AtomicReference` @kind object;
  #L39354e.  call temp:= `get`(v7) @signature `Ljava/util/concurrent/atomic/AtomicReference;.get:()Ljava/lang/Object;` @kind virtual;
  #L393554.  v7:= temp @kind object;
  #L393556.  v7:= (`io.reactivex.internal.queue.a`) v7 @kind object;
  #L39355a.  if v6 == 0 then goto L393596;
  #L39355e.  if v7 == 0 then goto L39356e;
  #L393562.  call temp:= `isEmpty`(v7) @signature `Lio/reactivex/internal/queue/a;.isEmpty:()Z` @kind virtual;
  #L393568.  v6:= temp;
  #L39356a.  if v6 == 0 then goto L393596;
  #L39356e.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.errors` @type ^`io.reactivex.internal.util.AtomicThrowable` @kind object;
  #L393572.  call temp:= `b`(v6) @signature `Lio/reactivex/internal/util/AtomicThrowable;.b:()Ljava/lang/Throwable;` @kind virtual;
  #L393578.  v6:= temp @kind object;
  #L39357a.  if v6 == 0 then goto L39358a;
  #L39357e.  v7:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L393582.  call `a`(v7, v6) @signature `Ld3/b;.a:(Ljava/lang/Throwable;)V` @kind interface;
  #L393588.  goto L393594;
  #L39358a.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.actual` @type ^`d3.b` @kind object;
  #L39358e.  call `onComplete`(v6) @signature `Ld3/b;.onComplete:()V` @kind interface;
  #L393594.  return @kind void;
  #L393596.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.requested` @type ^`java.util.concurrent.atomic.AtomicLong` @kind object;
  #L39359a.  v0:= 1L;
  #L39359e.  call temp:= `d`(v6, v0) @signature `Lio/reactivex/internal/util/b;.d:(Ljava/util/concurrent/atomic/AtomicLong;J)J` @kind static;
  #L3935a4.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.maxConcurrency` @type ^`int`;
  #L3935a8.  v7:= 2147483647I;
  #L3935ae.  if v6 == v7 then goto L3935d0;
  #L3935b2.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L3935b6.  call `g`(v6, v0) @signature `Ld3/c;.g:(J)V` @kind interface;
  #L3935bc.  goto L3935d0;
  #L3935be.  call temp:= `h`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.h:()Lio/reactivex/internal/queue/a;` @kind virtual;
  #L3935c4.  v6:= temp @kind object;
  #L3935c6.  @monitorenter v6
  #L3935c8.  call temp:= `offer`(v6, v7) @signature `Lio/reactivex/internal/queue/a;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L3935ce.  @monitorexit v6
  #L3935d0.  call temp:= `decrementAndGet`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L3935d6.  v6:= temp;
  #L3935d8.  if v6 != 0 then goto L39360e;
  #L3935dc.  return @kind void;
  #L3935de.  v7:= Exception @type ^`java.lang.Throwable` @kind object;
  #L3935e0.  @monitorexit v6
  #L3935e2.  throw v7;
  #L3935e4.  call temp:= `h`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.h:()Lio/reactivex/internal/queue/a;` @kind virtual;
  #L3935ea.  v6:= temp @kind object;
  #L3935ec.  @monitorenter v6
  #L3935ee.  call temp:= `offer`(v6, v7) @signature `Lio/reactivex/internal/queue/a;.offer:(Ljava/lang/Object;)Z` @kind virtual;
  #L3935f4.  @monitorexit v6
  #L3935f6.  v6:= v5.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L3935fa.  call temp:= `decrementAndGet`(v6) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L393600.  call temp:= `getAndIncrement`(v5) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L393606.  v6:= temp;
  #L393608.  if v6 == 0 then goto L39360e;
  #L39360c.  return @kind void;
  #L39360e.  call `e`(v5) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.e:()V` @kind virtual;
  #L393614.  return @kind void;
  #L393616.  v7:= Exception @type ^`java.lang.Throwable` @kind object;
  #L393618.  @monitorexit v6
  #L39361a.  throw v7;
  catch `java.lang.Throwable` @[L3935c8..L3935d0] goto L3935de;
  catch `java.lang.Throwable` @[L3935e0..L3935e2] goto L3935de;
  catch `java.lang.Throwable` @[L3935ee..L3935f6] goto L393616;
  catch `java.lang.Throwable` @[L393618..L39361a] goto L393616;
}
procedure `void` `onComplete`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v1 @kind this) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.onComplete:()V` @AccessFlag PUBLIC {
    temp;
    v0;

  #L393654.  v0:= v1.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L393658.  call temp:= `decrementAndGet`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.decrementAndGet:()I` @kind virtual;
  #L39365e.  call `d`(v1) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.d:()V` @kind virtual;
  #L393664.  return @kind void;
}
procedure `void` `onNext`(`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber` v2 @kind this, `java.lang.Object` v3 @kind object) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.onNext:(Ljava/lang/Object;)V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;

  #L3936c4.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.mapper` @type ^`h2.e` @kind object;
  #L3936c8.  call temp:= `apply`(v0, v3) @signature `Lh2/e;.apply:(Ljava/lang/Object;)Ljava/lang/Object;` @kind interface;
  #L3936ce.  v3:= temp @kind object;
  #L3936d0.  v0:= "The mapper returned a null MaybeSource" @kind object;
  #L3936d4.  call temp:= `d`(v3, v0) @signature `Lj2/b;.d:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;` @kind static;
  #L3936da.  v3:= temp @kind object;
  #L3936dc.  v3:= (`b2.m`) v3 @kind object;
  #L3936e0.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.active` @type ^`java.util.concurrent.atomic.AtomicInteger` @kind object;
  #L3936e4.  call temp:= `getAndIncrement`(v0) @signature `Ljava/util/concurrent/atomic/AtomicInteger;.getAndIncrement:()I` @kind virtual;
  #L3936ea.  v0:= new `io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver`;
  #L3936ee.  call `<init>`(v0, v2) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber$InnerObserver;.<init>:(Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;)V` @kind direct;
  #L3936f4.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.cancelled` @type ^`boolean` @kind boolean;
  #L3936f8.  if v1 != 0 then goto L393712;
  #L3936fc.  v1:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.set` @type ^`e2.a` @kind object;
  #L393700.  call temp:= `b`(v1, v0) @signature `Le2/a;.b:(Le2/b;)Z` @kind virtual;
  #L393706.  v1:= temp;
  #L393708.  if v1 == 0 then goto L393712;
  #L39370c.  call `a`(v3, v0) @signature `Lb2/m;.a:(Lb2/k;)V` @kind interface;
  #L393712.  return @kind void;
  #L393714.  v3:= Exception @type ^`java.lang.Throwable` @kind object;
  #L393716.  call `b`(v3) @signature `Lf2/a;.b:(Ljava/lang/Throwable;)V` @kind static;
  #L39371c.  v0:= v2.`io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe$FlatMapMaybeSubscriber.s` @type ^`d3.c` @kind object;
  #L393720.  call `cancel`(v0) @signature `Ld3/c;.cancel:()V` @kind interface;
  #L393726.  call `a`(v2, v3) @signature `Lio/reactivex/internal/operators/flowable/FlowableFlatMapMaybe$FlatMapMaybeSubscriber;.a:(Ljava/lang/Throwable;)V` @kind virtual;
  #L39372c.  return @kind void;
  catch `java.lang.Throwable` @[L3936c4..L3936e0] goto L393714;
}

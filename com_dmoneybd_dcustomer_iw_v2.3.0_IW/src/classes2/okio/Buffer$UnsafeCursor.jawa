record `okio.Buffer$UnsafeCursor` @kind class @AccessFlag PUBLIC_FINAL extends `java.io.Closeable` @kind interface {
  `okio.Buffer` `okio.Buffer$UnsafeCursor.buffer` @AccessFlag PUBLIC;
  `byte`[] `okio.Buffer$UnsafeCursor.data` @AccessFlag PUBLIC;
  `int` `okio.Buffer$UnsafeCursor.end` @AccessFlag PUBLIC;
  `long` `okio.Buffer$UnsafeCursor.offset` @AccessFlag PUBLIC;
  `boolean` `okio.Buffer$UnsafeCursor.readWrite` @AccessFlag PUBLIC;
  `okio.Segment` `okio.Buffer$UnsafeCursor.segment` @AccessFlag PRIVATE;
  `int` `okio.Buffer$UnsafeCursor.start` @AccessFlag PUBLIC;
}
procedure `void` `<init>`(`okio.Buffer$UnsafeCursor` v2 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {
    temp;
    v0;
    v1;

  #L2e2068.  call `<init>`(v2) @signature `Ljava/lang/Object;.<init>:()V` @kind direct;
  #L2e206e.  v0:= -1L;
  #L2e2072.  v2.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L2e2076.  v0:= -1I;
  #L2e2078.  v2.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L2e207c.  v2.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L2e2080.  return @kind void;
}
procedure `void` `close`(`okio.Buffer$UnsafeCursor` v3 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.close:()V` @AccessFlag PUBLIC {
    temp;
    v0;
    v1;
    v2;

  #L2e2094.  v0:= v3.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e2098.  if v0 == 0 then goto L2e20be;
  #L2e209c.  v0:= 0I;
  #L2e209e.  v3.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` := v0 @kind object;
  #L2e20a2.  v3.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v0 @kind object;
  #L2e20a6.  v1:= -1L;
  #L2e20aa.  v3.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v1 @kind wide;
  #L2e20ae.  v3.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L2e20b2.  v0:= -1I;
  #L2e20b4.  v3.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v0;
  #L2e20b8.  v3.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L2e20bc.  return @kind void;
  #L2e20be.  v0:= new `java.lang.IllegalStateException`;
  #L2e20c2.  v1:= "not attached to a buffer" @kind object;
  #L2e20c6.  call `<init>`(v0, v1) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e20cc.  throw v0;
}
procedure `long` `expandBuffer`(`okio.Buffer$UnsafeCursor` v9 @kind this, `int` v10 ) @signature `Lokio/Buffer$UnsafeCursor;.expandBuffer:(I)J` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;

  #L2e1e14.  if v10 <= 0 then goto L2e1ec2;
  #L2e1e18.  v0:= 8192I;
  #L2e1e1c.  if v10 > v0 then goto L2e1e94;
  #L2e1e20.  v1:= v9.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1e24.  if v1 == 0 then goto L2e1e84;
  #L2e1e28.  v2:= v9.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L2e1e2c.  if v2 == 0 then goto L2e1e74;
  #L2e1e30.  v2:= v1.`okio.Buffer.b` @type ^`long` @kind wide;
  #L2e1e34.  call temp:= `c`(v1, v10) @signature `Lokio/Buffer;.c:(I)Lokio/Segment;` @kind virtual;
  #L2e1e3a.  v10:= temp @kind object;
  #L2e1e3c.  v1:= v10.`okio.Segment.c` @type ^`int`;
  #L2e1e40.  v1:= v1 - 8192;
  #L2e1e44.  v10.`okio.Segment.c` @type ^`int` := v0;
  #L2e1e48.  v4:= v9.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1e4c.  v5:= (`long`) v1 @kind i2l;
  #L2e1e4e.  v7:= v2 + v5 @kind long;
  #L2e1e52.  v4.`okio.Buffer.b` @type ^`long` := v7 @kind wide;
  #L2e1e56.  v9.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v10 @kind object;
  #L2e1e5a.  v9.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v2 @kind wide;
  #L2e1e5e.  v10:= v10.`okio.Segment.a` @type ^`byte`[] @kind object;
  #L2e1e62.  v9.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v10 @kind object;
  #L2e1e66.  v10:= v1 - 8192;
  #L2e1e6a.  v9.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v10;
  #L2e1e6e.  v9.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v0;
  #L2e1e72.  return v5 @kind wide;
  #L2e1e74.  v10:= new `java.lang.IllegalStateException`;
  #L2e1e78.  v0:= "expandBuffer() only permitted for read/write buffers" @kind object;
  #L2e1e7c.  call `<init>`(v10, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e1e82.  throw v10;
  #L2e1e84.  v10:= new `java.lang.IllegalStateException`;
  #L2e1e88.  v0:= "not attached to a buffer" @kind object;
  #L2e1e8c.  call `<init>`(v10, v0) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e1e92.  throw v10;
  #L2e1e94.  v0:= new `java.lang.IllegalArgumentException`;
  #L2e1e98.  v1:= new `java.lang.StringBuilder`;
  #L2e1e9c.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L2e1ea2.  v2:= "minByteCount > Segment.SIZE: " @kind object;
  #L2e1ea6.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L2e1eac.  call temp:= `append`(v1, v10) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L2e1eb2.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L2e1eb8.  v10:= temp @kind object;
  #L2e1eba.  call `<init>`(v0, v10) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e1ec0.  throw v0;
  #L2e1ec2.  v0:= new `java.lang.IllegalArgumentException`;
  #L2e1ec6.  v1:= new `java.lang.StringBuilder`;
  #L2e1eca.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L2e1ed0.  v2:= "minByteCount <= 0: " @kind object;
  #L2e1ed4.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L2e1eda.  call temp:= `append`(v1, v10) @signature `Ljava/lang/StringBuilder;.append:(I)Ljava/lang/StringBuilder;` @kind virtual;
  #L2e1ee0.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L2e1ee6.  v10:= temp @kind object;
  #L2e1ee8.  call `<init>`(v0, v10) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e1eee.  throw v0;
}
procedure `int` `next`(`okio.Buffer$UnsafeCursor` v5 @kind this) @signature `Lokio/Buffer$UnsafeCursor;.next:()I` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;

  #L2e1c20.  v0:= v5.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L2e1c24.  v2:= v5.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1c28.  v2:= v2.`okio.Buffer.b` @type ^`long` @kind wide;
  #L2e1c2c.  v4:= lcmp(v0, v2);
  #L2e1c30.  if v4 == 0 then goto L2e1c5e;
  #L2e1c34.  v2:= -1L;
  #L2e1c38.  v4:= lcmp(v0, v2);
  #L2e1c3c.  if v4 != 0 then goto L2e1c4e;
  #L2e1c40.  v0:= 0L;
  #L2e1c44.  call temp:= `seek`(v5, v0) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @kind virtual;
  #L2e1c4a.  v0:= temp;
  #L2e1c4c.  return v0;
  #L2e1c4e.  v2:= v5.`okio.Buffer$UnsafeCursor.end` @type ^`int`;
  #L2e1c52.  v3:= v5.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L2e1c56.  v2:= v2 - v3 @kind int;
  #L2e1c58.  v2:= (`long`) v2 @kind i2l;
  #L2e1c5a.  v0:= v0 + v2 @kind long;
  #L2e1c5c.  goto L2e1c44;
  #L2e1c5e.  v0:= new `java.lang.IllegalStateException`;
  #L2e1c62.  call `<init>`(v0) @signature `Ljava/lang/IllegalStateException;.<init>:()V` @kind direct;
  #L2e1c68.  goto L2e1c6c;
  #L2e1c6a.  throw v0;
  #L2e1c6c.  goto L2e1c6a;
}
procedure `long` `resizeBuffer`(`okio.Buffer$UnsafeCursor` v13 @kind this, `long` v14 ) @signature `Lokio/Buffer$UnsafeCursor;.resizeBuffer:(J)J` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;
    v12;

  #L2e1f00.  v0:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1f04.  if v0 == 0 then goto L2e2042;
  #L2e1f08.  v1:= v13.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L2e1f0c.  if v1 == 0 then goto L2e2032;
  #L2e1f10.  v0:= v0.`okio.Buffer.b` @type ^`long` @kind wide;
  #L2e1f14.  v2:= 0L;
  #L2e1f18.  v4:= lcmp(v14, v0);
  #L2e1f1c.  if v4 > 0 then goto L2e1fbe;
  #L2e1f20.  v4:= lcmp(v14, v2);
  #L2e1f24.  if v4 < 0 then goto L2e1f90;
  #L2e1f28.  v4:= v0 - v14 @kind long;
  #L2e1f2c.  v6:= lcmp(v4, v2);
  #L2e1f30.  if v6 <= 0 then goto L2e1f76;
  #L2e1f34.  v6:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1f38.  v7:= v6.`okio.Buffer.a` @type ^`okio.Segment` @kind object;
  #L2e1f3c.  v7:= v7.`okio.Segment.g` @type ^`okio.Segment` @kind object;
  #L2e1f40.  v8:= v7.`okio.Segment.c` @type ^`int`;
  #L2e1f44.  v9:= v7.`okio.Segment.b` @type ^`int`;
  #L2e1f48.  v9:= v8 - v9 @kind int;
  #L2e1f4c.  v9:= (`long`) v9 @kind i2l;
  #L2e1f4e.  v11:= lcmp(v9, v4);
  #L2e1f52.  if v11 > 0 then goto L2e1f6c;
  #L2e1f56.  call temp:= `pop`(v7) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L2e1f5c.  v8:= temp @kind object;
  #L2e1f5e.  v6.`okio.Buffer.a` @type ^`okio.Segment` := v8 @kind object;
  #L2e1f62.  call `a`(v7) @signature `Lokio/SegmentPool;.a:(Lokio/Segment;)V` @kind static;
  #L2e1f68.  v4:= v4 - v9 @kind long;
  #L2e1f6a.  goto L2e1f2c;
  #L2e1f6c.  v2:= (`long`) v8 @kind i2l;
  #L2e1f6e.  v2:= v2 - v4 @kind long;
  #L2e1f70.  v3:= (`int`) v2 @kind l2i;
  #L2e1f72.  v7.`okio.Segment.c` @type ^`int` := v3;
  #L2e1f76.  v2:= 0I;
  #L2e1f78.  v13.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v2 @kind object;
  #L2e1f7c.  v13.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v14 @kind wide;
  #L2e1f80.  v13.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v2 @kind object;
  #L2e1f84.  v2:= -1I;
  #L2e1f86.  v13.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v2;
  #L2e1f8a.  v13.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v2;
  #L2e1f8e.  goto L2e2028;
  #L2e1f90.  v0:= new `java.lang.IllegalArgumentException`;
  #L2e1f94.  v1:= new `java.lang.StringBuilder`;
  #L2e1f98.  call `<init>`(v1) @signature `Ljava/lang/StringBuilder;.<init>:()V` @kind direct;
  #L2e1f9e.  v2:= "newSize < 0: " @kind object;
  #L2e1fa2.  call temp:= `append`(v1, v2) @signature `Ljava/lang/StringBuilder;.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;` @kind virtual;
  #L2e1fa8.  call temp:= `append`(v1, v14) @signature `Ljava/lang/StringBuilder;.append:(J)Ljava/lang/StringBuilder;` @kind virtual;
  #L2e1fae.  call temp:= `toString`(v1) @signature `Ljava/lang/StringBuilder;.toString:()Ljava/lang/String;` @kind virtual;
  #L2e1fb4.  v14:= temp @kind object;
  #L2e1fb6.  call `<init>`(v0, v14) @signature `Ljava/lang/IllegalArgumentException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e1fbc.  throw v0;
  #L2e1fbe.  v4:= lcmp(v14, v0);
  #L2e1fc2.  if v4 <= 0 then goto L2e2028;
  #L2e1fc6.  v4:= v14 - v0 @kind long;
  #L2e1fca.  v6:= 1I;
  #L2e1fcc.  v7:= 1I;
  #L2e1fce.  v8:= lcmp(v4, v2);
  #L2e1fd2.  if v8 <= 0 then goto L2e2028;
  #L2e1fd6.  v8:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1fda.  call temp:= `c`(v8, v6) @signature `Lokio/Buffer;.c:(I)Lokio/Segment;` @kind virtual;
  #L2e1fe0.  v8:= temp @kind object;
  #L2e1fe2.  v9:= v8.`okio.Segment.c` @type ^`int`;
  #L2e1fe6.  v9:= v9 - 8192;
  #L2e1fea.  v9:= (`long`) v9 @kind i2l;
  #L2e1fec.  call temp:= `min`(v4, v9) @signature `Ljava/lang/Math;.min:(JJ)J` @kind static;
  #L2e1ff2.  v9:= temp @kind wide;
  #L2e1ff4.  v10:= (`int`) v9 @kind l2i;
  #L2e1ff6.  v9:= v8.`okio.Segment.c` @type ^`int`;
  #L2e1ffa.  v9:= v9 + v10 @kind int;
  #L2e1ffc.  v8.`okio.Segment.c` @type ^`int` := v9;
  #L2e2000.  v11:= (`long`) v10 @kind i2l;
  #L2e2002.  v4:= v4 - v11 @kind long;
  #L2e2004.  if v7 == 0 then goto L2e1fce;
  #L2e2008.  v13.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v8 @kind object;
  #L2e200c.  v13.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v0 @kind wide;
  #L2e2010.  v7:= v8.`okio.Segment.a` @type ^`byte`[] @kind object;
  #L2e2014.  v13.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v7 @kind object;
  #L2e2018.  v7:= v9 - v10 @kind int;
  #L2e201c.  v13.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v7;
  #L2e2020.  v13.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v9;
  #L2e2024.  v7:= 0I;
  #L2e2026.  goto L2e1fce;
  #L2e2028.  v2:= v13.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e202c.  v2.`okio.Buffer.b` @type ^`long` := v14 @kind wide;
  #L2e2030.  return v0 @kind wide;
  #L2e2032.  v14:= new `java.lang.IllegalStateException`;
  #L2e2036.  v15:= "resizeBuffer() only permitted for read/write buffers" @kind object;
  #L2e203a.  call `<init>`(v14, v15) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e2040.  throw v14;
  #L2e2042.  v14:= new `java.lang.IllegalStateException`;
  #L2e2046.  v15:= "not attached to a buffer" @kind object;
  #L2e204a.  call `<init>`(v14, v15) @signature `Ljava/lang/IllegalStateException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e2050.  goto L2e2054;
  #L2e2052.  throw v14;
  #L2e2054.  goto L2e2052;
}
procedure `int` `seek`(`okio.Buffer$UnsafeCursor` v12 @kind this, `long` v13 ) @signature `Lokio/Buffer$UnsafeCursor;.seek:(J)I` @AccessFlag PUBLIC_FINAL {
    temp;
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    v8;
    v9;
    v10;
    v11;

  #L2e1c80.  v0:= -1L;
  #L2e1c84.  v2:= lcmp(v13, v0);
  #L2e1c88.  if v2 < 0 then goto L2e1dbc;
  #L2e1c8c.  v2:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1c90.  v3:= v2.`okio.Buffer.b` @type ^`long` @kind wide;
  #L2e1c94.  v5:= lcmp(v13, v3);
  #L2e1c98.  if v5 > 0 then goto L2e1dbc;
  #L2e1c9c.  v5:= lcmp(v13, v0);
  #L2e1ca0.  if v5 == 0 then goto L2e1da2;
  #L2e1ca4.  v0:= lcmp(v13, v3);
  #L2e1ca8.  if v0 != 0 then goto L2e1cb0;
  #L2e1cac.  goto L2e1da2;
  #L2e1cb0.  v0:= 0L;
  #L2e1cb4.  v2:= v2.`okio.Buffer.a` @type ^`okio.Segment` @kind object;
  #L2e1cb8.  v5:= v12.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` @kind object;
  #L2e1cbc.  if v5 == 0 then goto L2e1ce8;
  #L2e1cc0.  v6:= v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` @kind wide;
  #L2e1cc4.  v8:= v12.`okio.Buffer$UnsafeCursor.start` @type ^`int`;
  #L2e1cc8.  v9:= v5.`okio.Segment.b` @type ^`int`;
  #L2e1ccc.  v8:= v8 - v9 @kind int;
  #L2e1cce.  v8:= (`long`) v8 @kind i2l;
  #L2e1cd0.  v6:= v6 - v8 @kind long;
  #L2e1cd2.  v8:= lcmp(v6, v13);
  #L2e1cd6.  if v8 <= 0 then goto L2e1ce4;
  #L2e1cda.  v3:= v6 @kind wide;
  #L2e1cdc.  v11:= v5 @kind object;
  #L2e1cde.  v5:= v2 @kind object;
  #L2e1ce0.  v2:= v11 @kind object;
  #L2e1ce2.  goto L2e1cea;
  #L2e1ce4.  v0:= v6 @kind wide;
  #L2e1ce6.  goto L2e1cea;
  #L2e1ce8.  v5:= v2 @kind object;
  #L2e1cea.  v6:= v3 - v13 @kind long;
  #L2e1cee.  v8:= v13 - v0 @kind long;
  #L2e1cf2.  v10:= lcmp(v6, v8);
  #L2e1cf6.  if v10 <= 0 then goto L2e1d1e;
  #L2e1cfa.  v2:= v5.`okio.Segment.c` @type ^`int`;
  #L2e1cfe.  v3:= v5.`okio.Segment.b` @type ^`int`;
  #L2e1d02.  v4:= v2 - v3 @kind int;
  #L2e1d06.  v6:= (`long`) v4 @kind i2l;
  #L2e1d08.  v6:= v6 + v0 @kind long;
  #L2e1d0a.  v4:= lcmp(v13, v6);
  #L2e1d0e.  if v4 < 0 then goto L2e1d3e;
  #L2e1d12.  v2:= v2 - v3 @kind int;
  #L2e1d14.  v2:= (`long`) v2 @kind i2l;
  #L2e1d16.  v0:= v0 + v2 @kind long;
  #L2e1d18.  v5:= v5.`okio.Segment.f` @type ^`okio.Segment` @kind object;
  #L2e1d1c.  goto L2e1cfa;
  #L2e1d1e.  v0:= lcmp(v3, v13);
  #L2e1d22.  if v0 <= 0 then goto L2e1d3a;
  #L2e1d26.  v2:= v2.`okio.Segment.g` @type ^`okio.Segment` @kind object;
  #L2e1d2a.  v0:= v2.`okio.Segment.c` @type ^`int`;
  #L2e1d2e.  v1:= v2.`okio.Segment.b` @type ^`int`;
  #L2e1d32.  v0:= v0 - v1 @kind int;
  #L2e1d34.  v0:= (`long`) v0 @kind i2l;
  #L2e1d36.  v3:= v3 - v0 @kind long;
  #L2e1d38.  goto L2e1d1e;
  #L2e1d3a.  v5:= v2 @kind object;
  #L2e1d3c.  v0:= v3 @kind wide;
  #L2e1d3e.  v2:= v12.`okio.Buffer$UnsafeCursor.readWrite` @type ^`boolean` @kind boolean;
  #L2e1d42.  if v2 == 0 then goto L2e1d78;
  #L2e1d46.  v2:= v5.`okio.Segment.d` @type ^`boolean` @kind boolean;
  #L2e1d4a.  if v2 == 0 then goto L2e1d78;
  #L2e1d4e.  call temp:= `b`(v5) @signature `Lokio/Segment;.b:()Lokio/Segment;` @kind virtual;
  #L2e1d54.  v2:= temp @kind object;
  #L2e1d56.  v3:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1d5a.  v4:= v3.`okio.Buffer.a` @type ^`okio.Segment` @kind object;
  #L2e1d5e.  if v4 != v5 then goto L2e1d66;
  #L2e1d62.  v3.`okio.Buffer.a` @type ^`okio.Segment` := v2 @kind object;
  #L2e1d66.  call temp:= `push`(v5, v2) @signature `Lokio/Segment;.push:(Lokio/Segment;)Lokio/Segment;` @kind virtual;
  #L2e1d6c.  v5:= temp @kind object;
  #L2e1d6e.  v2:= v5.`okio.Segment.g` @type ^`okio.Segment` @kind object;
  #L2e1d72.  call temp:= `pop`(v2) @signature `Lokio/Segment;.pop:()Lokio/Segment;` @kind virtual;
  #L2e1d78.  v12.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v5 @kind object;
  #L2e1d7c.  v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v13 @kind wide;
  #L2e1d80.  v2:= v5.`okio.Segment.a` @type ^`byte`[] @kind object;
  #L2e1d84.  v12.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v2 @kind object;
  #L2e1d88.  v2:= v5.`okio.Segment.b` @type ^`int`;
  #L2e1d8c.  v13:= v13 - v0 @kind long;
  #L2e1d8e.  v14:= (`int`) v13 @kind l2i;
  #L2e1d90.  v2:= v2 + v14 @kind int;
  #L2e1d92.  v12.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v2;
  #L2e1d96.  v13:= v5.`okio.Segment.c` @type ^`int`;
  #L2e1d9a.  v12.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v13;
  #L2e1d9e.  v13:= v13 - v2 @kind int;
  #L2e1da0.  return v13;
  #L2e1da2.  v0:= 0I;
  #L2e1da4.  v12.`okio.Buffer$UnsafeCursor.segment` @type ^`okio.Segment` := v0 @kind object;
  #L2e1da8.  v12.`okio.Buffer$UnsafeCursor.offset` @type ^`long` := v13 @kind wide;
  #L2e1dac.  v12.`okio.Buffer$UnsafeCursor.data` @type ^`byte`[] := v0 @kind object;
  #L2e1db0.  v13:= -1I;
  #L2e1db2.  v12.`okio.Buffer$UnsafeCursor.start` @type ^`int` := v13;
  #L2e1db6.  v12.`okio.Buffer$UnsafeCursor.end` @type ^`int` := v13;
  #L2e1dba.  return v13;
  #L2e1dbc.  v0:= new `java.lang.ArrayIndexOutOfBoundsException`;
  #L2e1dc0.  v1:= 2I;
  #L2e1dc2.  v1:= new `java.lang.Object`[v1];
  #L2e1dc6.  v2:= 0I;
  #L2e1dc8.  call temp:= `valueOf`(v13) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L2e1dce.  v13:= temp @kind object;
  #L2e1dd0.  v1[v2]:= v13 @kind object;
  #L2e1dd4.  v13:= 1I;
  #L2e1dd6.  v14:= v12.`okio.Buffer$UnsafeCursor.buffer` @type ^`okio.Buffer` @kind object;
  #L2e1dda.  v2:= v14.`okio.Buffer.b` @type ^`long` @kind wide;
  #L2e1dde.  call temp:= `valueOf`(v2) @signature `Ljava/lang/Long;.valueOf:(J)Ljava/lang/Long;` @kind static;
  #L2e1de4.  v14:= temp @kind object;
  #L2e1de6.  v1[v13]:= v14 @kind object;
  #L2e1dea.  v13:= "offset=%s > size=%s" @kind object;
  #L2e1dee.  call temp:= `format`(v13, v1) @signature `Ljava/lang/String;.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;` @kind static;
  #L2e1df4.  v13:= temp @kind object;
  #L2e1df6.  call `<init>`(v0, v13) @signature `Ljava/lang/ArrayIndexOutOfBoundsException;.<init>:(Ljava/lang/String;)V` @kind direct;
  #L2e1dfc.  goto L2e1e00;
  #L2e1dfe.  throw v0;
  #L2e1e00.  goto L2e1dfe;
}

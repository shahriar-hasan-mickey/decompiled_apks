record `org.spongycastle.crypto.modes.gcm.GCMUtil` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `int` `@@org.spongycastle.crypto.modes.gcm.GCMUtil.E1` @AccessFlag PRIVATE_STATIC_FINAL;
global `long` `@@org.spongycastle.crypto.modes.gcm.GCMUtil.E1L` @AccessFlag PRIVATE_STATIC_FINAL;
global `int`[] `@@org.spongycastle.crypto.modes.gcm.GCMUtil.LOOKUP` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<clinit>`() @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.<clinit>:()V` @AccessFlag STATIC_CONSTRUCTOR {

  # return;
}
procedure `void` `<init>`(`org.spongycastle.crypto.modes.gcm.GCMUtil` v0 @kind this) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {

  # return;
}
procedure `int` `a`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.a:([I)I` @AccessFlag STATIC {

  # return;
}
procedure `void` `asBytes`(`int`[] v1 @kind object, `byte`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asBytes:([I[B)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `asBytes`(`long`[] v1 @kind object, `byte`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asBytes:([J[B)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `asBytes`(`int`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asBytes:([I)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `asBytes`(`long`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asBytes:([J)[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `asInts`(`byte`[] v1 @kind object, `int`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asInts:([B[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `asInts`(`byte`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asInts:([B)[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `asLongs`(`byte`[] v1 @kind object, `long`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asLongs:([B[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `asLongs`(`byte`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.asLongs:([B)[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `b`(`int`[] v4 @kind object, `int`[] v5 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.b:([I[I)I` @AccessFlag STATIC {

  # return;
}
procedure `int` `c`(`int`[] v5 @kind object, `int` v6 ) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.c:([II)I` @AccessFlag STATIC {

  # return;
}
procedure `int` `d`(`int`[] v5 @kind object, `int` v6 , `int`[] v7 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.d:([II[I)I` @AccessFlag STATIC {

  # return;
}
procedure `int`[] `generateLookup`() @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.generateLookup:()[I` @AccessFlag PRIVATE_STATIC {

  # return;
}
procedure `void` `multiply`(`byte`[] v1 @kind object, `byte`[] v2 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiply:([B[B)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `multiply`(`int`[] v17 @kind object, `int`[] v18 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiply:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `multiply`(`long`[] v19 @kind object, `long`[] v20 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiply:([J[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `multiplyP`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiplyP:([I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `multiplyP`(`int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiplyP:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `multiplyP8`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiplyP8:([I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `multiplyP8`(`int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.multiplyP8:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `byte`[] `oneAsBytes`() @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.oneAsBytes:()[B` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `oneAsInts`() @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.oneAsInts:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `oneAsLongs`() @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.oneAsLongs:()[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`byte`[] v3 @kind object, `byte`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([B[B)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`byte`[] v2 @kind object, `byte`[] v3 @kind object, `int` v4 , `int` v5 ) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([B[BII)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`byte`[] v3 @kind object, `byte`[] v4 @kind object, `byte`[] v5 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([B[B[B)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`int`[] v3 @kind object, `int`[] v4 @kind object, `int`[] v5 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`long`[] v5 @kind object, `long`[] v6 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([J[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `xor`(`long`[] v5 @kind object, `long`[] v6 @kind object, `long`[] v7 @kind object) @signature `Lorg/spongycastle/crypto/modes/gcm/GCMUtil;.xor:([J[J[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}

record `org.spongycastle.math.raw.Nat128` @kind class @AccessFlag PUBLIC_ABSTRACT {
}
global `long` `@@org.spongycastle.math.raw.Nat128.M` @AccessFlag PRIVATE_STATIC_FINAL;
procedure `void` `<init>`(`org.spongycastle.math.raw.Nat128` v0 @kind this) @signature `Lorg/spongycastle/math/raw/Nat128;.<init>:()V` @AccessFlag PUBLIC_CONSTRUCTOR {

  # return;
}
procedure `int` `add`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.add:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addBothTo`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.addBothTo:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addTo`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat128;.addTo:([II[III)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addTo`(`int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.addTo:([I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `addToEachOther`(`int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat128;.addToEachOther:([II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `copy`(`int`[] v2 @kind object, `int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.copy:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `copy64`(`long`[] v3 @kind object, `long`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.copy64:([J[J)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `create`() @signature `Lorg/spongycastle/math/raw/Nat128;.create:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `create64`() @signature `Lorg/spongycastle/math/raw/Nat128;.create64:()[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `createExt`() @signature `Lorg/spongycastle/math/raw/Nat128;.createExt:()[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `createExt64`() @signature `Lorg/spongycastle/math/raw/Nat128;.createExt64:()[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `diff`(`int`[] v7 @kind object, `int` v8 , `int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 ) @signature `Lorg/spongycastle/math/raw/Nat128;.diff:([II[II[II)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `eq`(`int`[] v3 @kind object, `int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.eq:([I[I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `eq64`(`long`[] v7 @kind object, `long`[] v8 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.eq64:([J[J)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int`[] `fromBigInteger`(`java.math.BigInteger` v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.fromBigInteger:(Ljava/math/BigInteger;)[I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long`[] `fromBigInteger64`(`java.math.BigInteger` v5 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.fromBigInteger64:(Ljava/math/BigInteger;)[J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `getBit`(`int`[] v3 @kind object, `int` v4 ) @signature `Lorg/spongycastle/math/raw/Nat128;.getBit:([II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `gte`(`int`[] v5 @kind object, `int` v6 , `int`[] v7 @kind object, `int` v8 ) @signature `Lorg/spongycastle/math/raw/Nat128;.gte:([II[II)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `gte`(`int`[] v5 @kind object, `int`[] v6 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.gte:([I[I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isOne`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.isOne:([I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isOne64`(`long`[] v8 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.isOne64:([J)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isZero`(`int`[] v3 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.isZero:([I)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `boolean` `isZero64`(`long`[] v7 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.isZero64:([J)Z` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `mul`(`int`[] v23 @kind object, `int` v24 , `int`[] v25 @kind object, `int` v26 , `int`[] v27 @kind object, `int` v28 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mul:([II[II[II)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `mul`(`int`[] v25 @kind object, `int`[] v26 @kind object, `int`[] v27 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.mul:([I[I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `long` `mul33Add`(`int` v13 , `int`[] v14 @kind object, `int` v15 , `int`[] v16 @kind object, `int` v17 , `int`[] v18 @kind object, `int` v19 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mul33Add:(I[II[II[II)J` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mul33DWordAdd`(`int` v10 , `long` v11 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mul33DWordAdd:(IJ[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mul33WordAdd`(`int` v10 , `int` v11 , `int`[] v12 @kind object, `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mul33WordAdd:(II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulAddTo`(`int`[] v27 @kind object, `int` v28 , `int`[] v29 @kind object, `int` v30 , `int`[] v31 @kind object, `int` v32 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mulAddTo:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulAddTo`(`int`[] v26 @kind object, `int`[] v27 @kind object, `int`[] v28 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.mulAddTo:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWord`(`int` v8 , `int`[] v9 @kind object, `int`[] v10 @kind object, `int` v11 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mulWord:(I[I[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordAddExt`(`int` v11 , `int`[] v12 @kind object, `int` v13 , `int`[] v14 @kind object, `int` v15 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mulWordAddExt:(I[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordDwordAdd`(`int` v10 , `long` v11 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mulWordDwordAdd:(IJ[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `mulWordsAdd`(`int` v8 , `int` v9 , `int`[] v10 @kind object, `int` v11 ) @signature `Lorg/spongycastle/math/raw/Nat128;.mulWordsAdd:(II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `square`(`int`[] v24 @kind object, `int` v25 , `int`[] v26 @kind object, `int` v27 ) @signature `Lorg/spongycastle/math/raw/Nat128;.square:([II[II)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `square`(`int`[] v24 @kind object, `int`[] v25 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.square:([I[I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `sub`(`int`[] v9 @kind object, `int` v10 , `int`[] v11 @kind object, `int` v12 , `int`[] v13 @kind object, `int` v14 ) @signature `Lorg/spongycastle/math/raw/Nat128;.sub:([II[II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `sub`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.sub:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subBothFrom`(`int`[] v10 @kind object, `int`[] v11 @kind object, `int`[] v12 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.subBothFrom:([I[I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subFrom`(`int`[] v10 @kind object, `int` v11 , `int`[] v12 @kind object, `int` v13 ) @signature `Lorg/spongycastle/math/raw/Nat128;.subFrom:([II[II)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `int` `subFrom`(`int`[] v10 @kind object, `int`[] v11 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.subFrom:([I[I)I` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `java.math.BigInteger` `toBigInteger`(`int`[] v4 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.toBigInteger:([I)Ljava/math/BigInteger;` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `java.math.BigInteger` `toBigInteger64`(`long`[] v7 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.toBigInteger64:([J)Ljava/math/BigInteger;` @AccessFlag PUBLIC_STATIC {

  # return;
}
procedure `void` `zero`(`int`[] v2 @kind object) @signature `Lorg/spongycastle/math/raw/Nat128;.zero:([I)V` @AccessFlag PUBLIC_STATIC {

  # return;
}
